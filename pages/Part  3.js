Part 3
Enhancing your functional skills
Parts 1 and 2 of this book taught you about the tools you need to apply func- tional programming to solve real-world scenarios. You learned new techniques and design patterns, all targeted at eliminating side effects so you can write code that’s modular, extensible, and easy to reason about. In this part of the book, you’ll use this learning to tackle the challenges of unit testing JavaScript applica- tions, optimizing your code under the functional umbrella, and handling the complexities of dealing with asynchronous events and data.
Chapter 6 focuses on unit testing imperative applications and why FP is inher- ently testable and less complex. Achieving referential transparency also leads to an automated testing modality called property-based testing.
Chapter 7 explores the inner workings of JavaScript’s function context as well as the performance considerations that must be taken into account when using deeply nested function closures and recursion. To improve overall appli- cation performance, you’ll learn about lazy evaluation, memoization, and tail- call optimization.
Finally, in chapter 8, you’ll learn more monadic design patterns to combat the increasing complexity of applications. This chapter focuses specifically on two frequent JavaScript tasks: fetching data asynchronously from a server or a database using promises, and cutting down on traditional function callbacks of event-driven programs by approaching them from a reactive mindset using RxJS.
<p className="pag">Page 152</p>
After reading through this entire book, you should be equipped to become suc- cessful at applying functional programming techniques during your professional endeavors.
