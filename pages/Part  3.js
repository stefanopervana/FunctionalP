Part 3
Enhancing your functional skills
Parts 1 and 2 of this book taught you about the tools you need to apply functional programming to solve real-world scenarios. You learned new techniques and design patterns, all targeted at eliminating side effects so you can write code that’s modular, extensible, and easy to reason about. In this part of the book, you’ll use this learning to tackle the challenges of unit testing JavaScript applications, optimizing your code under the functional umbrella, and handling the complexities of dealing with asynchronous events and data.
Chapter 6 focuses on unit testing imperative applications and why FP is inherently testable and less complex. Achieving referential transparency also leads to an automated testing modality called property-based testing.
Chapter 7 explores the inner workings of JavaScript’s function context as well as the performance considerations that must be taken into account when using deeply nested function closures and recursion. To improve overall application performance, you’ll learn about lazy evaluation, memoization, and tailcall optimization.
Finally, in chapter 8, you’ll learn more monadic design patterns to combat the increasing complexity of applications. This chapter focuses specifically on two frequent JavaScript tasks: fetching data asynchronously from a server or a database using promises, and cutting down on traditional function callbacks of event-driven programs by approaching them from a reactive mindset using RxJS.
<p className="pag">Page 152</p>
After reading through this entire book, you should be equipped to become successful at applying functional programming techniques during your professional endeavors.
