Searching 21 files for "- "

C:\Users\Emanuela\FunctionalP\pages\Anexo.js:
    1: Page 235 - 
    2  
    3  Chapter appendix
    .
    6  Because JavaScript isn’t a pure functional language, you have to rely on the help of third-party libraries that you can load into your project to emulate features, such as currying, composition, memoization, lazy evaluation, immutability, and so on, that are core in purer functional languages like Haskell. The libraries eliminate the need for you to implement the features yourself, so that you can focus on writing your business logic functions and delegate the orchestration of this code to these libraries. This section lists the functional libraries used throughout this book. These libraries are designed to do the following:
    7  ■	Fill in any gaps of standard JavaScript environments by providing additional language constructs and high-level utility functions that encourage you to write code using simple functions
    8: ■	When using JavaScript on the client, ensure that the functionality is consis- tent across browser vendors
    9: ■	Abstract out the internals of functional programming techniques like curry- ing, composition, partial evaluation, lazy evaluation, and others in a consis- tent manner
   10  For each library, I’ll include installation instructions for both browser and server (Node.js) environments.
   11  Lodash
   ..
   20  -	Node: $npm i --save lodash
   21  Ramda
   22: This utility library is designed specifically for functional programming, which facili- tates the creation of function pipelines. All of Ramda’s functions are immutable and side effect-free. In addition, all the functions have automatic currying, and its param- eters are arranged to be convenient for currying and composition. Ramda also con- tains property lenses, which are used in this book to read/write the properties of objects in an immutable manner.
   23  ■	Version: 0.18.0
   24  ■	Home page: http://ramdajs.com/
   ..
   27  -	Node: $npm install ramda
   28  RxJS
   29: The Reactive Extensions for JavaScript implement a paradigm known as reactive pro- gramming, which combines the best ideas of the observer pattern, iterator pattern, and functional programming to yield a library that facilitates writing asynchronous and event-based programs.
   30  ■	Version: 4.0.7
   31  ■	Parent project home page: http://reactivex.io/
   ..
   38  This book also uses nonfunctional libraries to take care of some additional aspects of software development like logging, testing, and static code analysis.
   39  Log4js
   40: Log4JavaScript is a client-side logging framework that follows the same “Log4X” design of packages as other languages, such as Log4j (Java), log4php (PHP), and oth- ers. This library is commonly used for enterprise-level logging, which is much more powerful than the typical console.log.
   41  ■	Version: 1.0.0
   42  ■	Home page: http://stritti.github.io/log4js/
   ..
   71  -	Node: $npm instali blanket
   72  JSCheck
   73: JSCheck is a specification-driven (property-based) testing library for JavaScript written by Douglas Crockford and inspired by Haskell’s QuickCheck project. From the descrip- tion of the properties of a function, it generates random test cases that attempt to prove those properties.
   74  ■	Home page: www.jscheck.org/
   75  ■	Installation:
   76  -	Browser: <script src="jscheck.js"></script>
   77  -	Node: $npm instali jscheck
   78: Page 239 - Chapter index
   79  Symbols
   80  () operator 39
   ..
  118  asynchronous events and data 205-234
  119  challenges of asynchronous code 206-213
  120: creating temporal depen- dencies among functions 207-208
  121  falling into callback pyramid 208-210
  122  using continuation-passing style 210-213
  ...
  160  gathering resuits with _.reduce 65-68
  161  lambda expressions 61-62
  162: removing unwanted ele- menti with _.filter 68-70
  163  transforming data with _.map 62-64
  164  methods 59-60
  ...
  173  emulating blocked-scope variables 52-53
  174  emulating private variables 50-52
  175: making asynchronous server- side calls 52
  176: code coverage, measuring effec- tiveness through 172-179
  177  measuring complexity of functional code 177
  178  measuring effectiveness of testing functional code 173-177
  ...
  200  control flow
  201  managing with functional combinators 112-116
  202: alternation (OR- combinator) 113-114
  203  fork (join) combinator 115-116
  204  identity (I-combinator) 112
  ...
  219  curried function evaluation 92-98
  220  emulating function factories 95-97
  221: implementing reusable func- tion templates 97-98
  222  curry function 160 curry2 function 95 currying 12
  223  function context stack and 183-186
  ...
  235  db variable 11
  236  declarative function chains 71-74
  237: declarative, functional program- ming as 7-9
  238  decodeURIComponent function 140
  239  decomposition of complex tasks 16-18
  ...
  255  ECMAScript 24
  256  effectiveness, measuring through code coverage 172-179
  257: measuring complexity of func- tional code 177
  258  measuring effectiveness of testing functional code 173-177
  259  Either monad overview 162-164
  ...
  275  error callbacks 209, 217
  276  error-handling 118-121
  277: problems with null- checking 121
  278  reasons not to throw exceptions 119-120
  279  with monads 132-141
  ...
  324  FP (functional programming) as declarative 7-9
  325  benefits of 16-22
  326: encouraging decomposi- tion of complex tasks 16-18
  327  processing data using fluent chains 18-19
  328  reacting to complexity of asynchronous applications 19-21
  ...
  362  challenges of recursive code 186-187 currying and function context stack 183-186 deferring using lazy evaluation 188-191
  363  memorization
  364: applying to recursive calls 197-199 currying and 196 decomposing to maximize 196-197 memoizing computation- ally intensive functions 192-195 overview 192
  365  recursion and tail-call optimization 199-203
  366: functional programming. See FP functional reactive program- ming. See FRP functional references 37
  367  Page 242
  368  
  369  functions
  370: as data 75-76 as first-class citizens 39-40 chaining 60-70 gathering results with _.reduce 65-68 lambda expressions 61-62 removing unwanted ele- menti with _.filter 68-70 transforming data with _.map 62-64 compatible 88-92 arity and 89-92 type-compatible functions 88-89 creating temporal dependen- cies among 207-208 curried function
  371  evaluation 92-98 emulating function factories 95-97 implementing reusable function templates 97-98
  372  delayed, binding into 101-102
  373: function methods 44 higher-order functions 40-42 types of function invocation 43 See also functional optimiza- tions
  374  functions as data 76 functors 124-127 Future object 214
  375  G
  ...
  382  I-combinator 112 identity (I-combinator) 112 identity function 123, 126, 131, 149
  383  if-else blocks 175, 177 if-else conditions 19, 68, 114, 215
  384: IIFE (immediately invoked func- tion expression) 51 immutability 3-4, 9, 21 immutable data, preserving 15-16
  385  imperative code 72 imperative programming 7-8,
  386  71
  ...
  427  object literal interface 33 Object.freeze() function 34, 36 objects
  428  managing state of 31-32 treating as values 32-34
  429: observables 21 observer pattern 236 one-line expressions 62 OOP (object-oriented program- ming), vs. functional programming 24-38 deep-freezing moving parts 34-37
  430  managing state of JavaScript objects 31-32 navigating and modifying object graphs with lenses 37-38 treating objects as values 32-34
  431  operator function 40 OR (||) operator 189 OR-combinator 113-114 orElse function 140 output type 86
  ...
  489  terminating condition 77, 79
  490  testing 153-179
  491: challenges of testing impera- tive programs 155-158
  492  dependency on shared resources leads to inconsistent results 157
  493  difficulty identifying and decomposing tasks 155-157
  ...
  531  _.uniq function 72
  532  unit function 130
  533: unit tests, functional program- ming’s influence on 154-155
  534  units of modularity 155
  535  units of work 16, 24, 38
  ...
  563  Luis Atencio
  564  In complex web applications, thè low-level details of your JavaScript code can obscure thè workings of thè System as a whole. As a coding style, functional programming (FP) promotes loosely coupled relationships among thè components of your application, makingthe big picture easierto design, communicate, and maintain.
  565: Functional Programming in JavaScript teaches you techniques to improve your web applications—their extensibility, modularity, reusability, and testability, as well as their performance. This easy-to-read book uses concrete examples and clear explana- tions to show you how to use functional programming in reai life. If you’re new to functional programming, you’ll appreciate this guide’s many insightful comparisons to imperative or object- oriented programming that help you understand functional design. By thè end, you’ll think about application design in a fresh new way, and you may even grow to appreciate monads!
  566  What’s Inside
  567  ■ High-value FP techniques for real-world uses ■ Using FP where it makes thè most sense ■ Separating thè logie of your System from implementation details

C:\Users\Emanuela\FunctionalP\pages\Ch1.js:
  111  <div className='col-md-6'>
  112  <p className="pag">Page 3</p>
  113: <h1 className="huno">Chapter 1 - Becoming functional</h1>
  114  <h2 className="hdos">This chapter covers</h2>
  115  <li className="littag"> Pensando en términos funcionales</li>
  ...
  138  <p className="it">El rápido ritmo de plataformas web, la evolución de los navegadores, y, lo más importante: las demandas de los usuarios finales, tienen un efecto profundo en la forma en que diseñamos aplicaciones web hoy en día. Los usuarios exigen que las aplicaciones web se sienten más como una computadora de escritorio nativo o una aplicación móvil con widgets ricos y sensibles. Naturalmente, estas exigencias obligan a los desarrolladores de JavaScript a pensar más ampliamente sobre el espacio de soluciones y adoptar paradigmas de programación adecuadas y las mejores prácticas que proporcionan las mejores soluciones posibles.</p>
  139  
  140: <p className="p">The rapid pace of web platforms, the evolution of browsers, and—most impor- tant—the demands of end users have all had a profound effect on the way we design web applications today. Users demand that web applications feel more like a native desktop or a mobile app with rich and responsive widgets. Naturally, these demands force JavaScript developers to think more broadly about the solution space and to adopt adequate programming paradigms and best practices that provide the best possible solutions.</p>
  141  <p className="it">Como desarrolladores, que gravitan hacia los frameworks que nos ayudan a crear arquitecturas de aplicaciones extensibles y limpias. Sin embargo, la complejidad de nuestra base de código todavía se sale de control, y nos desafia a reexaminar los principios básicos de diseño de nuestro código. Además, la web de hoy es radicalmente diferente de lo que era hace años para ERS desarrollos de JavaScript, ya que podemos hacer muchas cosas ahora que no eran técnicamente viables antes. Podemos optar por escribir grandes aplicaciones del lado del servidor con Node.js o empujar la mayor parte de la lógica de negocio en el cliente, dejando un servidor delgado atrás. En cualquier caso, tenemos que interactuar con la tecnología de almacenamiento, generar procesos asíncronos, manejar eventos, y mucho más.</p>
  142  
  143  <p className="p">As developers, we gravitate toward frameworks that help us create extensible and clean application architectures. Yet the complexity of our codebase still gets out of control, and we’re challenged to reexamine the basic design principles of our code. Also, the web of today is radically different than it was years ago for JavaScript developers, because we can do many things now that weren’t technically feasible before. We can choose to write large server-side applications with Node.js or push the bulk of the business logic onto the client, leaving a thin server behind. In either case, we need to interact with storage technology, spawn asynchronous processes, handle events, and much more.</p>
  144: <p className="it">diseño orientado a objetos ayuda a resolver parte del problema; sino porque JavaScript es un lenguaje dinámico con una gran cantidad de estado compartido, no pasa mucho tiempo antes de acumular suficiente complejidad para hacer nuestro código difícil de manejar y difícil de mantener. diseño orientado a objetos desde luego mueve la aguja en la dirección correcta, pero necesitamos más. Tal vez usted ha oído la programación reactiva plazo en los últimos años. Este para- digma de programación facilita el trabajo con los flujos de datos y la propagación del cambio. En JavaScript, esto es muy importante cuando se trata de un código asíncrono o basada en eventos. En general, lo que necesitamos es un paradigma de programación que nos anima a pensar cuidadosamente acerca de nuestros datos y las funciones que interactúan con él. Al pensar en el diseño de una aplicación, hágase las siguientes preguntas en términos de estos principios de diseño:</p>
  145  
  146: <p className="p">Object-oriented design helps solve part of the problem; but because JavaScript is such a dynamic language with lots of shared state, it isn’t long before we accumulate enough complexity to make our code unwieldy and hard to maintain. Object-oriented design certainly moves the needle in the right direction, but we need more. Perhaps you’ve heard the term reactive programming in recent years. This programming para- digm facilitates working with data flows and propagation of change. In JavaScript, this is extremely important when dealing with asynchronous or event-based code. Overall, what we need is a programming paradigm that encourages us to think carefully about our data and the functions that interact with it. When thinking about an application’s design, ask yourself the following questions in terms of these design principles:</p>
  147  <li className="littag"> Extensibilidad-Do I refactorizar constantemente mi código para soportar la funcionalidad adicional?</li>
  148  <li className="litag">	Extensibility—Do I constantly refactor my code to support additional functionality?</li>
  ...
  158  <p className="it">Si su respuesta es “Sí” o “No sé” a cualquiera de estas preguntas, entonces usted ha recogido el libro derecha como guía en el camino hacia la productividad. La programación funcional (FP) es el paradigma de programación que necesita. A pesar de que se basa en conceptos simples, FP requiere un cambio en la manera de pensar acerca de los problemas. FP no es una nueva herramienta o una API, pero un enfoque diferente para la resolución de problemas que se convertirá intuitivo una vez que Deben conocerse los principios básicos.</p>
  159  
  160: <p className="p">If you answer “Yes” or “I don’t know” to any of these questions, then you’ve picked up the right book as a guide on the path to productivity. Functional programming (FP) is the programming paradigm you need. Although it’s based on simple concepts, FP requires a shift in the way you think about problems. FP isn’t a new tool or an API, but a different approach to problem solving that will become intuitive once you under- stand the basic principles.</p>
  161: <p className="it">En este capítulo, defino lo que la programación funcional es y cómo y por qué digo que es útil e importante. Introduzco los principios básicos de fun- ciones inmutabilidad y puros y hablar acerca de las técnicas de planificación familiar y cómo esas técnicas afectan a su enfoque para el diseño de programas. Estas técnicas permiten elegir fácilmente la programación reactiva y lo utilizan para resolver tareas complejas de JavaScript. Pero antes de que podamos entrar en todo esto, es necesario saber por qué pensar funcionalmente es importante y cómo se puede ayudar a hacer frente a las complejidades ofJavaScript programas.</p>
  162  
  163: <p className="p">In this chapter, I define what functional programming is and tell you how and why it’s useful and important. I introduce the core principles of immutability and pure func- tions and talk about FP techniques and how those techniques affect your approach to designing programs. These techniques allow you to easily pick up reactive programming and use it to solve complex JavaScript tasks. But before we can get into all this, you need to learn why thinking functionally is important and how it can help you tackle the complexities ofJavaScript programs.</p>
  164  <h2 className="hdos">1.1	Can functional programming help?</h2>
  165  
  ...
  171  <p className="it">En el contexto de JavaScript, una mentalidad FP puede ser utilizado para dar forma a la naturaleza muy expresiva de la lengua y ayudarle a escribir código que está limpio y modular, capaz de Exámenes y conciso para que pueda ser más productivo en el trabajo. Durante muchos años, hemos descuidado el hecho de que JavaScript se puede escribir de manera más eficaz con un estilo funcional. Este descuido se debe en parte a una mala interpretación general del lenguaje JavaScript, y también debido a la falta de construcciones nativas para gestionar adecuadamente el estado de JavaScript; se trata de una plataforma dinámica que sitúa la carga de administrar este estado sobre nosotros (los responsables de introducir errores en nuestras aplicaciones). Esto puede funcionar bien para pequeños scripts, pero se vuelve más difícil de controlar a medida que crece su base de código. En cierto modo, creo que lo protege de FP en sí JavaScript. Discuto esto más adelante en el capítulo 2.</p>
  172  
  173: <p className="p">In the context of JavaScript, an FP mindset can be used to shape the incredibly expressive nature of the language and help you write code that is clean, modular, test- able, and succinct so that you can be more productive at work. For many years, we’ve neglected the fact that JavaScript can be written more effectively in a functional style. This neglect is partly due to an overall misunderstanding of the JavaScript language, and also due to JavaScript’s lack of native constructs to properly manage state; it’s a dynamic platform that places the burden of managing this state on us (the ones responsible for introducing bugs into our applications). This may work well for small scripts, but it becomes harder to control as your code base grows. In a way, I think FP protects you from JavaScript itself. I discuss this further in chapter 2.</p>
  174  <p className="it">Escribir código JavaScript funcional se ocupa de la mayor parte de estas preocupaciones. El uso de un conjunto de técnicas y prácticas probadas en base a funciones puras, se puede escribir código que es fácil de razonar acerca de la vista de la creciente complejidad. Escribir JavaScript funcionalmente es un acuerdo de dos por uno, porque no sólo a mejorar la calidad de toda la aplicación, sino que también aumenta más el dominio de y una mejor comprensión del lenguaje JavaScript.</p>
  175  
  176: <p className="p">Writing functional JavaScript code addresses most of these concerns. Using a set of proven techniques and practices based on pure functions, you can write code that is easy to reason about in the face of increasing complexity. Writing JavaScript function- ally is a two-for-one deal, because you not only improve the quality of your entire application, but also gain more proficiency in and a better understanding of the JavaScript language.</p>
  177  <p className="it">Debido a la programación funcional no es un framework o una herramienta, sino una forma de escribir código, pensando funcionalmente es radicalmente diferente de pensar en términos de orientación a objetos. Pero, ¿cómo convertirse funcional? ¿Cómo comenzar a pensar funcionalmente? La programación funcional es intuitivo una vez que haya captado su esencia. Desaprender viejos hábitos es la parte más difícil y puede ser un gran cambio de paradigma para la mayoría de las personas que vienen de un entorno orientado a objetos. Antes de que pueda aprender a pensar funcionalmente, primero hay que aprender lo que es FP.</p>
  178  
  ...
  190  `}</code></pre>
  191  <p className="it">NOTA he mencionado anteriormente que, debido a que la programación funcional no es una herramienta de información específica, sino una manera de escribir código, se puede aplicar a escribir del lado del cliente (basado en el navegador), así como aplicaciones del lado del servidor (Node.js). Abriendo el navegador y escribiendo algo de código es probablemente la forma más fácil de conseguir poner JavaScript en marcha y funcionando, y eso es todo lo que necesita para este libro.</p>
  192: <p className="p">NOTE I mentioned earlier that because functional programming isn’t a spe- cific tool, but a way of writing code, you can apply it to write client-side (browser-based) as well as server-side applications (Node.js). Opening the browser and typing in some code is probably the easiest way to get JavaScript up and running, and that’s all you’ll need for this book.</p>
  193  <p className="it">Este programa es simple, sino porque todo está codificado, no puede usarlo para ver mensajes  de forma dinámica. Digamos que usted quiere cambiar el formato, el contenido, o tal vez el elemento de destino; que había necesidad de volver a escribir toda esta expresión. Tal vez usted decide envolver este código con una función y hacer el cambio apunta parámetros, por lo que se puede escribir una vez y utilizarlo con cualquier configuración:</p>
  194  <p className="p">This program is simple, but because everything is hardcoded, you can’t use it to display messages dynamically. Say you wanted to change the formatting, the content, or perhaps the target element; you’d need to rewrite this entire expression. Maybe you decide to wrap this code with a function and make the change points parameters, so you can write it once and use it with any configuration:</p>
  ...
  199  }
  200  printMessage('msg', 'h1','Hello World');`}</code></pre>
  201: <p className="it">Una mejora, de hecho, pero todavía no es una pieza completamente reutilizable de código. Suponga que desea escribir en un archivo en lugar de una página HTML. Es necesario tomar el proceso de pensamiento simple de crear funciones parametrizadas a un nivel diferente, donde los pará- metros no son sólo valores escalares, pero también pueden ser ellas mismas funciones que proporcionan funcionalidad adi- cional. La programación funcional es un poco como el uso de funciones en los esteroides, ya que su único objetivo es evaluar y combinar una gran cantidad de funciones con otros para lograr un mayor comportamiento. Voy avance rápido un poco y le mostrará un adelanto de este mismo programa usando un enfoque funcional.</p>
  202: <p className="p">An improvement, indeed, but still not a completely reusable piece of code. Suppose you want to write to a file instead of an HTML page. You need to take the simple thought process of creating parameterized functions to a different level, where param- eters aren’t just scalar values but can also be functions themselves that provide addi- tional functionality. Functional programming is a bit like using functions on steroids, because your sole objective is to evaluate and combine lots of functions with others to achieve greater behavior. I’ll fast-forward a bit and show you a sneak peek at this same program using a functional approach.</p>
  203  <p className="it">Listado 1.1 printMessage Funcional:</p>
  204  <p className="p">Listing 1.1 Functional printMessage:</p>
  ...
  208  <p className="p">Without a doubt, this looks radically different than the original. For starters, hi isn’t a scalar anymore; it’s a function just like addToDom and echo. Visually, it feels as though you’re creating a function from smaller functions.</p>
  209  <p className="it">Hay una razón para esta locura. Listado 1.1 captura el proceso de descomposición de un programa en partes más pequeñas que son más reutilizables, más fiable y más fácil de entender, y luego combinarlas para formar un programa completo que es más fácil de reason acerca en su conjunto. Cada programa funcional sigue este principio fundamental. Por el momento, vamos a usar una función mágica, correr, 1 para activar una serie de funciones de forma secuencial, como addToDom, hola, y el eco. Voy a explicar en detalle más adelante plazo. Detrás de las escenas, que básicamente vincula cada función de una manera de tipo cadena haciendo pasar el valor de retorno de uno como entrada a la siguiente. En este caso, la cadena “Hello World” de regresar de eco se pasa a alta, y el resultado es finalmente pasó a addToDom.</p>
  210: <p className="p">There’s a reason for this madness. Listing 1.1 captures the process of decomposing a program into smaller pieces that are more reusable, more reliable, and easier to understand, and then combining them to form an entire program that is easier to rea- son about as a whole. Every functional program follows this fundamental principle. For the time being, you’ll use a magical function, run,1 to invoke a series of functions sequentially, such as addToDom, hi, and echo. I’ll explain run in detail later. Behind the scenes, it basically links each function in a chain-like manner by passing the return value of one as input to the next. In this case, the string “Hello World” returned from echo is passed into hi, and the result is finally passed into addToDom.</p>
  211  <p className="pag">Page 7</p>
  212: <p className="it">¿Por qué la solución funcional mira de esta manera? Me gusta pensar que es básicamente la parametrización de su código para que pueda cambiar fácilmente en un manner- no invasiva como el ajuste de las condiciones iniciales de un algoritmo. Con este fundamento puesto, ahora se puede aumentar fácilmente printMessage para repetir el mensaje dos veces, utilizar un encabezado h2, y escribir en la consola, en lugar de la DOM, todo ello sin tener que volver a escribir cualquiera de la lógica interna.</p>
  213  <p className="p">Why does the functional solution look this way? I like to think of it as basically parameterizing your code so that you can easily change it in a noninvasive manner— like adjusting an algorithm’s initial conditions. With this foundation laid, you can now easily augment printMessage to repeat the message twice, use an h2 header, and write to the console instead of the DOM, all without having to rewrite any of the internal logic.</p>
  214  <p className="it">Listing 1.2 Extendiendo printMessage:</p>
  ...
  217  printMessage('Get Functional');`}</code></pre>
  218  
  219: <p className="it">Este enfoque visualmente distinto no es accidental. Al comparar la funcionalidad de la solución no funcional, se habrán dado cuenta de que hay una diferencia radical en el estilo. Tanto imprimir la misma salida, sin embargo, tienen un aspecto muy diferente. Esto se debe al modo declarativo inherente de FP del desarrollo. Con el fin de entender completamente funcional programa- ming, primero debe aprender los conceptos fundamentales sobre los que se basa:</p>
  220: <p className="p">This visually distinct approach isn’t accidental. When comparing the functional to the nonfunctional solution, you may have noticed that there’s a radical difference in style. Both print the same output, yet they look very different. This is due to FP’s inherent declarative mode of development. In order to fully understand functional program- ming, first you must learn the fundamental concepts on which it’s based:</p>
  221  <li className="littag"> La programación declarativa</li>
  222  <li className="litag">	Declarative programming</li>
  ...
  229  <h2 className="hdos">1.2.1	Functional programming is declarative</h2>
  230  <p className="it"> La programación funcional cae bajo el paraguas de los paradigmas de programación declarativa: es un paradigma que expresa un conjunto de operaciones sin revelar cómo se implementan o cómo fluyen los datos a través de ellas. Sin embargo, los modelos más populares utilizados hoy en día son imperativos o procedimentales y están soportados en la mayoría de los lenguajes estructurados y orientados a objetos como Java, C #, C ++ y otros. La programación imperativa trata un programa de computadora como simplemente una secuencia de declaraciones de arriba a abajo que cambia el estado del sistema para computar un resultado. </p>
  231: <p className="p">Functional programming falls under the umbrella of declarative programming para- digms: it’s a paradigm that expresses a set of operations without revealing how they’re implemented or how data flows through them. The more popular models used today, though, are imperative or procedural, and are supported in most structured and object- oriented languages like Java, C#, C++, and others. Imperative programming treats a computer program as merely a sequence of top-to-bottom statements that changes the state of the system in order to compute a result.</p>
  232  
  233  <p class="ind">Índice 1. Para más detalles sobre esta función de ejecución provisional, visite http://mng.bz/nmax.</p>
  ...
  243  <p className="it">programación imperativa indica a la computadora, con gran detalle, cómo realizar una tarea determinada (bucle a través de la aplicación de la fórmula y cuadrado para cada número, en este caso). Esta es la forma más común de escribir el código y lo más probable es que sea la primera forma de abordar este problema.</p>
  244  <p className="p">Imperative programming tells the computer, in great detail, how to perform a certain task (looping through and applying the square formula to each number, in this case). This is the most common way of writing this code and will most likely be your first approach to tackling this problem.</p>
  245: <p className="it">La programación declarativa, por otro lado, separa la descripción del programa de evaluación. Se centra en el uso de expresiones para describir lo que la lógica de un programa es sin precisar necesariamente su flujo o control cambia de estado. Un ejemplo de programación tivo declara- se encuentra en las instrucciones SQL. consultas SQL se componen de declaraciones que describen lo que el resultado de una consulta debe ser similar, haciendo abstracción del mecanismo interno para la recuperación de datos. En el capítulo 3, se muestra un ejemplo del uso de una superposición similar a SQL sobre su código funcional para dar un sentido a la vez su solicitud y los datos que se ejecuta a través de él.</p>
  246: <p className="p">Declarative programming, on the other hand, separates program description from evaluation. It focuses on the use of expressions to describe what the logic of a program is without necessarily specifying its control flow or state changes. An example of declara- tive programming is found in SQL statements. SQL queries are composed of statements that describe what the outcome of a query should look like, abstracting the internal mechanism for data retrieval. In chapter 3, I show an example of using a SQL-like overlay over your functional code to give meaning to both your application and the data that runs through it.</p>
  247: <p className="it">El cambio a un enfoque funcional para hacer frente a esta misma tarea, sólo tiene que ser con- cerned con aplicar el comportamiento correcto en cada elemento y ceder el control de bucle a otras partes del sistema. Puede dejar que Array.map () hacer la mayor parte del trabajo pesado:</p>
  248: <p className="p">Shifting to a functional approach to tackle this same task, you only need to be con- cerned with applying the right behavior at each element and cede control of looping to other parts of the system. You can let Array.map() do most of the heavy lifting:</p>
  249: <p className="it">En comparación con el ejemplo anterior, se ve que este código le libera de la responsa- bilidad de gestionar adecuadamente un contador de bucle y el acceso índice de la matriz; en pocas palabras, cuanto más código que tiene, más lugares hay para los insectos que se produzca. Además, los bucles estándar no son artefactos reutilizables a menos que estén resumieron con las funciones. Y eso es precisamente lo que vamos a hacer. En el capítulo 3, demuestro cómo eliminar bucles manuales completamente de su código en favor de la primera clase, funciones de orden superior, como un mapa, reducir y filtro, que acepta funciones como parámetros para que su código es más reutilizable, extensible y declarativo. Esto es lo que hice con la función de ejecución mágico en los listados 1.1 y 1.2.</p>
  250: <p className="p">Compared with the previous example, you see that this code frees you from the respon- sibility of properly managing a loop counter and array index access; put simply, the more code you have, the more places there are for bugs to occur. Also, standard loops aren’t reusable artifacts unless they’re abstracted with functions. And that’s precisely what we’ll do. In chapter 3, I demonstrate how to remove manual loops completely from your code in favor of first-class, higher-order functions like map, reduce, and filter, which accept functions as parameters so that your code is more reusable, extensible, and declarative. This is what I did with the magical run function in listings 1.1 and 1.2.</p>
  251  <p className="it">Haciendo abstracción bucles con funciones le permite tomar ventaja de las expresiones lambda o funciones de dirección, introducidos en ES6 JavaScript. Las expresiones lambda proporcionan una alternativa sucinta a funciones anónimas que se pueden pasar en un argumento de la función, en el espíritu de la escritura menos:</p>
  252  <p className="p">Abstracting loops with functions lets you take advantage of lambda expressions or arrow functions, introduced in ES6 JavaScript. Lambda expressions provide a succinct alternative to anonymous functions that can be passed in as a function argument, in the spirit of writing less:</p>
  ...
  260  <p className="p">Translating lambda notation to regular function notation</p>
  261  <p className="it">Las expresiones lambda proporcionan una enorme ventaja sobre sintáctica notaciones función regular, ya que reducen la estructura de una función de llamar a las piezas más importantes. Esta expresión lambda ES6:</p>
  262: <p className="p">Lambda expressions provide an enormous syntactical advantage over regular func- tion notations because they reduce the structure of a function call down to the most important pieces. This ES6 lambda expression:</p>
  263  <pre><code>{`num => Math.pow(num, 2)`}</code></pre>
  264  <p className="it">es equivalente a la siguiente función:</p>
  ...
  270  <p className="p">Why remove loops from your code? A loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations. You’ll learn that functional programs aim for statelessness and immutability as much as possible. Stateless code has zero chance of changing or breaking global state. To achieve this, you’ll use functions that avoid side effects and changes of state, known as pure functions.</p>
  271  <h2 className="hdos">1.2.2	Pure functions and the problem with side effects</h2>
  272: <p className="it">La programación funcional se basa en la premisa de que construir pro- gramas inmutables sobre la base de los componentes básicos de las funciones puras. Una función pura tiene las cualidades siguien- tes:</p>
  273: <p className="p">Functional programming is based on the premise that you build immutable pro- grams based on the building blocks of pure functions. A pure function has the fol- lowing qualities:</p>
  274  <li className="littag"> Sólo depende de las aportaciones y no en cualquier estado oculto o externos que pueden cambiar durante su evaluación o entre las llamadas.</li>
  275  <li className="litag">	It depends only on the input provided and not on any hidden or external state that may change during its evaluation or between calls.</li>
  276  <li className="littag"> No infligir cambios más allá de su alcance, tales como la modificación de un objeto global o un parámetro pasado por referencia.</li>
  277  <li className="litag">	It doesn’t inflict changes beyond their scope, such as modifying a global object or a parameter passed by reference.</li>
  278: <p className="p">Intuitively, any function that doesn’t meet these requirements is “impure.” Program- ming with immutability can feel strange at first. After all, the whole point of impera- tive design, which is what we’re accustomed to, is to declare that variables are to mutate from one statement to the next (they’re “variable,” after all). This is a natural thing for us to do. Consider the following function:</p>
  279  <pre><code>{`var counter = 0; function incremento { return ++counter;
  280  }`}</code></pre>
  281: <p className="it">Esta función es impura porque lee / modifica una variable externa, contador, que no es local al ámbito de la función. En general, las funciones tienen efectos secundarios al leer o escribir en los recursos externos, como se muestra en la figura 1.1. Otro ejem- plo es la función populares Date.now (); su salida desde luego no es predecible y con- sistente, porque siempre depende de un factor constante cambio: el tiempo.</p>
  282  
  283: <p className="p">This function is impure because it reads/modifies an external variable, counter, which isn’t local to the function’s scope. Generally, functions have side effects when reading from or writing to external resources, as shown in figure 1.1. Another exam- ple is the popular function Date.now() ; its output certainly isn’t predicable and con- sistent, because it always depends on a constantly changing factor: time.</p>
  284  <p className="pag">Page 10</p>
  285  <p className="it">En este caso, se accede a través de un contador variable global implícito (en JavaScript basado en navegador, que es el objeto de la ventana). Otro efecto secundario común se produce cuando se accede a datos de instancia a través de la palabra clave this. El comportamiento de este en JavaScript es diferente a lo es en cualquier otro lenguaje de programación, ya que determina el contexto de ejecución de una función. Esto a menudo conduce a código que es difícil razonar sobre, por lo que lo evito siempre que sea posible. Me gustaría volver a este tema en el siguiente capítulo. Los efectos secundarios pueden ocurrir en muchas situaciones, incluyendo los siguientes:</p>
  ...
  299  <li className="litag">	Querying the HTML documents, browser cookies, or databases</li>
  300  <p className="it">Si no puede crear y modificar objetos o imprimir en la consola, ¿qué valor práctico obtendría de un programa como este? De hecho, las funciones puras pueden ser difíciles de usar en un mundo lleno de comportamiento dinámico y mutación. Pero la programación funcional práctica no restringe todos los cambios de estado; Sólo proporciona un framework para ayudarle a administrar y reducirlos, mientras que le permite separar lo puro de lo impuro. El código impuro produce efectos secundarios visibles externamente como los mencionados anteriormente, y en este libro examino formas de lidiar con esto.</p>
  301: <p className="p">If you’re unable to create and modify objects or print to the console, what practical value would you get from a program like this? Indeed, pure functions can be hard to use in a world full of dynamic behavior and mutation. But practical functional pro- gramming doesn’t restrict all changes of state; it just provides a framework to help you manage and reduce them, while allowing you to separate the pure from the impure. Impure code produces externally visible side effects like those listed earlier, and in this book I examine ways to deal with this.</p>
  302  <p className="it">Para hablar más concretamente sobre estos temas, supongamos que usted es un desarrollador en un equipo encargado de ejecutar una aplicación para gestionar datos de los estudiantes de la escuela. Listado 1.3 muestra un pequeño programa imperativo que encuentra un registro de alumnos según el número de la Seguridad Social y lo hace en el navegador (una vez más, el uso del navegador es inmaterial, sólo podría escribir tan fácilmente a la consola, una base de datos o un archivo) . Me refiero a este programa y se expanden por todo el libro como un típico escenario, en el mundo real que implica efectos secundarios por interactuando con un almacén de objetos locales externa (como una matriz de objetos) y haciendo un cierto nivel de IO.</p>
  303  
  ...
  308  <p className="p">Listing 1.3 Imperative showStudent function with side effects</p>
  309  <p className="it">Vamos a analizar este código adicional. Esta función expone claramente unos efectos secundarios que RIP-plo más allá de su alcance:</p>
  310: <p className="p">Let’s analyze this code further. This function clearly exposes a few side effects that rip- ple beyond its scope:</p>
  311  <li className="littag">También está relacionada con una variable externa (dB) para el acceso de datos debido a que la firma de la función no declara este parámetro. En cualquier punto en el tiempo, esta referencia podría llegar a ser nulo o cambiar de una llamada al siguiente, produciendo resultados completamente diferentes y poner en peligro la integridad del programa.</li>
  312  <li className="litag">	It interacts with an external variable (db) for data access because the function signature doesn’t declare this parameter. At any point in time, this reference could become null or change from one call to the next, yielding completely different results and compromising the integrity of the program.</li>
  ...
  318  <li className="litag">	It can potentially throw an exception if the student isn’t found, which causes the entire program stack to unwind and end abruptly.</li>
  319  <p className="it"> La función en el listado 1.3 depende de recursos externos, lo que hace que el código sea inflexible, difícil de trabajar y difícil de probar. Las funciones puras, por el contrario, tienen contratos claros como parte de sus firmas que describen claramente todos los parámetros formales de la función (conjunto de entradas), haciéndolos más fáciles de entender y usar.</p>
  320: <p className="p">The function in listing 1.3 relies on external resources, which makes the code inflexible, hard to work with, and difficult to test. Pure functions, on the other hand, have clear contracts as part of their signatures that describe clearly all of the function’s for- mal parameters (set of inputs), making them simpler to understand and use.</p>
  321  
  322: <p className="it">Vamos a poner nuestro sombrero funcional y utilizar lo que ha aprendido desde la simple programa de mensajería Imprimir- en contra de este escenario de la vida real. A medida que se sienten más cómodos con la programación funcional en este libro, usted continuará para mejorar esta aplicación con nuevas técnicas. Por el momento, se pueden hacer dos mejoras simples:</p>
  323: <p className="p">Let’s put our functional hat on and use what you learned from the simple print- Message program against this real-life scenario. As you become more comfortable with functional programming in this book, you’ll continue to improve this implementation with new techniques. At the moment, you can make two simple enhancements:</p>
  324  <li className="littag"> Separar esta función largo en funciones más cortos, cada uno con un único fin.</li>
  325  <li className="litag">	Separate this long function into shorter functions, each with a single purpose.</li>
  ...
  331  <p className="pag">Page 12</p>
  332  <h1 className="huno">CHARTER 1 </h1>
  333: <p className="it">Convirtiéndose en el sistema funcional y el DOM son inevitables, pero al menos se puede hacer más manejable y hacen que destaquen por la lógica principal. Para ello, voy a introducir un popular técnica de FP llamada currificación. Con currificación, se puede establecer parcialmente algunos de los argumentos de una función con el fin de reducirlos a uno. Como se muestra en la siguiente tabla, se puede aplicar al curry para reducir hallazgo y añadir a las funciones unarios que puede fácilmente com- bine a través de ejecución.</p>
  334  
  335: <p className="p">Becoming functional system and the DOM are unavoidable, but at least you can make them more manage- able and single them out from the main logic. To do this, I’ll introduce a popular FP technique called currying. With currying, you can partially set some of the arguments of a function in order to reduce them down to one. As shown in the next listing, you can apply curry to reduce find and append to unary functions that can easily com- bine via run.</p>
  336  <p className="it">1.4 Descomposición de lista del programa showStudent</p>
  337  <p className="p">Listing 1.4 Decomposing the showStudent program</p>
  ...
  347  <li className="littag"> A mejorar la legibilidad del código siguiendo un estilo declarativo que proporciona una visión clara de los pasos de alto nivel llevadas a cabo por este programa.</li>
  348  <li className="litag">	You enhance the code’s readability by following a declarative style that provides a clear view of the high-level steps carried out by this program.</li>
  349: <li className="littag">Más importante, la interacción con los objetos HTML se trasladó a su propia fun- ción, aislando el puro a partir del comportamiento no-pura (impuro). Me explico ing curry- y la gestión de partes puras e impuras en profundidad en el capítulo 4.</li>
  350: <li className="litag">	More important, interaction with the HTML objects is moved into its own func- tion, isolating the pure from the non-pure (impure) behavior. I explain curry- ing and managing pure and impure parts in depth in chapter 4.</li>
  351   
  352  <p className="pag">Page 13</p>
  ...
  362  <p className="p">In order to make it referentially transparent, you need to remove its dependent state—the outer variable—and make it an explicit formal parameter of the function signature. You can convert it to ES6 lambda form:</p>
  363  <pre><code>{`var increment = counter => counter + 1;`}</code></pre>
  364: <p className="it">Ahora esta función es estable y siempre devuelve la misma salida cuando se proporciona con la misma entrada. De lo contrario, el valor devuelto por la función está siendo influenciado por algún factor exter- nos.</p>
  365: <p className="p">Now this function is stable and always returns the same output when provided with the same input. Otherwise, the function’s return value is being influenced by some exter- nal factor.</p>
  366: <p className="it">Buscamos esta calidad en funciones, ya que no sólo hace que el código más fácil de probar, sino que también nos permite razonar sobre programas enteros con mucha más facilidad. transparencia referencial o corrección ecuacional se heredan de matemáticas, sino que funciona en len- guaje de programación se comportan nada como funciones matemáticas; consiguiendo así perdería transparencia referencial es estrictamente en nosotros. Utilizando la función de ejecución mágica de nuevo, la figura 1.2 muestra cómo utilizar el imperativo frente a la versión funcional de incremento.</p>
  367: <p className="p">We seek this quality in functions because it not only makes code easier to test, but also allows us to reason about entire programs much more easily. Referential transparency or equational correctness is inherited from math, but functions in programming lan- guages behave nothing like mathematical functions; so achieving referential transpar- ency is strictly on us. Using the magical run function again, figure 1.2 shows how to use the imperative versus the functional version of increment.</p>
  368  <p className="it">Programas construidos de esta forma son mucho más fáciles de razonar acerca de porque se puede formar un modelo mental del estado del sistema y lograr el resultado deseado a través de la reescritura o sustitución. Veamos esto más concreta y asumen que cualquier programa puede definirse como un conjunto de funciones que procesa una entrada dada y produce una puesta OUT-. Aquí está en forma de pseudo:</p>
  369: <p className="p">Programs built this way are much easier to reason about because you can form a mental model of the state of the system and achieve the desired outcome through rewriting or substitution. Let’s look at this more concretely and assume that any program can be defined as a set of functions that processes a given input and produces an out- put. Here it is in pseudo form:</p>
  370  <pre><code>{`Program = [Input] + [func1, func2, func3, ...]	-> Output`}</code></pre>
  371  <p className="pag">Page 14</p>
  372  <p className="it">Figura 1.2 Comparación de trabajar con versiones imperativas y funcionales de incremento. El resultado de la versión imperativa es impredecible y puede ser inconsistente porque la variable de contador externa puede cambiar en cualquier momento, comprometiendo el resultado de invocaciones sucesivas de la función. La versión funcional transparentemente referencial es siempre equacionalmente correcta y no deja lugar a errores.</p>
  373  <p className="p">Figure 1.2 Comparison of working with imperative and functional versions of increment. The result of the imperative version is unpredictable and can be inconsistent because the external counter variable may change at any time, compromising the result of successive invocations of the function. The referentially transparent functional version is always equationally correct and leaves no room for errors.</p>
  374: <p className="it">Si las funciones [funcl, func2, func3, ...] son &#8203;&#8203;puros, se puede reescribir fácilmente este pro- grama por inlining los valores producidos por ellos- [vali, val2, val3, ...] - sin alterar el resultado. Consideremos un ejemplo sencillo de calcular el grado promedio de un estudiante:</p>
  375: <p className="p">If the functions [funcl, func2, func3, ...] are pure, you can easily rewrite this pro- gram by inlining the values produced by them—[vali, val2, val3, ...]—without altering the result. Consider a simple example of computing a student’s average grade:</p>
  376  <pre><code>{`
  377  var input =	[80,	90, 100];
  ...
  381  <pre><code>{`var average = divide(270, 3); //-> 90`}</code></pre>
  382  <p className="it">Debido división es siempre pura, se puede volver a escribir aún más utilizando su notación matemática ción; por lo que para esta entrada, el promedio siempre es 270/3 = 90. Referencial transparencia hace posible razonar acerca de los programas en este sistemática casi matemática, forma,. El programa completo se puede realizar de la siguiente manera:</p>
  383: <p className="p">Because divide is always pure, it can be rewritten further using its mathematical nota- tion; so for this input, the average is always 270/3 = 90. Referential transparency makes it possible to reason about programs in this systematic, almost mathematical, way. The entire program can be implemented as follows:</p>
  384: <p className="it">Aunque no va a aplicar el razonamiento ecuacional a todos los programas en el libro, es importante entender que esto está implícito en cualquier programa puramente funcional, y que no sería posible si las funciones tuvieron efectos secundarios. En el capítulo 6, vuelvo a la importancia de este principio en el contexto de código de prueba de la unidad funcional. Defin- ing todos los argumentos de la función en la delantera evita los efectos secundarios en la mayoría de los casos, al igual que con valores escalares; pero cuando los objetos se pasan por referencia, se debe tener cuidado de no inadvertidamente mutar ellos.</p>
  385: <p className="p">Although I don’t plan to apply equational reasoning to every program in the book, it’s important to understand that this is implicit in any purely functional program, and that it wouldn’t be possible if functions had side effects. In chapter 6, I come back to the importance of this principle in the context of unit testing functional code. Defin- ing all function arguments up front avoids side effects in most cases, as with scalar values; but when objects are passed by reference, you must be cautious not to inadver- tently mutate them.</p>
  386  <h2 className="hdos">1.2.4	Preserving immutable data</h2>
  387  <p className="it">inmutable datos son datos que no se puede cambiar después de haber sido creado. En JavaScript, como ocurre con muchos otros idiomas, todos los tipos primitivos (String, Número, y así sucesivamente) son inherentemente inmutable. Sin embargo, otros objetos, como matrices, no son inmutables; incluso si están pasados &#8203;&#8203;como entrada para una función, todavía puede causar un efecto secundario cambiando el contenido original. Considere este sencillo código de matriz de clasificación:</p>
  388: <p className="p">Immutable data is data that can’t be changed after it’s been created. In JavaScript, as with many other languages, all primitive types (String, Number, and so on) are inher- ently immutable. But other objects, like arrays, aren’t immutable; even if they’re passed as input to a function, you can still cause a side effect by changing the original content. Consider this simple array-sorting code:</p>
  389  <p className="pag">Page 15</p>
  390  
  391  <pre><code>{`var sortDesc = function (arr) {
  392: return arr.sort(function (a, b) { return b - a;
  393  });
  394  }`}</code></pre>
  395: <p className="it">A primera vista, este código parece perfectamente bien y es partidario del libre efecto. Se hace lo que se espera que haga-usted proporciona una matriz y devuelve la misma matriz ordenada en orden descen- dientes ING:</p>
  396: <p className="p">At a glance, this code seems perfectly fine and side effect-free. It does what you’d expect it to do—you provide an array, and it returns the same array sorted in descend- ing order:</p>
  397  <pre><code>{`var arr =	[1,2,3,4,5,6,7,8,9];
  398  sortDesc(arr); //->	[9,8,7,6,5,4,3,2,1]`}</code></pre>
  399: <p className="it">Desafortunadamente, la función Array.sort es con estado y provoca el efecto secundario de la clasificación de la matriz en lugar-la referencia original se cambia. Este es un serio defecto en el len- guaje y que vamos a superar en los próximos capítulos.</p>
  400: <p className="p">Unfortunately, the Array.sort function is stateful and causes the side effect of sorting the array in place—the original reference is changed. This is a serious flaw in the lan- guage and one that we’ll overcome in future chapters.</p>
  401: <p className="it">Ahora que usted ha tenido una visión de los principios fundamentales de la programación funcional (declarativa, pura, e inmutable), puedo expresar lo que es más Suc cinctly: programación funcional se refiere a la evaluación de las funciones declarativa puros para crear programas inmutables por evitando los efectos secundarios observables externamente. No es un bocado después de todo. Sólo he arañado la superficie en términos de los beneficios prácticos de la escritura de aplicaciones funcio- nales, pero por ahora se está empezando a entender lo que significa pensar con esta mentalidad.</p>
  402: <p className="p">Now that you’ve had a glimpse of the fundamental principles behind functional programming (declarative, pure, and immutable), I can express what it is more suc- cinctly: functional programming refers to the declarative evaluation of pure functions to create immutable programs by avoiding externally observable side effects. Not such a mouthful after all. I’ve only scratched the surface in terms of the practical benefits of writing func- tional applications, but by now you’re beginning to understand what it means to think with this mindset.</p>
  403  <p className="it">La mayor parte de los problemas que enfrentan hoy en día los desarrolladores de JavaScript se deben al uso intensivo de las grandes funciones que dependen en gran medida de las variables compartidas externamente, hacer un montón de ING rama-y no tienen una estructura clara. Por desgracia, esta es la situación para muchas aplicaciones Java script que tienen éxito compone de muchos archivos que se ejecutan entre sí, formando una malla compartida de datos mundial mutable que puede ser difícil de rastrear y depurar aún hoy en día.</p>
  404: <p className="p">Most of the issues JavaScript developers face nowadays are due to the heavy use of large functions that rely greatly on externally shared variables, do lots of branch- ing, and have no clear structure. Unfortunately, this is the situation for many Java- Script applications today—even successful ones made up of many files that execute together, forming a shared mesh of mutable, global data that can be hard to track and debug.</p>
  405  <p className="it">Se ven obligados a pensar en términos de operaciones puras y mirando a funciones como unidades selladas de trabajo que nunca mutan datos definitivamente puede reducir la posibilidad de errores. La comprensión de estos principios básicos es importante con el fin de aprovechar los beneficios de la programación funcional aporta a su código, que le guiará en el camino hacia la superación de la complejidad.</p>
  406  <p className="p">Being forced to think in terms of pure operations and looking at functions as sealed units of work that never mutate data can definitely reduce the potential for bugs. Understanding these core principles is important in order to reap the benefits functional programming brings to your code, which will guide you on the path to overcoming complexity.</p>
  ...
  408  
  409  <h2 className="hdos">1.3	Benefits of functional programming</h2>
  410: <p className="it">Con el fin de beneficiarse de la programación funcional, debe aprender a pensar FunciÃ³n- aliado y tener las herramientas adecuadas. En esta sección, presento algunas técnicas básicas que son indispensables para su caja de herramientas con el fin de desarrollar su conciencia funcional, el instinto de ver los problemas como una combinación de funciones simples que en conjunto proporcionan una solución completa. Los temas presentados en esta sección también sirven como una breve introducción a algunos de los próximos capítulos en el libro. Si es un concepto difícil de entender ahora, no se preocupe; se hará más claro a medida que avanza por el resto de los capítulos.</p>
  411: <p className="p">In order to benefit from functional programming, you must learn to think function- ally and have the proper tools. In this section, I introduce some core techniques that are indispensable for your toolbox in order to develop your functional awareness—the instinct of looking at problems as a combination of simple functions that together provide a complete solution. The topics introduced in this section also serve as a brief introduction to some of the upcoming chapters in the book. If a concept is hard to grasp now, don’t worry; it will become clearer as you progress through the rest of the chapters.</p>
  412  <p className="it">Ahora vamos a explorar en un nivel alto los beneficios FP aporta a sus aplicaciones de JavaScript. Las siguientes subsecciones explicar cómo se puede</p>
  413  <p className="p">Now let’s explore at a high level the benefits FP brings to your JavaScript applications. The following subsections explain how it can</p>
  ...
  420  <h2 className="hdos">1.3.1	Encouraging the decomposition of complex tasks</h2>
  421  <p className="it"> A un nivel alto, la programación funcional es efectivamente la interacción entre la descomposición (romper los programas en pequeños fragmentos) y la composición (uniendo las piezas de nuevo). Esta dualidad hace que los programas funcionales sean modulares y eficaces. Como mencioné anteriormente, la unidad de modularidad, o unidad de trabajo, es la función en sí. Pensar funcionalmente típicamente comienza con la descomposición aprendiendo a romper una tarea particular en subtareas lógicas (funciones), como se muestra en la descomposición de showStudent en la figura 1.3. </p>
  422: <p className="p">At a high level, functional programming is effectively the interplay between decompo- sition (breaking programs into small pieces) and composition (joining the pieces back together). It’s this duality that makes functional programs modular and so effec- tive. As I mentioned previously, the unit of modularity, or unit of work, is the function itself. Thinking functionally typically begins with decomposition by learning to break a particular task into logical subtasks (functions), as shown in the decomposition of showStudent in figure 1.3.</p>
  423: <p className="it">Si sea necesario, estas subtareas se pueden descomponer aún más hasta llegar a las funciones más simples, puras, cada una de las cuales es una unidad independiente del trabajo. Recuerde que este fue el proceso de pensamiento Seguí al refactorizar showStudent en el listado 1.4. ción Modulariza- en FP está estrechamente relacionado con el principio de singularidad, que establece que las funciones deben tener un solo propósito; Esto también fue evidente en el código para media, que se muestra anteriormente. La pureza y la transparencia referencial que animan a pensar de esta manera, porque a fin de pegar funciones simples juntos, deben ponerse de acuerdo sobre los tipos de entradas y salidas. Desde transparencia referencial, se aprende que la complejidad de una función es A VECES directamente relacionados con el número de argumentos que recibe (esto es simplemente una observación práctica y no un concepto formal que indica que cuanto menor sea el número de parámetros de la función, mientras más simple, función tiende a ser).</p>
  424: <p className="p">If need be, these subtasks can be decomposed further until you arrive at simpler, pure functions, each of which is an independent unit of work. Remember that this was the thought process I followed when refactoring showStudent in listing 1.4. Modulariza- tion in FP is closely related to the singularity principle, which states that functions should have a single purpose; this was also evident in the code for average, shown earlier. Purity and referential transparency encourage you to think this way because in order to glue simple functions together, they must agree on the types of inputs and outputs. From referential transparency, you learn that a function’s complexity is some- times directly related to the number of arguments it receives (this is merely a practical observation and not a formal concept indicating that the lower the number of func- tion parameters, the simpler the function tends to be).</p>
  425  <p className="pag">Page 17</p>
  426  <p className="it"> Todo el tiempo, he estado usando run para combinar funciones para componer programas enteros. Es hora de descubrir esta magia oscura. En realidad, run es un alias para una de las técnicas más importantes: composición. La composición de dos funciones es otra función que resulta de tomar la salida de una y conectarlo a la siguiente. Suponga que tiene dos funciones fyg. Formalmente, esto se puede expresar como sigue: </p>
  427: <p className="p">All along, I’ve been using run to combine functions to make up whole programs. It’s time to uncover this dark magic. In reality, run is an alias for one the most impor- tant techniques: composition. The composition of two functions is another function that results from taking the output of one and plugging it into the next. Assume that you have two functions f and g. Formally, this can be expressed as follows:</p>
  428  <pre><code>{`
  429  f • g = f(g(x))`}</code></pre>
  430  <p className="it">Esta fórmula lee “f compone de g”, que crea una relación floja, de tipo seguro entre el valor de retorno de g y el argumento de f. El requisito de dos funciones sean compatibles es que deben estar de acuerdo en el número de argumentos, así como sus tipos. Vamos a ver esto de cerca en el capítulo 3. Por ahora, vamos a diagrama de la composición del Estudiante show-en la figura 1.4, esta vez utilizando la función correcta, componer:</p>
  431  
  432: <p className="p">This formula reads “f composed of g,” which creates a loose, type-safe relationship between g’s return value and f’s argument. The requirement for two functions to be compatible is that they must agree in the number of arguments as well as their types. We’ll look at this closely in chapter 3. For now, let’s diagram the composition of show- Student in figure 1.4, this time using the correct function, compose:</p>
  433  <pre><code>{`var showStudent = compose(append('#student-info'), csv, find(db));
  434   showStudent('444-44-4444');`}</code></pre>
  ...
  440  <p className="it">Además, la composición funcional eleva el nivel de abstracción para que pueda definir claramente todos los pasos realizados en el código sin estar expuestos a cualquiera de sus datos subyacentes. Debido a que componga acepta otras funciones como argumentos, se le conoce como un nivel superior de orderfunction. Pero la composición no es la única manera de crear código de fluidez, modular; en este libro, también aprenderá cómo construir secuencias de operaciones por Connect-ing operaciones de una manera similar a la cadena.</p>
  441  
  442: <p className="p">In addition, functional composition raises the level of abstraction so that you can clearly outline all the steps performed in this code without being exposed to any of its underlying details. Because compose accepts other functions as arguments, it’s known as a higher-orderfunction. But composition isn’t the only way to create fluent, modular code; in this book, you’ll also learn how to build sequences of operations by connect- ing operations in a chain-like manner.</p>
  443  <p className="pag">Page 18</p>
  444  <h2 className="hdos">1.3.2	Processing data using fluent chains</h2>
  445  <p className="it">Además de mapa, puede importar un repertorio de muchas funciones de orden superior en cualquier proyecto de JavaScript a través de algunas bibliotecas funcionales potentes y optimizados. En los capítulos 3 y 4, me importa un recorrido por muchas de estas funciones de orden superior implementadas en kits de herramientas funcionales de JavaScript populares como Lodash.js y Ramda.js; se superponen en muchos aspectos, pero cada uno aporta características únicas que pueden facilitar el montaje de cadenas ción fun-.</p>
  446  
  447: <p className="p">In addition to map, you can import a repertoire of many higher-order functions into any JavaScript project through some powerful and optimized functional libraries. In chapters 3 and 4, I give a tour of many of these higher-order functions implemented in popular JavaScript functional toolkits like Lodash.js and Ramda.js; they overlap in many aspects, but each brings unique features that can facilitate assembling func- tion chains.</p>
  448: <p className="it">Si usted ha escrito algo de código jQuery antes, probablemente esté familiarizado con este idioma. Una cadena es una invocación secuencial de funciones que comparten un valor de retorno de objeto común (tal como el S o el objeto jQuery). Al igual composición, este idioma le permite escribir código escueta y concisa, y que por lo general se utiliza mucho en funcional, así como bibliotecas JavaScript programación tivo reac- (más sobre esto más adelante). Para demostrar esto, vamos a hacer frente a un problema diferente. Supongamos que usted está asignada a escribir un programa que calcula la nota media de studente que se han inscrito en más de una clase. Dado este conjunto de datos de inscripción:</p>
  449  
  450: <p className="p">If you’ve written some JQuery code before, you’re probably familiar with this idiom. A chain is a sequential invocation of functions that share a common object return value (such as the S or jQuery object). Like composition, this idiom allows you to write terse and concise code, and it’s typically used a lot in functional as well as reac- tive programming JavaScript libraries (more on this later). To show this, let’s tackle a different problem. Suppose you’re tasked with writing a program that computes the average grade for studente who have enrolled in more than one class. Given this array of enrollment data:</p>
  451  
  452  <pre><code>{`let enrollment = [
  ...
  479  <p className="pag">Page 19</p>
  480  <p className="it">Ahora puede usar Lodash para unir funciones que representan estos pasos, formando una cadena funcional, como se muestra en el listado 1.5 (para una explicación completa de lo que cada una de estas funciones hace, puede visitar la Apéndice para instrucciones sobre dónde encontrar la documentación apropiada). Una cadena de funciones es un programa evaluado perezoso, lo que significa que difiere su ejecución hasta que sea necesario. Esto beneficia el rendimiento porque puede evitar ejecutar secuencias enteras de código que no se utilizarán en ningún otro lugar, lo que ahorrará preciosos ciclos de CPU. Esto simula de forma efectiva el comportamiento de llamada por necesidad construido en otros idiomas funcionales. </p>
  481: <p className="p">Now you can use Lodash to stitch together functions representing these steps, form- ing a functional chain, as shown in listing 1.5 (for a full explanation of what each of these functions does, you can visit the appendix for directions on where to fmd the proper documentation). A function chain is a lazy evaluated program, which means it defers its execution until needed. This benefits performance because you can avoid executing entire sequences of code that won’t be used anywhere else, saving precious CPU cycles. This effectively simulates the call-by-need behavior built into other func- tional languages.</p>
  482  <p className="it">Listing 1.5 Programación con cadenas de funciones</p>
  483  
  ...
  485  <p className="it">No se preocupe demasiado en este punto con todo lo que está sucediendo en este código. Por ahora, compararlo con la versión imperativa, y observe cómo se puede eliminar la necesidad de declarar y cambiar las variables, bucles, y las declaraciones if-else. Como veremos en el capítulo 7, muchos mecanismos de control de flujo imperativas como bucles y ramificaciones aumentan el nivel de complejidad de sus funciones, ya que ejecutan diferentes caminos Dependiendo de ciertas condiciones, haciéndolos muy difíciles de probar.</p>
  486  
  487: <p className="p">Don’t be too concerned at this point with everything that’s happening in this code. For now, compare it to the imperative version, and notice how you can eliminate the need to declare and change variables, loops, and if-else statements. As you’ll learn in chapter 7, many imperative control-flow mechanisms like loops and branches increase the level of complexity of your functions because they execute different paths depend- ing on certain conditions, making them incredibly difficult to test.</p>
  488  <p className="it">Para ser justos, sin embargo, este ejemplo se salta una gran cantidad de código de control de errores se encuentran en los típicos programas del mundo real. Anteriormente, he mencionado que lanzar excepciones era una causa de efectos secundarios. Las excepciones no existen en la programación funcional académica, pero en la vida real no serán capaces de escapar de ellos. Hay una distinción entre la gestión de errores puro y manejo de excepciones. El objetivo es implementar el manejo de errores pura tanto como sea posible y permitir excepciones a fuego en condiciones verdaderamente excepcionales, al igual que las descritas anteriormente.</p>
  489  <p className="p">To be fair, though, this example skips a lot of error-handling code found in typical real-world programs. Earlier, I mentioned that throwing exceptions was a cause of side effects. Exceptions don’t exist in academic functional programming, but in real life you won’t be able to escape them. There’s a distinction between pure error handling and exception handling. The goal is to implement pure error handling as much as possible and allow exceptions to fire in truly exceptional conditions, just like the ones described earlier.</p>
  ...
  491  <p className="p">Fortunately, by applying some purely functional design patterns, you won’t need to sacrifice this level of expressiveness to provide robust error-handling logic for your code. This is the main topic of discussion in chapter 5.</p>
  492  <p className="it">Hasta ahora, usted ha visto cómo FP puede ayudar a crear aplicaciones modulares, comprobables, extensibles. ¿Qué tan bien funciona cuando se necesita para interactuar con los datos asíncronos o basadas en eventos procedentes de la entrada del usuario, las peticiones web remotos, sistemas de archivos, o el almacenamiento sistente per-?</p>
  493: <p className="p">So far, you’ve seen how FP can help you create modular, testable, extensible applications. How well does it work when you need to interact with asynchronous or event-based data coming from user input, remote web requests, file systems, or per- sistent storage?</p>
  494  <h2 className="hdos">1.3.3	Reacting to the complexity of asynchronous applications</h2>
  495: <p className="it">Si recuerda la última vez que tuvo que obtener los datos remotas, manejar la entrada del usuario, o interactuar con el almacenamiento local, es probable que recuerdan la escritura secciones enteras de la lógica de negocio en secuencias anidadas de funciones de devolución de llamada. Este patrón de devolución de llamada rompe el flujo lineal de su código y se hace difícil de leer, porque está atestado de formas anidadas de la lógica éxito- y control de errores. Esto es todo a punto de cambiar.</p>
  496: <p className="p">If you remember the last time you had to fetch remote data, handle user input, or interact with local storage, you probably recall writing entire sections of business logic into nested sequences of callback functions. This callback pattern breaks the linear flow of your code and becomes hard to read, because it’s cluttered with nested forms of success- and error-handling logic. This is all about to change.</p>
  497  <p className="pag">Page 20</p>
  498: <p className="it">Como he dicho antes, el aprendizaje de la programación funcional, especialmente para los Ircops desa- JavaScript, es muy importante hoy en día. Cuando la construcción de aplicaciones de gran tamaño, una gran parte de la atención se ha desplazado de los frameworks orientados a objetos como Backbone.js a los frameworks que favorezcan un paradigma de programación reactiva. frameworks web como AngularJS siguen siendo ampliamente utilizados hoy en día; pero los nuevos jugadores en el campo, tales como RxJS, abrazan el poder de FP para hacer frente a tareas muy difíciles.</p>
  499: <p className="p">As I said earlier, learning functional programming, especially for JavaScript devel- opers, is extremely important today. When building large applications, a lot of the focus has shifted from object-oriented frameworks like Backbone.js to frameworks that favor a reactive programming paradigm. Web frameworks like Angularjs are still widely used today; but new players in the field, such as RxJS, embrace the power of FP to tackle very challenging tasks.</p>
  500: <p className="it">la programación reactiva es probablemente una de las más excitantes e interesantes aplica- ciones de programación funcional. Se puede utilizar para reducir drásticamente la complejidad de código asíncrono y orientada a eventos que, como desarrolladores de JavaScript, se ocupa de todos los días en el cliente, así como el servidor.</p>
  501: <p className="p">Reactive programming is probably one of the most exciting and interesting appli- cations of functional programming. You can use it to dramatically reduce the com- plexity in asynchronous and event-driven code that you, as JavaScript developers, deal with on a daily basis on the client as well as the server.</p>
  502: <p className="it">El principal beneficio de la adopción de un paradigma reactiva es que aumenta el nivel de abstracción de su código, lo que le permite centrarse en la lógica de negocio específico, mientras que olvidando sobre el código repetitivo ardua asociados con la apertura asincrónica y programas basados &#8203;&#8203;en eventos. Además, este paradigma emergente aprovecha al máximo dad abil- de FP a la cadena o componer funciones juntas.</p>
  503: <p className="p">The main benefit of adopting a reactive paradigm is that it raises the level of abstraction of your code, allowing you to focus on specific business logic while forget- ting about the arduous boilerplate code associated with setting up asynchronous and event-based programs. Also, this emerging paradigm takes full advantage of FP’s abil- ity to chain or compose functions together.</p>
  504  <p className="it">Eventos vienen en muchos sabores: clics del ratón, cambios en el campo de texto, se centran cambios, manipulan de dling peticiones HTTP, nuevas consultas de bases de datos, archivos, escribe, y así sucesivamente. Supongamos que necesita para leer y validar el SSN de un estudiante. Un enfoque típico imperativo podría ser como la siguiente lista.</p>
  505: <p className="p">Events come in many flavors: mouse clicks, text field changes, focus changes, han- dling new HTTP requests, database queries, file writes, and so on. Suppose you need to read and validate a student’s SSN. A typical imperative approach might look like the next listing.</p>
  506  <p className="it">Añadir 1,6 programa imperativo que lee y valida el SSN de un estudiante</p>
  507  <p className="p">Listing 1.6 Imperative program that reads and validates a student’s SSN</p>
  508: <p className="it">Para una tarea tan sencilla, esto está empezando a parecer compleja; y el código carece el nivel deseado de modularidad con toda la lógica de negocio en un solo lugar. Además, esta función no es reutilizable debido a su dependencia de estado externo. Debido a la programación reactiva se basa en la programación funcional, se beneficia de la utilización de funciones puras de datos pro- Cess con las mismas operaciones conocidas, como el mapa y la reducción y la concisión de las expresiones lambda. Así que aprender funcional es la mitad de la batalla cuando el aprendizaje reactiva!</p>
  509: <p className="p">For such a simple task, this is beginning to look complex; and the code lacks the desired level of modularity with all business logic in a single place. Also, this function isn’t reusable due to its dependency on external state. Because reactive programming is based on functional programming, it benefits from the use of pure functions to pro- cess data with the same familiar operations like map and reduce and the terseness of lambda expressions. So learning functional is half the battle when learning reactive!</p>
  510   
  511  <p className="pag">Page 21</p>
  512  <p className="it">Este paradigma se activa a través de un artefacto muy importante que se llama un observable. ables observables permiten suscribe a una corriente de datos que se pueden procesar mediante la composición y las operaciones encadenando con elegancia. Vamos a verlo en acción y suscribirse a un campo de entrada simple para el SSN de un estudiante.</p>
  513  
  514: <p className="p">This paradigm is enabled through a very important artifact called an observable. Observ- ables let you subscribe to a stream of data that you can process by composing and chaining operations together elegantly. Let’s see it in action and subscribe to a simple input field for a student’s SSN.</p>
  515  <p className="it">Añadir 1,7 programa funcional que lee y valida el SSN de un estudiante:</p>
  516  
  ...
  525  <p className="it">¿Puede usted ver la similitud entre 1,7 y lista de programación con cadenas en el listado 1.5? Esto demuestra que si está procesando una colección de elementos o entradas de usuario, todo se abstrae y tratada de la misma manera exacta. Tengo mucho más que decir acerca de esto en el capítulo 8.  </p>
  526  
  527: <p className="p">Can you see the similarity between listing 1.7 and programming with chains in list- ing 1.5? This shows that whether you’re processing a collection of elements or user input, it’s all abstracted out and treated in the exact same manner. I have much more to say about this in chapter 8.  </p>
  528: <p className="it">Uno de los robos de balón más importantes es que todas las operaciones que se realizan en la lista- Ing 1.7 son completamente inmutable, y toda la lógica de negocio se segregan en funciones indi- viduo. Usted no tiene que usar funcional con reactivos, pero pensando funcionalmente te obliga a hacerlo, y cuando lo hace, se desbloquea una arquitectura realmente sorprendentes sobre la base de la programación funcional reactivo (FRP).</p>
  529  
  530: <p className="p">One of the most important takeaways is that all the operations performed in list- ing 1.7 are completely immutable, and all the business logic is segregated into individ- ual functions. You don’t have to use functional with reactive, but thinking functionally forces you to do so—and when you do, you unlock a truly amazing architecture based on functional reactive programming (FRP).</p>
  531: <p className="it">La programación funcional es un cambio de paradigma que puede transformar radicalmente la forma de hacer frente a las soluciones a los retos de programación. Así es FP un reemplazo para el diseño más populares orientado a objetos? Afortunadamente, la aplicación de programa-ming funcional a su código no es un enfoque de todo o nada, como se señala en las Michael Feathers citar al principio de este capítulo. De hecho, una gran cantidad de aplicaciones pueden beneficiarse del uso de FP junto a una arquitectura orientada a objetos. Debido al control rígido para bilidad immuta- y estado compartido, FP también es conocido por hacer la programación multihilo más sencillo. Debido a que JavaScript es una plataforma de un solo subproceso, esto no es algo que tenemos que preocuparse o cubrir en este libro. En el siguiente capítulo, me paso algún tiempo que destaca algunas de las principales diferencias entre el diseño funcional y orientada a objetos, que creo que le ayudará a asimilar la forma funcional de pensar con mayor facilidad.  </p>
  532  
  533: <p className="p">Functional programming is a paradigm shift that can dramatically transform the way you tackle solutions to any programming challenges. So is FP a replacement for the more popular object-oriented design? Fortunately, applying functional program- ming to your code isn’t an all-or-nothing approach, as noted in the Michael Feathers quote at the beginning of this chapter. In fact, lots of applications can benefit from using FP alongside an object-oriented architecture. Due to rigid control for immuta- bility and shared state, FP is also known for making multithreaded programming more straightforward. Because JavaScript is a single-threaded platform, this isn’t something we need to worry about or cover in this book. In the next chapter, I spend some time highlighting some of the key differences between functional and object- oriented design, which I believe will help you grok the functional way of thinking more easily.  </p>
  534  <p className="it">En este capítulo, he mencionado brevemente los temas que se tratarán en profundidad pasantes a cabo el libro a medida que se hunden más en un framework funcional de la mente. Si usted ha estado siguiente al de todos los conceptos hasta ahora, eso es genial, pero no se preocupe si se ha perdido algunas cosas: que sólo significa que ha recogido el libro adecuado. En programación orientada a objetos tradicionales, estás acostumbren a la programación en el estilo imperativo / de procedimiento; cambiando para ello será necesario hacer un cambio drástico en sus procesos de pensamiento a medida que comienza a abordar los problemas de la “forma funcional”.</p>
  535  
  536: <p className="p">In this chapter, I briefly touched on topics that will be covered in depth through- out the book as you sink deeper into a functional frame of mind. If you’ve been fol- lowing all the concepts so far, that’s great, but don’t worry if you missed a few things— that just means you’ve picked up the right book. In traditional OOP, you’re accus- tomed to programming in the imperative/procedural style; changing this will require you to make a drastic shift in your thought processes as you begin to tackle problems the “functional way.”</p>
  537  <p className="pag">Page 22</p>
  538  <h2 className="hdos">1.4	Summary</h2>
  ...
  546  <li className="litag">	Functional programming treats functions as building blocks by relying on first-class, higher-order functions to improve the modularity and reusability of your code.</li>
  547  <li className="littag"> Puede reducir la complejidad de los programas basados en eventos combinando funcionalidad con programación reactiva. </li>
  548: <li className="litag">	You can reduce the complexity of event-based programs by combining func- tional with reactive programming.</li>
  549  <p className="pag">Page 23 </p>
  550  

C:\Users\Emanuela\FunctionalP\pages\Ch2.js:
  110    <div className='col-md-3'></div>
  111  <div className='col-md-6'>
  112: <h1>Chapter 2 - Higher-order JavaScript</h1>
  113  <h2>This chapter covers</h2>
  114  <li classname="littag">	¿Por JavaScript es un lenguaje funcional adecuado</li>
  ...
  124  <li classname="littag">	El uso práctico de los cierres</li>
  125  <li className="litag">	Practical use of closures</li>
  126: <p classname="pit">El lenguaje natural tiene ningún paradigma dominante, y tampoco lo hace JavaScript. Los desarrolladores pueden elegir entre una caja de sorpresas de approaches- procedimental, funcional y orientada a objetos, y se mezclan según sea apropiado.</p>
  127  <p className="p">Natural language has no dominant paradigm, and neither does JavaScript. Developers can select from a grab bag of approaches— procedural, functional, and object-oriented—and blend them as appropriate.</p>
  128  <p classname="pit">-Angus Croll, Si Hemingway escribió JavaScript</p>
  129  <p className="p">—Angus Croll, If Hemingway Wrote JavaScript</p>
  130  <p className="pag">Page 24</p>
  131: <p classname="pit">A medida que las aplicaciones se hacen más grandes, también lo hace su complejidad. No importa lo bien que se cree que es, la confusión es inevitable si usted no tiene los modelos de programación adecuados en su lugar. En el capítulo 1, he explicado la programación funcional es un paradigma razones ling compel- adoptar. Pero por sí mismos paradigmas son sólo modelos de programación que necesitan la lengua de acogida derecho de venir a la vida.</p>
  132: <p className="p">As applications get bigger, so does their complexity. No matter how good you think you are, turmoil is unavoidable if you don’t have the proper programming models in place. In chapter 1, I explained the reasons functional programming is a compel- ling paradigm to adopt. But paradigms by themselves are just programming models that need the right host language to come to life.</p>
  133  <p classname="pit">En este capítulo, se lo llevará en un recorrido de paso rápido de un lenguaje híbrido que mezcla tanto la programación funcional, así como orientado a objetos: JavaScript. Por supuesto, esto no es en absoluto un extenso estudio de la lengua; más bien, me centraré en lo que permite JavaScript para utilizar funcionalmente, así como donde se queda corto. Un ejemplo de esto es la falta de apoyo a la inmutabilidad. Además, este capítulo trata sobre las funciones de orden superior y cierres, que en conjunto forman la columna vertebral que le permite escribir JavaScript en un estilo funcional. Sin más preámbulos, vamos a bucear en.</p>
  134  <p className="p">In this chapter, I take you on a fast-pass tour of a hybrid language that mixes both object-oriented as well as functional programming: JavaScript. Of course, this is by no means an extensive study of the language; rather, I’ll focus on what allows JavaScript to be used functionally as well as where it falls short. One example of this is the lack of support for immutability. In addition, this chapter covers higher-order functions and closures, which together form the backbone that allows you to write JavaScript in a functional style. Without further ado, let’s dive in.</p>
  ...
  137  <p className="p">I began by answering the question, “Why functional?” Another question that comes to mind is, “Why JavaScript?” The answer to this question is simple: omnipresence. JavaScript is a dynamically typed, object-oriented, general-purpose language with an immensely expressive syntax. It’s one of the most ubiquitous languages ever created and can be seen in the development of mobile applications, websites, web servers, desktop and embedded applications, and even databases. Given its extraordinary adoption as the language of the web, it begs to reason that JavaScript is by far the most widely used FP language ever created.</p>
  138  <p classname="pit">A pesar de su sintaxis similar a C, JavaScript atrae un montón de inspiración de lenguajes funcionales como Lisp y Scheme. Sus puntos en común se encuentran en su apoyo a las funciones de mayor orden, cierres, literales de matriz, y otras características que hacen de JavaScript una plataforma excelente para la aplicación de técnicas de planificación familiar. De hecho, las funciones son las principales unidades de trabajo en JavaScript, lo que significa que son utilizados no sólo para conducir el comportamiento de sus aplicaciones, sino también para definir objetos, crear módulos y controlar los eventos.</p>
  139: <p className="p">Despite its C-like syntax, JavaScript draws lots of inspiration from functional lan- guages like Lisp and Scheme. Their commonalities lie in their support for higher- order functions, closures, array literals, and other features that make JavaScript a superb platform for applying FP techniques. In fact, functions are the main units of work in JavaScript, which means they’re used not only to drive the behavior of your applications, but also to define objects, create modules, and handle events.</p>
  140: <p classname="pit">JavaScript está evolucionando y mejorando activamente. Con el respaldo de la ECMAScript (ES) Stan- dard, su próximo gran lanzamiento, ES6, añade muchas más funciones para el idioma: flecha funciones, constantes, iteradores, promesas y otras características que se adapten a pro- gramación funcional muy bien.</p>
  141: <p className="p">JavaScript is actively evolving and improving. Backed by the ECMAScript (ES) stan- dard, its next major release, ES6, adds many more features to the language: arrow functions, constants, iterators, promises, and other features that suit functional pro- gramming very well.</p>
  142: <p classname="pit">A pesar del hecho de que tiene un montón de características funcionales de gran alcance, es importante saber thatJavaScript es tan como es funcional orientada a objetos. Por desgracia, este último se ve raramente; la mayoría de los desarrolladores utilizan operaciones mutables, estructuras de control imperativo, y cambios de estado instancia de los objetos, los cuales están virtualmente eliminados cuando de adoptar un estilo de estilo funcional. Sin embargo, creo que es importante pasar algún tiempo hablando de JavaScript como un lenguaje orientado a objetos primero para que pueda apreciar mejor las diferencias clave entre los dos paradigmas. Esto le permitirá dar el salto en la programación fun- cional con mayor facilidad.</p>
  143: <p className="p">Despite the fact that it has lots of powerful functional features, it’s important to know thatJavaScript is as object-oriented as it is functional. Unfortunately, the latter is rarely seen; most developers use mutable operations, imperative control structures, and instance state changes on objects, which are all virtually eliminated when adopt- ing a functional style. Nevertheless, I feel it’s important to spend some time talking about JavaScript as an object-oriented language first so that you can better appreciate the key differences between the two paradigms. This will allow you to leap into func- tional programming more easily.</p>
  144  <h2>2.2	Functional vs. object-oriented programming</h2>
  145  <p classname="pit">Tanto la programación funcional y orientado a objetos (POO) se puede utilizar para desarrollar de tamaño mediano a grandes sistemas. lenguajes híbridos como Scala y F #, por ejemplo, se mezclan ambos paradigmas en un solo idioma. JavaScript tiene una capacidad similar, y el dominio se trata de aprender a utilizar una combinación de ambos; decidir dónde trazar la línea depende de la preferencia personal y las exigencias del problema que abordar. Entender dónde funcional y orientado a objetos se aproxima a interceptar y difieren puede ayudar a la transición de una a la otra, o pensar en términos de cualquiera de ellos.</p>
  ...
  151  <p classname="pit">Cuando defino una relación entre un objeto y otro diciendo que es un subtipo o tipo derivado, l'm en referencia a la relación de prototipos que existe entre los objetos. Es importante aclarar que, si bien está orientado orientado a JavaScript, que no tiene herencia clásica ya que puede haber visto en otros lenguajes como Java.</p>
  152  <p className="p">When I define a relationship between one object and another by saying it's a subtype or derived type, l'm referring to the prototypal relationship that exists between the objects. It's important to clarify that although JavaScript is oriented-oriented, it doesn't have classical inheritance as you may have seen in other languages like Java.</p>
  153: <p classname="pit">En ES6, este mecanismo para la creación de enlaces entre los objetos prototipo ha sido (ERRO- neamente, según muchos) recubiertos de azúcar con palabras clave tales como la clase y se extiende. Esto hace objeto a codificar la herencia más sencillo, pero oculta el verdadero trabajo y el poder del mecanismo de prototipo de JavaScript. No voy a cubrir JavaScript enteder ori- a objetos en este libro (hacia el final de este capítulo, proporciono una referencia a un libro que trata sobre este y otros temas en profundidad).</p>
  154: <p className="p">In ES6, this mechanism for setting up prototype links between objects has been (erro- neously, according to many) sugar-coated with keywords such as class and extends. This makes coding object inheritance more straightforward but hides the real work and power of JavaScript's prototype mechanism. I won't cover object-ori- ented JavaScript in this book (toward the end of this chapter, I provide a reference to a book that discusses this and other topics in depth).</p>
  155: <p classname="pit">funcionalidad adicional se puede añadir mediante la derivación de Student adicionalmente con un tipo más específico, como CollegeStudent. En su esencia, programas orientados a objetos favorecen la crea- ción de nuevos objetos derivados como el principal medio para obtener la reutilización de código. En este caso, CollegeStudent volverá a utilizar todos los datos y el comportamiento de sus tipos de padres. Sin embargo, la adición de más funcionalidad a los objetos existentes puede ser complicado cuando no se aplica necesariamente a todos sus descendientes. Aunque nombre y apellido se aplican a persona y todos sus hijos, workAddress es posiblemente más relevante como parte de un objeto Employee (derivado de la Persona) de un objeto Student. La razón para el pintado de este modelo es que la principal diferencia entre las aplicaciones orientadas a objetos y funcional es cómo se organizan estos datos (propiedades del objeto) y el comportamiento (funciones).</p>
  156: <p className="p">Extra functionality can be added by deriving Student further with a more specific type, such as CollegeStudent. At their core, object-oriented programs favor the cre- ation of new derived objects as the principal means to gain code reuse. In this case, CollegeStudent will reuse all the data and behavior from its parent types. But adding more functionality to existing objects can be tricky when it doesn’t necessarily apply to all of its descendants. Although firstname and lastname apply to Person and all of its children, workAddress is arguably more relevant as part of an Employee object (derived from Person) than a Student object. The reason for painting this model is that the main difference between object-oriented and functional applications is how this data (the object’s properties) and behavior (functions) are organized.</p>
  157  <p classname="pit">aplicaciones orientadas a objetos, que son en su mayoría imperativo, dependen en gran medida a objetos basado encapsulación para proteger la integridad de su estado mutable, tanto directos como hereditaria, a fin de exponer o manipular ese estado a través de los métodos de instancia. Como resultado, hay un estrecho acoplamiento entre los datos de un objeto y su comportamiento de grano fino, formando un paquete cohesivo; este es el objetivo de los programas orientados a objetos y por qué la forma central de la abstracción es el objeto.</p>
  158: <p className="p">Object-oriented applications, which are mostly imperative, rely heavily on object- based encapsulation to protect the integrity of their mutable state, both direct and inherited, in order to expose or manipulate that state via instance methods. As a result, there’s a tight coupling between an object’s data and its fine-grained behavior, forming a cohesive package; this is the goal in object-oriented programs and why the central form of abstraction is the object.</p>
  159  <p classname="pit">Como alternativa, la programación funcional elimina la necesidad de ocultar los datos de las personas que llaman y por lo general trabaja con un conjunto más pequeño de tipos de datos muy simples. Debido a que todo esté inmutable, usted es libre de trabajar con objetos directamente, pero esta vez a través de funciones generalizadas que viven fuera del alcance de un objeto. En otras palabras, los datos se acopla libremente con el comportamiento. Como se puede ver en la figura 2.1, en lugar de los métodos de instancia FME grano, código funcional se basa en más operaciones de grano grueso que puede CrossCut o el trabajo a través de muchos tipos de datos. En este paradigma, las funciones se convierten en la principal forma de abstracción.</p>
  160: <p className="p">Alternatively, functional programming removes the need to hide data from the callers and typically works with a smaller set of very simple data types. Because every- thing is immutable, you’re free to work with objects directly, but this time through generalized functions that live outside of an object’s scope. In other words, data is loosely coupled to behavior. As you can see in figure 2.1, instead of fme-grained instance methods, functional code relies on more coarse-grained operations that can crosscut or work across many data types. In this paradigm, functions become the main form of abstraction.</p>
  161  <p className="pag">Page 26</p> 
  162  
  ...
  165  <p classname="pit">En cuanto a la figura 2.1, se ven los dos paradigmas difieren medida que se mueve hacia arriba y hacia la derecha. En la práctica, algunos de los mejores código orientado a objetos que he visto utiliza ambos paradigmas juntos, en su intersección. Para ello, es necesario tratar los objetos como entidades o valores inmutables y separar su funcionalidad en funciones que trabajan en estos objetos. Por lo tanto un método de persona que tiene este aspecto:</p>
  166  <p className="p">Looking at figure 2.1, you see the two paradigms differ as you move up and to the right. In practice, some of the best object-oriented code I’ve seen uses both paradigms together—at their intersection. To do this, you need to treat objects as immutable entities or values and separate their functionality into functions that work on these objects. So a method on Person that looks like this:</p>
  167: <p classname="pit">Como ya saben, JavaScript es un lenguaje de tipos dinámicos (lo que significa que nunca tendrá que escribir tipos explícitos junto a referencias a objetos), por lo nombre_completo () funciona con cualquier tipo derivado de persona (o cualquier objeto con propiedades nombre y apellido, para que materia), como se muestra en la figura 2.2. Dada su naturaleza dinámica, funciones de JavaScript apoyan el uso de las funciones polimórficas generalizadas. En otras palabras, las funciones que utilizan referen- cias basar tipos (como persona) trabajan en objetos de tipos derivados (tales como Student o CollegeStudent).</p>
  168: <p className="p">As you know, JavaScript is a dynamically typed language (which means you never have to write explicit types next to object references), so fullname() will work with any type derived from Person (or any object with properties firstname and lastname, for that matter), as shown in figure 2.2. Given its dynamic nature, JavaScript functions support the use of generalized polymorphic functions. In other words, functions that use ref- erences to base types (such as Person) work on objects of derived types (such as Student or CollegeStudent).</p>
  169  <p className="pag">Page 27</p>
  170  <p classname="pit">Figura 2.2 El enfoque de programación orientada a objetos es crear jerarquías de herencia (como estudiante de Parent) con métodos y datos fuertemente ligados juntos. La programación funcional, por el contrario, favorece generaI funciones polimórficas que crosscut diferentes tipos de datos y evitar el uso de este.</p>
  171  <p className="p">Figure 2.2 The focus of OOP is to create inheritance hierarchies (such as Student from Parent) with methods and data tightly bound together. Functional programming, on the other hand, favors generai polymorphic functions that crosscut different data types and avoid the use of this.</p>
  172: <p classname="pit">Como se puede ver en la figura 2.2, separando nombre completo () en una función independiente le anima a evitar el uso de la esta referencia a acceder a los datos de objeto. Usando esto es problemático, ya que le da acceso a los datos a nivel de instancia fuera del ámbito de método, lo que provoca efectos secundarios. El uso de FP, datos de objeto no está acoplado íntimamente a espe- partes especí- de su código y es mucho más reutilizable y fácil de mantener.</p>
  173: <p className="p">As you can see in figure 2.2, separating fullname() into a standalone function encourages you to avoid using the this reference to access object data. Using this is problematic because it gives you access to instance-level data outside of the method scope, which causes side effects. Using FP, object data is not intimately coupled to spe- cific parts of your code and is far more reusable and maintainable.</p>
  174  <p classname="pit">En lugar de crear un montón de tipos derivados, se puede ampliar el comportamiento de una función pasando otras funciones como argumentos. Para ilustrar esto, vamos a definir el modelo de datos simple en el listado siguiente, que contiene el estudiante clase que deriva de la persona. Yo uso este modelo en la mayoría de los ejemplos en este libro.</p>
  175  <p className="p">Instead of creating lots of derived types, you can extend the behavior of a function by passing other functions as arguments. To illustrate, let’s define the simple data model in the following listing, which contains the class Student that derives from Person. I use this model in most of the examples throughout this book.</p>
  ...
  203  <p className="pag">Page 29</p>
  204  <h2>Finding and running code examples</h2>
  205: <p classname="pit">Los ejemplos de código de este libro se pueden encontrar en la programación-en-javascript www.manning.com/books/functional- y al https://github.com/luijar/functional-programming-js. Siéntase libre de revisar el proyecto y comenzar a practicar la programación funcional por su cuenta. Le recomiendo que ejecuta cualquiera de las pruebas unitarias y jugar con los diferentes pro- gramas. En el momento de escribir estas líneas, ya que no todas las funciones JavaScript ES6 se han implementado en todos los navegadores, yo uso el transpiler Babel (anteriormente conocido como 6to5) para convertir el código en código ES6 ES5 equivalente.</p>
  206: <p className="p">The code samples for this book can be found at www.manning.com/books/functional- programming-in-javascript and at https://github.com/luijar/functional-programming-js. Feel free to check out the project and begin practicing functional programming on your own. I recommend that you run any of the unit tests and play with the different pro- grams. At the time of this writing, because not all JavaScript ES6 features have been implemented across all browsers, I use the Babel transpiler (formerly known as 6to5) to convert ES6 code into equivalent ES5 code.</p>
  207  <p classname="pit">Algunas características no necesitan transpilation y se pueden activar con una configuración de navegador como Habilitar JavaScript experimental de Chrome. Si se está ejecutando en modo experimental, que es importante para permitir el modo estricto mediante la adición de la afirmación 'use strict'; al comienzo de su archivo JavaScript.</p>
  208  <p className="p">Some features don't need transpilation and can be turned on with a browser setting like Chrome's Enable Experimental JavaScript. If you're running in experimental mode, it's important to enable strict mode by adding the statement 'use strict'; at the beginning of your JavaScript file.</p>
  ...
  210  <p className="p">Given a person, your task is to fìnd all of their friends that live in the same country as this person. Also, given a student, your task is to find other students living in the same country and attending the same school. The object-oriented solution tightly couples operations, via this and super, to the object and parent object, respectively:</p>
  211   
  212: <p classname="pit">Por otra parte, debido a FP se basa en la pureza y la transparencia referencial, por iso lating el comportamiento del estado se pueden añadir más operaciones mediante la definición y Bining com- nuevas funciones que trabajan en esos tipos. Al hacer esto, se termina con objetos simples de la carga de los datos anillo de sto, y funciones versátiles que pueden trabajar en esos objetos como argumentos, que pueden estar compuestos de lograr una funcionalidad especializada. No ha aprendido acerca de la composición todavía (que está cubierto en el capítulo 4), pero es importante destacar otra diferencia fundamental entre los paradigmas. En esencia, lo que hace la herencia de programación orientada a objetos, composición hace por FP en cuanto a la aplicación de un nuevo comportamiento a diferentes types.1 datos Para ejecutar este código, vamos a usar el siguiente conjunto de datos:</p>
  213: <p className="p">On the other hand, because FP is based on purity and referential transparency, by iso- lating the behavior from the state you can add more operations by defining and com- bining new functions that work on those types. Doing this, you end up with simple objects in charge of sto ring data, and versatile functions that can work on those objects as arguments, which can be composed to achieve specialized functionality. You haven’t learned about composition yet (it’s covered in chapter 4), but it’s important to highlight another fundamental difference between the paradigms. In essence, what inheritance does for OOP, composition does for FP in terms of applying new behavior to different data types.1 To run this code, you’ll use the following dataset:</p>
  214  <p className="pag">Page 30</p>
  215  <pre><code>{`
  ...
  233  <p className="pag">Page 31</p>
  234  <p classname="pit">Mediante la aplicación de la programación funcional, se crea una función completamente nueva, hallazgo StudentsBy, eso es mucho más fácil trabajar con ellos. Tenga en cuenta que esta nueva función se puede utilizar con cualquier objeto que se refieren a la persona, así como cualquier combinación de escuela y país.</p>
  235: <p className="p">By applying functional programming, you create an entirely new function, find- StudentsBy, that’s much easier to work with. Keep in mind that this new function works with any objects that relate to Person, as well as any school and country combination.</p>
  236: <p classname="pit">Esto demuestra claramente las diferencias entre los dos paradigmas. diseño orientado a objetos se centra en la naturaleza de los datos y las relaciones de datos, mientras que la programación fun- cional se centra en las operaciones realizadas en el comportamiento. Tabla 2.1 SUM- marizes otras diferencias clave que vale la pena notar que hablo de ellos en este capítulo y en otros a venir.</p>
  237: <p className="p">This clearly demonstrates the differences between the two paradigms. Object- oriented design focuses on the nature of data and data relationships, whereas func- tional programming focuses on the operations performed—behavior. Table 2.1 sum- marizes other key differences that are worth noticing as I talk about them in this chapter and others to come.</p>
  238  <p classname="pit">Tabla 2.1 Comparación de algunas cualidades importantes de la programación orientada a objetos y funcional. Estas cualidades son temas que se discuten en este libro.</p>
  239  <p className="p">Table 2.1 Comparing some important qualities of object-oriented and functional programming. These qualities are themes that are discussed throughout this book.</p>
  240: <p classname="pit">A pesar de sus diferencias, la creación de aplicaciones mediante la mezcla de estos paradigmas pueden ser un poderoso enfoque. Por un lado, se obtiene un modelo de dominio rico en rela- ciones naturales entre sus tipos de constituyentes; y por el otro, tiene un conjunto de fun- ciones puras que pueden trabajar en estos tipos. ¿Dónde se traza la línea dependerá de qué tan cómodo se siente usando paradigma. Debido a que es tan JavaScript orientado a objetos como es funcional, utilizando funcionalmente requerirá una atención especial en términos de controlar los cambios de estado.</p>
  241: <p className="p">Despite their differences, building applications by blending these paradigms can be a powerful approach. On the one hand, you get a rich domain model with natural rela- tionships among its constituent types; and on the other, you have a set of pure func- tions that can work on these types. Where you draw the line will depend on how comfortable you feel using either paradigm. Because JavaScript is as object-oriented as it is functional, using it functionally will require some special attention in terms of controlling state changes.</p>
  242  <h2>2.2.1	Managing the state of JavaScript objects</h2>
  243  <p classname="pit">El estado de un programa se puede definir como una instantánea de los datos almacenados en todos sus objetos en cualquier momento en el tiempo. Lamentablemente, JavaScript es uno de los peores idiomas cuando se trata de proteger el estado de un objeto. Un objeto JavaScript es muy dinámico, y se puede modificar, añadir o eliminar sus propiedades en cualquier punto en el tiempo. En la enumeración de 2,1, si espera _address a encapsular (el uso del subrayado es puramente sintáctica) dentro de persona, estás equivocado. Usted tiene acceso completo a esta propiedad fuera de la clase para hacer lo que le plazca o incluso eliminarlo.</p>
  ...
  247  <p classname="pit">Con la libertad viene una gran responsabilidad. Aunque esto puede darle la libertad de hacer muchas cosas resbaladizas como la creación de propiedad dinámica, sino que también puede dar lugar a código que es extremadamente difícil de mantener en los programas de medianas a grandes.</p>
  248  <p className="p">With freedom comes great responsibility. Although this may give you the liberty to do many slick things like dynamic property creation, it can also lead to code that’s extremely difficult to maintain in midsize-to-large programs.</p>
  249: <p classname="pit">He mencionado en el capítulo 1 que el trabajo con funciones puras hace que su código sea más fácil de mantener y razonar acerca. ¿Existe tal cosa como un objeto puro? Un objeto inmutable que contiene funcionalidad inmutable puede considerarse puro. El mismo nivel de razonamiento que se aplica a las funciones del mismo modo que se traduce a objetos simples. Manag- ing estado en JavaScript es crucial en nuestra búsqueda para utilizarlo como un lenguaje funcional. Hay algunas prácticas y patrones que se pueden utilizar para administrar la inmutabilidad, que vamos a visitar en las siguientes secciones, pero encapsulación completa y protección de datos serán un gran peso en su disciplina para hacerlo cumplir.</p>
  250: <p className="p">I mentioned in chapter 1 that working with pure functions makes your code easier to maintain and reason about. Is there such a thing as a pure object? An immutable object that contains immutable functionality can be considered pure. The same level of reasoning that applies to functions translates just as well to simple objects. Manag- ing state in JavaScript is crucial in our quest to use it as a functional language. There are some practices and patterns you can use to manage immutability, which we’ll visit in the next sections, but complete encapsulation and protection of data will weigh heavily in your discipline to enforce it.</p>
  251  <h2>2.2.2	Treating objects as values</h2>
  252: <p classname="pit">Cadenas y números son probablemente los tipos de datos más fácil de trabajar en cualquier lenguaje de programa- ming. ¿Por qué crees que es? Parte de la razón es que, tradicionalmente, estos tipos primitivos son inherentemente inmutable, lo que nos da una cierta tranquilidad de que otros tipos definidos por el usuario no lo hacen. En la programación funcional, que llamamos tipos que se comportan de esta manera los valores. En el capítulo 1, que ha aprendido a pensar en la inmutabilidad, y esto requiere de manera efectiva el tratamiento de cualquier objeto como un valor; al hacerlo le permite trabajar con las funciones que pasan alrededor de los objetos y no preocuparse de su alteración.</p>
  253: <p className="p">Strings and numbers are probably the easiest data types to work with in any program- ming language. Why do you think that is? Part of the reason is that, traditionally, these primitive types are inherently immutable, which gives us a certain peace of mind that other user-defined types don’t. In functional programming, we call types that behave this way values. In chapter 1, you learned to think about immutability, and this requires effectively treating any object as a value; doing so allows you to work with functions that pass objects around and not worry about them being altered.</p>
  254: <p classname="pit">A pesar de que todo el azúcar sintáctica añadió alrededor de las clases en ES6, objetos de JavaScript no son más que las bolsas de atributos que se pueden añadir, eliminar y cambiar en cualquier momento. ¿Qué se puede hacer para remediar esto? Muchos lenguajes de programación SUP- construcciones portuarias que conforman propiedades de un objeto inmutable. Un ejemplo es la palabra clave final de Java. Además, lenguajes como C # tienen las variables inmutables por defecto, a menos que se indique lo contrario. En la actualidad, no tiene este lujo en JavaScript. Aunque JavaScript tipos primitivos no se pueden cambiar, el estado de la variable que se refiere a un tipo de lata primitivo. Por lo tanto, tiene que ser capaz de proporcionar, o al menos emular, referencias inmutables a los datos para que sus objetos definidos por el usuario se comportan como si fueran inmutables.</p>
  255: <p className="p">Despite all the syntactic sugar added around classes in ES6, JavaScript objects are nothing more than bags of attributes that can be added, removed, and changed at any time. What can you do to remedy this? Many programming languages sup- port constructs that make an object’s properties immutable. One example is Java’s final keyword. Also, languages like F# have immutable variables by default, unless stated otherwise. At present, you don’t have this luxury in JavaScript. Although JavaScript primitive types can’t be changed, the state of the variable that refers to a primitive type can. Therefore, you need to be able to provide, or at least emulate, immutable references to data so that your user-defined objects behave as if they were immutable.</p>
  256: <p classname="pit">ES6 utiliza la palabra clave const para crear referencias constantes. Esto mueve la aguja en la dirección correcta, porque las constantes no se pueden reasignar o re-declaran. En la programación funcional prác- cal, puede utilizar const como un medio para llevar los datos simples configuraciones ción (cadenas URL, nombres de bases de datos, etc.) en su programa funcional si es necesario. Aunque la lectura de una variable externa es un efecto secundario, la plataforma pro-porciona una semántica especial a constantes por lo que no va a cambiar de forma inesperada entre llamadas ción fun-. He aquí un ejemplo de declarar un valor constante:</p>
  257: <p className="p">ES6 uses the const keyword to create constant references. This moves the needle in the right direction because constants can’t be reassigned or re-declared. In practi- cal functional programming, you can use const as a means to bring simple configura- tion data (URL strings, database names, and so on) into your functional program if need be. Although reading from an external variable is a side effect, the platform pro- vides special semantics to constants so they won’t change unexpectedly between func- tion calls. Here’s an example of declaring a constant value:</p>
  258  
  259   
  ...
  261  <p classname="pit">Pero esto no resuelve los problemas de la mutabilidad al nivel que requiere FP. Puede impedir que una variable sea reasignado, pero ¿cómo se puede evitar que el estado interno de un objeto de cambiar? Este código sería perfectamente aceptable:</p>
  262  <p className="p">But this doesn’t solve the problems of mutability to the level that FP requires. You can prevent a variable from being reassigned, but how can you prevent an object’s internal state from changing? This code would be perfectly acceptable:</p>
  263: <p classname="pit">Lo que necesita es una política más estricta para la inmutabilidad; y la encapsulación es una buena es- trategia para proteger contra las mutaciones. Para estructuras de objetos simples, una buena alternativa es adoptar el modelo de objetos de valor. Un objeto de valor es uno cuya igualdad no depende de identidad o de referencia, sólo en su valor; una vez declarada, su estado no puede cambiar. Además de los números y cadenas, algunos ejemplos de objetos de valor son tipos como tupla, par, punto, código postal, coordinar, el dinero, la fecha y otros. He aquí un ción ¡Ejecución de Código postal:</p>
  264: <p className="p">What you need is a stricter policy for immutability; and encapsulation is a good strat- egy to protect against mutations. For simple object structures, a good alternative is to adopt the Value Object pattern. A value object is one whose equality doesn’t depend on identity or reference, just on its value; once declared, its state may not change. In addition to numbers and strings, some examples of value objects are types like tuple, pair, point, zipCode, coordinate, money, date, and others. Here’s an implementa- tion for zipCode:</p>
  265  <pre><code>{`
  266  function zipCode(code, location) { let _code = code; let _location = location ||	'';
  ...
  282  princetonZip.toString(); / /-> '08544-3345'
  283  `}</code></pre>
  284: <p classname="pit">En JavaScript, puede utilizar las funciones y proteger el acceso al estado interno de un código postal mediante la devolución de una interfaz literal objeto que expone un pequeño conjunto de métodos a la persona que llama y trata _code y _location como variables seudo-privada. Estas variables son sólo acce- sible en el objeto literal a través de cierres, que se verá más adelante en este capítulo.</p>
  285: <p className="p">In JavaScript, you can use functions and guard access to a ZIP code’s internal state by returning an object literal interface that exposes a small set of methods to the caller and treats _code and _location as pseudo-private variables. These variables are only acces- sible in the object literal via closures, which you’ll see later in this chapter.</p>
  286  <p classname="pit">El objeto devuelto se comporta efectivamente como un primitivo que no tiene ods.2 met mutando Por lo tanto, el método toString, aunque no es una pura función, se comporta como tal y es una representación de cadena de este objeto puro. objetos de valor son ligeros y</p>
  287: <p className="p">The returned object effectively behaves like a primitive that has no mutating meth- ods.2 Hence, the toString method, although not a pure function, behaves like one and is a pure string representation of this object. Value objects are lightweight and</p>
  288: <p className="ind">index 2 The object’s internal state may be protected, but its behavior is still subject to mutation because you can dynamically remove or replace any of its methods. easy to work with in both functional and OOP. In conjunction with const, you can cre- ate objects with semantics similar to those of a string or number. Let’s consider another example:</p>
  289  <p className="pag">Page 34</p> 
  290  <p classname="pit">El uso de métodos para devolver nuevas copias (como en translate) es otra forma de implementar la inmutabilidad. La aplicación de una operación de traducción sobre este objeto genera un nuevo objeto de coordenadas:</p>
  ...
  294  greenwich.translate(10, 10).toString(); //-> '(61.4778, 10.0015)'`}</code></pre>
  295  <p classname="pit">Value Object es un patrón de diseño orientado a objetos que se inspiró en la programación funcional. Este es otro ejemplo de cómo los paradigmas se complementan elegantemente. Este patrón es ideal, pero no es suficiente para modelar dominios completos del problema del mundo real. En la práctica, es probable que el código se necesita para manejar los datos jerárquicos (como se vio con la Persona y Estudiantes antes), así como interactuar con los objetos heredados. Por suerte, JavaScript tiene un mecanismo para emularlo usando Object.freeze.</p>
  296: <p className="p">Value Object is an object-oriented design pattern that was inspired by functional pro- gramming. This is another example of how the paradigms elegantly complement each other. This pattern is ideal, but it’s not enough for modeling entire real-world prob- lem domains. In practice, it’s likely your code will need to handle hierarchical data (as you saw with Person and Student earlier) as well as interact with legacy objects. Luck- ily, JavaScript has a mechanism to emulate this using with Object.freeze.</p>
  297  <h2>2.2.3 Deep-freezing moving parts</h2>
  298  <p classname="pit">sintaxis nueva clase de JavaScript no define palabras clave para mark fields como inmutable, sino que es compatible con un mecanismo interno para hacerlo, mediante el control de algunas metapropiedades de objetos ocultos como escritura. Al establecer esta propiedad en false, la función de JavaScript Object.freeze () puede prevenir el estado de un objeto a partir de cambiar. Vamos a empezar por la congelación de la persona objeto del listado 2.1:</p>
  ...
  304  
  305  <pre><code>{`TypeError: Cannot assign to read only property '_firstname' of #`}</code></pre>
  306: <p classname="pit">Object.freeze () también puede inmovilizar atributos heredados. Así que la congelación de una instancia de Student funciona exactamente de la misma manera y sigue la cadena de prototipo del objeto protect- ing todos los atributos heredados persona. Pero no se puede usar para congelar objeto anidado Butes atri-, como se muestra en la figura 2.3.</p>
  307: <p className="p">Object.freeze() can also immobilize inherited attributes. So freezing an instance of Student works exactly the same way and follows the object’s prototype chain protect- ing every inherited Person attribute. But it can’t be used to freeze nested object attri- butes, as shown in figure 2.3.</p>
  308  <p classname="pit">Figura 2.3 Aunque el tipo persona ha sido congelado, sus propiedades de objeto internai (como _address) no tienen. Así person.address.country es elegible para ser cambiado en cualquier momento. Debido a que sólo las variables de nivel superior se congelan, se trata de una congelación superficial.</p>
  309  <p className="p">Figure 2.3 Although the Person type has been frozen, its internai object properties (like _address) haven’t. So person.address.country is eligible to be changed at any time. Because only the top-level variables are frozen, this is a shallow freeze.</p>
  ...
  343  <p classname="pit">Yo sólo he mostrado algunas técnicas que puede utilizar para hacer cumplir un nivel de inmutabilidad en su código, pero es poco realista esperar que se pueden crear aplicaciones completas sin tener que modificar ningún estado. Por lo tanto, las políticas estrictas cuando se crean nuevos objetos a partir de originales (como se</p>
  344  <p className="p">I’ve just shown some techniques you can use to enforce a level of immutability in your code, but it’s unrealistic to expect that you can create entire applications without ever modifying any state. Thus, strict policies when creating new objects from originals (as</p>
  345: with coordinate.translate() ) are extremely beneficial in your quest to reduce the complexities and intricacies ofJavaScript applications. Next, I discuss the best alterna- tive to centrally managing object changes immutably using a functional approach called lenses.
  346  <p className="pag">Page 37</p>
  347  <h2>2.2.4	Navigating and modifying object graphs with lenses</h2>
  ...
  349  <p className="p">In OOP, you’re accustomed to calling methods that change the internal contente of a stateful object. This has the disadvantage of never being able to guarantee the outcome of retrieving the state and may break the functionality of part of the system that expects the object to stay intact. You could opt to implement your own copy-on-write strategy and return new objects from each method call—a tedious and error-prone process, to say the least. A simple setter function in the Person class would look like this:</p>
  350  <p classname="pit">Ahora imagina tener que hacer esto para cada característica de cada tipo en su modelo de dominio. Necesita una solución para mutar objetos con estado, de una manera inmutable, eso es discreto y no requiere hardcoding código repetitivo en todas partes. Lentes, también conocidos como referencias funcionales, son la solución de programación funcional para acceder y manipular de manera inmutable atributos de tipos de datos con estado. Internamente, las lentes funcionan de manera similar a una estrategia de copia en escritura mediante el uso de un componente de almacenamiento interno que sabe cómo manejar adecuadamente y copiar estado. No es necesario poner en práctica esto por sí mismo; más bien, se puede utilizar una biblioteca de JavaScript llamada funcional Ramda.js (detalles sobre el uso de esta y otras bibliotecas se pueden encontrar en el apéndice). Por defecto, Ramda expone toda la funcionalidad ite a través del objeto global R. Usando R.lensProp, puede CRE comió una lente que se envuelve sobre la propiedad apellido de la persona:</p>
  351: <p className="p">Now imagine having to do this for every single property of every type in your domain model. You need a solution for mutating stateful objects, in an immutable manner, that’s unobtrusive and doesn’t require hardcoding boilerplate code everywhere. Lenses, also known as functional references, are functional programming’s solution to accessing and immutably manipulating attributes of stateful data types. Internally, lenses work similarly to a copy-on-write strategy by using an internal storage component that knows how to properly manage and copy state. You don’t need to implement this yourself; rather, you can use a functional JavaScript library called Ramda.js (details about using this and other libraries can be found in the appendix). By default, Ramda exposes all of ite functionality via the global object R. Using R.lensProp, you can cre- ate a lens that wraps over the lastname property of Person:</p>
  352  <pre><code>{`
  353  var person = new Person('Alonzo', 'Church', '444-44-4444'); var lastnameLens = R.lenseProp('lastName');`}</code></pre>
  ...
  356  <pre><code>{`R.view(lastnameLens, person); //-> 'Church'`}</code></pre>
  357  <p classname="pit">Esto es, para todos los propósitos prácticos, similar a un método get apellido (). Nada impresionante hasta ahora. ¿Qué hay de la incubadora? Aquí es donde entra en juego la magia Ahora, Call-ing R.set crea y devuelve una copia de nueva del objeto que contiene el nuevo valor y conserva el estado instancia original (la semántica copia en escritura gratis!).:</p>
  358: <p className="p">This is, for all practical purposes, similar to a get lastname() method. Nothing impressive so far. What about the setter? Here’s where the magic comes in. Now, call- ing R.set creates and returns a brand-new copy of the object containing the new value and preserves the original instance state (copy-on-write semantics for free!):</p>
  359  <pre><code>{`var newPerson = R.set(lastnameLens, 'Mourning', person); newPerson.lastname;
  360   / /-> 'Mourning' person.lastname; //-> 'Church'`}</code></pre>
  ...
  362  <p className="pag">Page 38</p>
  363  <p classname="pit">Las lentes son valiosos porque le dan un mecanismo discreto de objetos ING manipulat-, incluso si estos son objetos heredados u objetos fuera de su control. Las lentes también son compatibles con propiedades anidadas, como la propiedad de dirección de la persona:</p>
  364: <p className="p">Lenses are valuable because they give you an unobtrusive mechanism for manipulat- ing objects, even if these are legacy objects or objects outside of your control. Lenses also support nested properties, like the address property of Person:</p>
  365  <pre><code>{`
  366  person.address = new Address(
  ...
  382  <p className="p">Now that you understand how to work with objects properly, I’ll shift gears and address the topic of functions. Functions drive the moving pieces of your application and are the heart of functional programming.</p>
  383  <h2>2.3	Functions</h2>
  384: <p classname="pit">En la programación funcional, las funciones son las unidades básicas de trabajo, lo que significa que los centros cosa every- alrededor de ellos. Una función es cualquier expresión exigible que puede ser evaluada aplicando el operador () a la misma. Las funciones pueden devolver ya sea un valor calculado o indefinido (función void) de nuevo a la persona que llama. Como FP funciona muy parecido a las matemáticas, fun- ciones sólo son significativos cuando producen un resultado útil (no es nulo o no definido); de lo contrario, el supuesto es que modifican datos externos y causan efectos secundarios que se produzca. Para el propósito de este libro, podemos distinguir entre expresiones (funciones que producen un valor) y declaraciones (funciones que no lo hacen). programación imperativa y de procedimientos realizados en su mayoría por secuencias ordenadas de declaraciones; pero FP es totalmente expresivo, por lo que las funciones de vacío no sirven a un propósito en este paradigma.</p>
  385: <p className="p">In functional programming, functions are the basic units of work, which means every- thing centers around them. A function is any callable expression that can be evaluated by applying the () operator to it. Functions can return either a computed value or undefined (void function) back to the caller. Because FP works a lot like math, func- tions are meaningful only when they produce a usable result (not null or undefined); otherwise, the assumption is that they modify external data and cause side effects to occur. For the purpose of this book, we can distinguish between expressions (functions that produce a value) and statements (functions that don’t). Imperative and procedural programming are mostly made up of ordered sequences of statements; but FP is entirely expressional, so void functions don’t serve a purpose in this paradigm.</p>
  386: <p classname="pit">funciones de JavaScript tienen dos características importantes que son el pan y ter pero- de su estilo funcional: son de primera clase y de orden superior. Vamos a explorar tanto de estas ideas con detalle a continuación.</p>
  387: <p className="p">JavaScript functions have two important characteristics that are the bread and but- ter of its functional style: they’re first-class and higher-order. We’ll explore both of these ideas in detail next.</p>
  388   
  389  <p className="pag">Page 39</p>
  ...
  434  <li className="litag">	If comparator returns greater than 0, p1 comes after p2.</li>
  435  <p classname="pit">Además de ser asignables, como funciones de JavaScript sort () aceptan otras funciones como argumentos y pertenecen a una categoría llamada funciones de orden superior.</p>
  436: <p className="p">In addition to being assignable, JavaScript functions like sort() accept other func- tions as arguments and belong to a category called higher-order functions.</p>
  437  <h2>2.3.2	Higher-order functions</h2>
  438  <p classname="pit">Dado que las funciones se comportan como objetos normales, se puede esperar que intuitivamente se pueden pasar como argumentos de funciones y desistieron de otras funciones. Estos se llaman funciones de orden superior. Que viste la función de comparación para Array.sort (); vamos a ver rápidamente en algunos otros ejemplos.</p>
  439  <p className="p">Because functions behave like regular objects, you can intuitively expect that they can be passed in as function arguments and returned from other functions. These are called higher-order functions. You saw the comparator function for Array.sort() ; let’s quickly look at some other examples.</p>
  440  <p classname="pit">El siguiente fragmento de muestra que las funciones pueden ser pasados ​​a otras funciones. La función applyOperation toma dos argumentos y aplica cualquier función operador para ambos:</p>
  441: <p className="p">The following snippet shows that functions can be passed in to other functions. The applyOperation function takes two arguments and applies any operator func- tion to both of them:</p>
  442  <pre><code>{`
  443  function applyOperation(a, b, opt) { return opt(a,b);
  ...
  450  <p classname="pit">En el siguiente ejemplo, la función de complemento toma un argumento y devuelve una función que, a su vez, recibe un segundo argumento y los suma:</p>
  451  <p className="p">In the next example, the add function takes an argument and returns a function that, in turn, receives a second argument and adds them together:</p>
  452: <p classname="pit">Dado que las funciones son de primera clase y de orden superior, las funciones de JavaScript pueden comportarse como valores, lo que implica que una función no es más que un valor todavía-a-ser ejecutado definidos inmutable en base a la entrada proporcionada a la función. Este principio está incorporado en todo lo que haces en la programación funcional, especialmente cuando se pone en cadenas de funciones, como se verá en el capítulo 3. Cuando la construcción de cadenas de funciones, siempre vas a confiar en los nombres de funciones para que apunte a un pedazo de una programa que se eje- cuta como parte de toda una expresión.</p>
  453: <p className="p">Because functions are first-class and higher-order, JavaScript functions can behave as values, which implies that a function is nothing more than a yet-to-be-executed value defined immutably based on the input provided to the function. This principle is embedded in everything that you do in functional programming, especially when you get into function chains, as you’ll see in chapter 3. When building function chains, you’ll always rely on function names to point to a piece of a program that will be exe- cuted as part of an entire expression.</p>
  454  <p classname="pit">Se pueden combinar las funciones de orden superior para crear expresiones significativas de piezas más pequeñas y simplificar muchos programas que de otro modo sería tedioso de escribir. A modo de ejemplo, digamos que usted necesita para imprimir una lista de las personas que viven en los Estados Unidos. Su primer acercamiento probablemente se vería como el código imperativo:</p>
  455  <p className="p">You can combine higher-order functions to create meaningful expressions from smaller pieces and simplify many programs that would otherwise be tedious to write. As an example, say you need to print a list of people who live in the United States. Your first approach would probably look like this imperative code:</p>
  ...
  472  <p className="pag">Page 42</p>
  473  <p classname="pit">Un patrón notable que se produce en lenguajes como JavaScript es que los nombres de funciones pueden ser sustantivos pasivos como multiplicador, comparador, y la acción. Debido a que son de primera clase, las funciones se pueden asignar a las variables y se ejecutan en un momento posterior. Vamos a refactorizar printPeople a aprovechar al máximo las funciones de orden superior:</p>
  474: <p className="p">A noticeable pattern that occurs in languages like JavaScript is that function names can be passive nouns like multiplier, comparator, and action. Because they’re first- class, functions can be assigned to variables and executed at a later time. Let’s refactor printPeople to take full advantage of higher-order functions:</p>
  475  <p classname="pit">Esta es la mentalidad que debe desarrollar para abrazar plenamente la programación funcional. Este ejercicio muestra que el código es mucho más flexible que lo que comenzó, porque se puede intercambiar rápidamente (o configurar) los criterios de selección, así como el cambio en el que desea imprimir. Los capítulos 3 y 4 se centran en este tema y el uso de bibliotecas especiales para encadenar operaciones fluidez juntos y construir programas complejos de partes simples.</p>
  476  <p className="p">This is the mindset you must develop to fully embrace functional programming. This exercise shows that the code is a lot more flexible than what you started with, because you can quickly swap (or configure) the criteria for selection as well as change where you want to print. Chapters 3 and 4 focus on this topic and the use of special libraries to fluently chain operations together and build complex programs from simple parts.</p>
  ...
  495  <li classname="littag"> Como una función-El mundial referencia a la presente se establece ya sea al objeto global o indefinido (en modo estricto):</li>
  496  <li className="litag"> As a global function—The reference to this is set either to the global object or to undefined (in strict mode):</li>
  497: <p classname="pit">Como se puede ver en estos ejemplos, al contrario que en otros lenguajes de programación, el esta referencia se establece en función de cómo se utiliza la función (a nivel mundial, como un método de objeto, como constructor, y así el hijo) y no por su contexto léxica (su ubicación en el código). Esto puede conducir a código que es difícil de entender, porque es necesario prestar aten- ción cerca del contexto en el que una función se está ejecutando.</p>
  498: <p className="p">As you can see from these examples, unlike in other programming languages, the this reference is set based on how the function is used (globally, as an object method, as a constructor, and so son) and not by its lexical context (its location in the code). This can lead to code that’s hard to understand, because you need to pay close atten- tion to the context in which a function is executing.</p>
  499: <p classname="pit">He incluido esta sección porque es importante que usted sepa como oper desa- JavaScript; pero, como he indicado varias veces, el uso de esta en el código funcional es rara vez visto (de hecho, ha evitado a toda costa). Es muy utilizada por biblioteca y implement- herramienta ERS para casos especiales que exigen el contexto de flexión lenguaje para realizar hazañas increíbles. Estos implican a menudo la función se aplican métodos y llamada.</p>
  500: <p className="p">I included this section because it’s important for you to know as a JavaScript devel- oper; but as I’ve indicated several times, the use of this in functional code is rarely seen (in fact, it’s avoided at all costs). It’s heavily used by library and tool implement- ers for special cases that demand bending the language context to perform incredible feats. These often involve the function methods apply and call.</p>
  501   
  502  <p className="pag">Page 44</p>
  ...
  504  <p classname="pit">JavaScript soporta la llamada a las funciones a través de los métodos de la función (como los meta-cali funciones) y aplicar, que pertenecen al prototipo de la función. Ambos métodos se utilizan ampliamente cuando el código de andamios esta construida de manera que los usuarios de la API pueden crear nuevas funciones de los ya existentes. Vamos a echar un vistazo rápido a escribir una función negate, por ejemplo:</p>
  505  <p className="p">JavaScript supports calling functions via the function methods (like meta-functions) cali and apply, which belong to the function’s prototype. Both methods are used extensively when scaffolding code is built so that API users can create new functions from existing ones. Let’s take a quick look at writing a negate function, for example:</p>
  506: <p classname="pit">La función negate crea una nueva función que invoca su argumento y luego logi- niega camente ella. En este ejemplo se utiliza aplicar, pero se puede utilizar la llamada de la misma manera; la dife- rencia es que este último acepta una lista de argumentos, mientras que la primera tiene una matriz de argumentos. El primer argumento, thisArg, se puede utilizar para manipular el texto con- función según sea necesario. Aquí están las dos firmas:</p>
  507: <p className="p">The negate function creates a new function that invokes its argument and then logi- cally negates it. This example uses apply, but you could use call the same way; the dif- ference is that the latter accepts an argument list, whereas the former takes an array of arguments. The first argument, thisArg, can be used to manipulate the function con- text as needed. Here are both signatures:</p>
  508  <pre><code>{`Function.prototype.apply(thisArg, [argsArray])
  509  Function.prototype.call(thisArg, arg1,arg2,...)`}</code></pre>
  510  <p classname="pit">Si thisArg refiere a un objeto, se establece en el objeto se llama al método sobre. Si thisArg es nulo, el contexto función se ajusta al objeto global, y la función se comporta como una simple función global. Pero si el método es una función en modo estricto, el valor real de null se pasa.</p>
  511  <p className="p">If thisArg refers to an object, it’s set to the object the method is called on. If thisArg is null, the function context is set to the global object, and the function behaves like a simple global function. But if the method is a function in strict mode, the actual value of null is passed in.</p>
  512: <p classname="pit">Manipulando el contexto función a través de thisArg abre la puerta a muchas técnicas dife- rentes. Esto no se recomienda en la programación funcional, porque nunca se basa en el estado de contexto (recuérdese que todos los datos se proporciona a funciones como argumentos), por lo que no voy a pasar más tiempo en esta función.</p>
  513: <p className="p">Manipulating the function context through thisArg opens the door to many dif- ferent techniques. This is discouraged in functional programming, because it never relies on the context state (recall that all data is provided to functions as arguments), so I won’t spend any more time on this feature.</p>
  514  <p classname="pit">Aunque la noción de un contexto global o un objeto compartido no es del todo útil en JavaScript funcional, hay un contexto específico que nos importa: el contexto función. Para entenderlo, hay que entender cierres y alcances.</p>
  515  <p className="p">Although the notion of a shared global or object context isn’t all that useful in functional JavaScript, there’s one specific context we care about: the function context. To understand it, you must understand closures and scopes.</p>
  ...
  517  <p className="pag">Page 45</p>
  518  <h2>2.4 Closures and scopes</h2>
  519: <p classname="pit">Antes de JavaScript, cierres sólo existía en idiomas FP utilizados en ciertas aplica- ciones específicas. JavaScript es el primero en adoptar en el desarrollo de la corriente principal y signifi- Canti cambiar la forma en que se escribe código. Vamos a revisar el tipo de Código postal:</p>
  520: <p className="p">Prior to JavaScript, closures only existed in FP languages used in certain specific appli- cations. JavaScript is the first to adopt it into mainstream development and signifi- canti change the way in which we write code. Let’s revisit the zipCode type:</p>
  521  <pre><code>{`
  522  function zipCode(code, location) { let _code = code; let _location = location ||	'';
  ...
  540  <p className="p">This is a bit mind-bending, and it’s all thanks to the closure that forms around object and function declarations in JavaScript. Being able to access data this way has many practical uses; in this section, we’ll look at using closures to emulate private variables, fetch data from the server, and force block-scoped variables.</p>
  541  <p classname="pit">Un cierre es una estructura de datos que se une a una función de su entorno en el momento en que se declaró. Se basa en la ubicación del texto de la declaración de la función; por lo tanto, un cierre también se llama un alcance estático o léxico que rodea a la definición de la función. Ya que da acceso a las funciones a su estado circundante, que hace que el código lectura clara y capaz. Como veremos en breve, los cierres son fundamentales no sólo en los programas funcionales cuando se trabaja con funciones de orden superior, sino también para la gestión de eventos y devoluciones de llamada, emulando las variables privadas, y la mitigación de las trampas de algunos ofJavaScript. </p>
  542: <p className="p">A closure is a data structure that binds a function to its environment at the moment it’s declared. It’s based on the textual location of the function declaration; therefore, a closure is also called a static or lexical scope surrounding the function definition. Because it gives functions access to its surrounding state, it makes code clear and read- able. As you’ll see shortly, closures are instrumental not only in functional programs when you’re working with higher-order functions, but also for event-handling and callbacks, emulating private variables, and mitigating some ofJavaScript’s pitfalls.</p>
  543: <p classname="pit">Las reglas que rigen el comportamiento de cierre de una función están estrechamente relacionados con reglas de alcance de JavaScript. A grupos alcance un conjunto de enlaces variables y define una sec- ción de código en el que se define una variable. En esencia, es un cierre heren- cia de una función de ámbitos afines a cómo el método de un objeto tiene acceso a su instancia heredadas variables ambos tienen referencias a sus padres. Los cierres se ven fácilmente en el caso de funciones anidadas. Aquí está un ejemplo rápido: </p>
  544: <p className="p">The rules that govern the behavior of a function’s closure are closely related to JavaScript’s scoping rules. A scope groups a set of variable bindings and defines a sec- tion of code in which a variable is defined. In essence, a closure is a function’s inheri- tance of scopes akin to how an object’s method has access to its inherited instance variables—both have references to their parents. Closures are readily seen in the case of nested functions. Here’s a quick example:</p>
  545  <p className="pag">Page 46</p>
  546  <p classname="pit">Es importante notar en este ejemplo que a pesar de que las variables de cantidad y de bases en ambas funciones ya no están en el ámbito activo son, siguen siendo accesibles desde la función devuelta cuando se invoca. En esencia, se puede imaginar las funciones anidadas añadir y plantean como funciones que el paquete no sólo su cómputo sino también una instantánea de todas las variables que les rodea. En términos más generales, como se muestra en la figura 2.4, ClO de una función de seguro incluye lo siguiente: </p>
  547: <p className="p">It’s important to notice in this example that even though the amount and base variables in both functions are no longer in the active scope, they’re still accessible from the returned function when invoked. Essentially, you can imagine the nested functions add and raise as functions that package not only their computation but also a snapshot of all variables surrounding them. More generally, as shown in figure 2.4, a function’s clo- sure includes the following:</p>
  548  <li classname="littag">	Todos los parámetros de la función (params y params2, en este caso)</li>
  549  <li className="litag">	All function parameters (params and params2, in this case)</li>
  ...
  561  <p className="p">At first glance, this may seem unintuitive and somewhat mystical. You’d expect that locai variables—innervar in this case—would cease to exist or be garbage-collected after makeInner returned, thereby printing undefined. Behind the scenes, it’s again the magic of closures that makes this possible. The function returned from makeInner remembers all the variables in the scope at the time it was declared and also prevents them from being disposed of. The global scope is also part of this closure, giving access to outerVar as well; I’ll revisit closures and what’s inside a function context in chapter 7.</p>
  562  <p classname="pit">Usted puede preguntarse cómo las variables (como additionalVars) declararon después de una función se declara también puede ser incluido como parte de su cierre. Para responder a esto, es necesario que Deben conocerse que JavaScript tiene tres formas de alcance: ámbito global, ámbito de la función, y un alcance de pseudo-bloque. </p>
  563: <p className="p">You may wonder how variables (like additionalVars) declared after a function is declared can also be included as part of its closure. To answer this, you need to under- stand that JavaScript has three forms of scoping: global scope, function scope, and a pseudo-block scope.</p>
  564  <h2>2.4.1 Problems with the global scope</h2>
  565: <p classname="pit">ámbito global es la forma más simple de determinación del alcance, pero también lo peor. Todos los objetos y Ables variabilidad declaradas en el nivel más exterior de un script (no contenida en cualquier función) son parte del alcance global y accesible desde todo el código JavaScript. Recordemos que nuestro objetivo en la programación funcional es evitar que cualquier cambio observables a rizarse hacia fuera de fun- ciones; pero en el ámbito mundial, cada línea que se ejecuta provoca cambios visibles que se produzca. </p>
  566: <p className="p">Global scope is the simplest form of scoping, but also the worst. Any objects and vari- ables declared in the outermost level of a script (not contained in any function) are part of the global scope and accessible from all JavaScript code. Recall that our goal in functional programming is to prevent any observable changes to ripple out from func- tions; but in the global scope, every line that executes causes visible changes to occur.</p>
  567  <p classname="pit">Es tentador usar variables globales, pero están compartidos entre todos los scripts cargados en la página, que puede conducir fácilmente a las colisiones de espacio de nombres si el código JavaScript no está empacado en módulos. Contaminar el espacio de nombres global puede ser problemático porque se corre el riesgo de anular las variables y funciones declaradas en diferentes archivos. </p>
  568: <p className="p">It’s tempting to use global variables, but they’re shared among all scripts loaded onto the page, which can easily lead to namespace collisions if your JavaScript code isn’t pack- aged into modules. Polluting the global namespace can be problematic because you run the chance of overriding variables and functions declared in different files.</p>
  569  <p classname="pit">Los datos globales tiene el efecto perjudicial de hacer que los programas difícil de razonar acerca de porque usted está obligado a mantener una nota mental de la situación de todas las variables en cualquier punto en el tiempo. Esta es una de las principales razones de la complejidad del programa aumenta a medida que su código se hace más grande. Es también favorece a tener efectos secundarios en sus funciones, ya que, inevitablemente, crear dependencias externas al leer o escribir en él. Debería ser obvio en este punto que cuando se escribe en un estilo FP, evitará el uso de variables globales a toda costa. </p>
  570  <p className="p">Global data has the detrimental effect of making programs hard to reason about because you’re obligated to keep a mental note of the state of all variables at any point in time. This is one of the main reasons program complexity increases as your code becomes larger. It’s also conducive to having side effects in your functions, because you inevitably create external dependencies when reading from or writing to it. It should be obvious at this point that when writing in an FP style, you’ll avoid using global variables at all cost.</p>
  ...
  610  }`}</code></pre>
  611  <p classname="pit">no es accesible desde fuera del bloque de código. Esto puede ser confuso para los desarrolladores que están acostumbrados a que el estilo y son nuevos en JavaScript. Debido Javascript ámbito de la función de forma exclusiva, las variables declaradas en un bloque se puede acceder en cualquier punto de la función. Esto también puede ser una pesadilla para los desarrolladores de JavaScript, pero hay maneras de superarlo. Veamos el problema que nos ocupa:</p>
  612: <p className="p">isn’t accessible from outside the code block. This can be confusing for developers who are accustomed to that style and are new to JavaScript. Because JavaScript has func- tion scope exclusively, any variables declared in a block are accessible at any point in the function. This can also be a nightmare for JavaScript developers, but there are ways to overcome it. Let’s look at the problem at hand:</p>
  613  <pre><code>{`function doWork() { if (!myVar) { var myVar = 10;
  614  }
  ...
  616  }
  617  doWork();`}</code></pre>
  618: <p classname="pit">El miVar variable se declara en la sentencia if, pero es visible desde el exterior del bloque. Curiosamente, la ejecución de este código imprime el valor de 10. Esto puede ser baf- aventura, especialmente para los desarrolladores que se utilizan para el alcance a nivel de bloque más común. Un mecanismo de JavaScript nal inter- iza declaraciones de variables y función a la parte superior del alcance-el ámbito de la función actual, en este caso. Esto puede hacer que la escritura bucles en malas condiciones; prestar atención a la siguiente lista.</p>
  619: <p className="p">The variable myVar is declared in the if statement, but it’s visible from outside the block. Strangely enough, running this code prints out the value 10. This can be baf- fling, especially for developers used to the more common block-level scope. An inter- nal JavaScript mechanism hoists variable and function declarations to the top of the current scope—the function scope, in this case. This can make writing loops unsafe; pay attention to the following listing.</p>
  620  <p classname="pit">Añadir 2,4 problema loop-counter Ambiguous:</p>
  621  <p className="p">Listing 2.4 Ambiguous loop-counter problem:</p>
  ...
  633  <p className="pag">Page 50</p>
  634  <p classname="pit">El contador de bucles i se mueve a la parte superior de la función y se convierte en parte del cierre de la función multipleBy10. El olvido de utilizar la palabra clave var en la declaración de i no puede crear una variable de ámbito local en multiplyBy y accidentalmente modifica el contador del bucle a 10. La declaración de bucle de venta libre se iza, en undefined, y más tarde le asigna el valor 0 cuando el bucle es correr. En el capítulo 8, verá una recurrencia de este problema de la ambigüedad que se produce con el cálculo de operaciones de no bloqueo en bucles.</p>
  635: <p className="p">The loop counter i is moved to the top of the function and becomes part of the multipleBy10 function’s closure. Forgetting to use the keyword var in i’s declaration fails to create a locally scoped variable in multiplyBy and accidentally modifies the loop counter to 10. The loop-counter declaration is hoisted, set to undefined, and then later assigned the value 0 when the loop is run. In chapter 8, you’ll see a recur- rence of this ambiguity problem that occurs with computing nonblocking operations in loops.</p>
  636  <p classname="pit">Buenos entornos de desarrollo y borra de puede ayudar a mitigar estos problemas, pero incluso ellos no son de mucha ayuda en la cara de cientos de líneas de código. En el siguiente capítulo, vamos a ver mejores soluciones que sean propensos a errores que los bucles estándar más elegante y menos: las técnicas que aprovechan al máximo las funciones de orden superior y ayuda a mitigar estos pit-caídas. Como hemos visto a lo largo de este capítulo, ES6 JavaScript proporciona la palabra clave let para ayudar a resolver esta ambigüedad bucle de venta libre por la unión adecuadamente el contador del bucle a su bloque que lo contiene:</p>
  637: <p className="p">Good IDEs and linters can help mitigate these issues, but even they aren’t much help in the face of hundreds of lines of code. In the next chapter, we’ll look at better solutions that are both more elegant and less error-prone than standard loops: tech- niques that take full advantage of higher-order functions and help mitigate these pit- falls. As you’ve seen throughout this chapter, ES6 JavaScript provides the let keyword to help resolve this loop-counter ambiguity by properly binding the loop counter to its enclosing block:</p>
  638  <p classname="pit">Este es un paso en la dirección correcta, y la razón por la que prefiero usar let de var en variables de ámbito acotado, pero bucles manuales tener otros defectos que vamos a REM Edy en el siguiente capítulo. Ahora que usted entiende lo que constituye el cierre de una función y su interacción con la mecánica de alcance, pasemos a algunos usos prácticos de los cierres.</p>
  639: <p className="p">This is a step in the right direction, and the reason why I prefer using let than var in scope-bounded variables, but manual loops have other shortcomings that we’ll rem- edy in the next chapter. Now that you understand what makes up a function’s closure and its interplay with scope mechanics, let’s turn to some practical uses of closures.</p>
  640  <h2>2.4.4	Practical applications of closures</h2>
  641: <p classname="pit">Los cierres tienen muchas aplicaciones prácticas que son importantes para aplicar cuando imple- Menting programas grandes de JavaScript. Estos no son específicos de la programación funcional, pero sí tomar ventaja mecanismo de la función de ofJavaScript:</p>
  642: <p className="p">Closures have many practical applications that are important to apply when imple- menting large JavaScript programs. These aren’t specific to functional programming, but they do take advantage ofJavaScript’s function mechanism:</p>
  643  <li classname="littag">	Emulando las variables privadas</li>
  644  <li className="litag">	Emulating private variables</li>
  ...
  653   
  654  <p className="pag">Page 51</p>
  655: <p classname="pit">El uso de cierres, sin embargo, es posible emular este comportamiento. Un ejemplo devuelve un objeto, al igual Código postal y coordinar en el ejemplo anterior. Estas funciones devuelven objetos literales con métodos que tienen acceso a ninguna de las variables locales de la fun- ción externa, pero que no exponen estas variables, por lo tanto haciendo efectivamente privado.</p>
  656: <p className="p">Using closures, however, it’s possible to emulate this behavior. One example is returning an object, much like zipCode and coordinate in the earlier example. These functions return object literals with methods that have access to any of the outer func- tion’s local variables, but don’t expose these variables, therefore effectively making them private.</p>
  657  <p classname="pit">Los cierres también pueden proporcionar una forma de gestionar el espacio de nombres global para evitar que los datos compartidos a nivel mundial. autores biblioteca y módulos llevan cierres a un nivel superior al ocultar los métodos y los datos privados de un módulo entero. Esto se conoce como el patrón del módulo, ya que utiliza una única expresión de la función invocada inmediatamente (IIFE) para encapsular las variables internas mientras que le permite exportar el conjunto necesario de funcionalidad con el mundo exterior y reducir severamente el número de referencias globales.</p>
  658  <p className="p">Closures can also provide a way to manage your global namespace to avoid globally shared data. Library and module authors take closures to the next level by hiding an entire module’s private methods and data. This is referred to as the Module pattern because it uses a single immediately invoked function expression (IIFE) to encapsulate internal variables while allowing you to export the necessary set of functionality to the outside world and severely reduce the number of global references.</p>
  659: <p classname="pit">NOTA Como una mejor práctica general, recomiendo el envasado de todo su código fun- cional dentro de módulos bien encapsulado. Puede transferir todos los principios básicos de la programación funcional que ha aprendido en este libro con el nivel de los módulos.</p>
  660: <p className="p">NOTE As a general best practice, I recommend packaging all of your func- tional code inside well-encapsulated modules. You can transfer all the core principles of functional programming you’ve learned in this book to the level of modules.</p>
  661  <p classname="pit">He aquí una pequeña muestra de un esqueleto de un módulo: 3</p>
  662  <p className="p">Here’s a short sample of a module skeleton:3</p>
  663  <p classname="pit">El MyModule objeto se crea a nivel mundial y se pasa a una expresión de función, creada con la palabra clave function, e inmediatamente se ejecuta cuando se carga el guión. Debido al ámbito de la función de JavaScript, _myPrivateVar y cualesquiera otras variables privadas son locales de la función de envoltura. El cierre que rodea los dos métodos exportados es lo que permite que el objeto para acceder de forma segura todas las propiedades internas del módulo. Esta es convincente, ya que mantiene su baja huella mundial, mientras que la exposición de un objeto con</p>
  664: <p className="p">The object MyModule is created globally and passed into a function expression, cre- ated with the function keyword, and immediately executed when the script is loaded. Due to JavaScript’s function scope, _myPrivateVar and any other private variables are local to the wrapping function. The closure surrounding the two exported methods is what allows the object to safely access all of the module’s internal properties. This is compelling because it keeps your global footprint low while exposing an object with</p>
  665  
  666: <p className="ind">Index 3 - For a more in-depth explanation of the different types of module patterns, see Ben Cherry’s “JavaScript Mod- ule Pattern: In-Depth,” Adequately Good, March 12, 2010, http://mng.bz/H9hk.</p>
  667   
  668  <p className="pag">Page 52</p>
  ...
  673  <p classname="pit">de primera clase de JavaScript, funciones de orden superior se puede pasar a otras funciones como las devoluciones de llamada. Devoluciones de llamada son útiles como ganchos para controlar los eventos de una manera discreta. Supongamos que se necesita para hacer una petición al servidor y desea ser notificado una vez que los datos han sido recibidos. El lenguaje tradicional es el de proporcionar una función de devolución de llamada que se encargará de la respuesta: </p>
  674  <p className="p">JavaScript’s first-class, higher-order functions can be passed into other functions as callbacks. Callbacks are useful as hooks to handle events in an unobtrusive manner. Suppose you need to make a request to the server and want to be notified once the data has been received. The traditional idiom is to provide a callback function that will handle the response:</p>
  675: <p classname="pit">getJSON es una función de orden superior que toma dos argumentos: devoluciones de llamada como una función de éxito y una función de error. Un patrón común que se produce con un código asíncrono, así como el manejo de eventos es que se puede acaparar fácilmente a sí mismo en las llamadas a funciones anidadas; esta forma la desagradable “pirámide de devolución de llamada de la fatalidad” cuando es necesario hacer varias llamadas remotas posteriores al servidor. Como probablemente experimenté, cuando el código está profundamente anidado, se hace difícil de seguir. En el capítulo 8, aprenderá las mejores prácticas de cómo alisar básicamente este código en expresiones tivos más fluidos y declara- esa cadena juntos en lugar de anidamiento. </p>
  676: <p className="p">getJSON is a higher-order function that takes two callbacks as arguments: a success function and an error function. A common pattern that occurs with asynchronous code as well as event handling is that you can easily corner yourself into deeply nested function calls; this forms the unpleasant “callback pyramid of doom” when you need to make several subsequent remote calls to the server. As you’ve probably experi- enced, when code is deeply nested, it becomes hard to follow. In chapter 8, you’ll learn best practices for how to basically flatten this code into more fluent and declara- tive expressions that chain together instead of nesting.</p>
  677  <p classname="pit">Emulando VARIABLES-SCOPE BLOQUEADO </p>
  678  <p className="p">EMULATING BLOCKED-SCOPE VARIABLES</p>
  679  <p classname="pit">El uso de cierres puede proporcionar una solución alternativa a la ambigua variabilidad loop-counter ejemplo capaz en el listado 2.4. Como he mencionado anteriormente, la cuestión de fondo es la falta de semántica bloque de alcance de JavaScript, por lo que el objetivo es crear artificialmente este ámbito de bloque. ¿Qué se puede hacer al respecto? El uso de let mitiga muchos de los problemas con el mecanismo de bucle tradición cional, pero un enfoque funcional sería tomar ventaja de los cierres y el alcance de la función JavaScript y considerar el uso forEach. Ahora, en lugar de preocuparse por atar el contador de bucles y otras variables en su alcance, se puede envolver con eficacia el cuerpo del bucle dentro del bucle como si la emulación de un bloque de función alcance bajo la sentencia de bucle. Como veremos más adelante, esto ayuda a que llame comportamiento asincrónico, mientras que la iteración en las colecciones: </p>
  680: <p className="p">Using closures can provide an alternative solution to the ambiguous loop-counter vari- able example in listing 2.4. As I mentioned earlier, the underlying issue is JavaScript’s lack of block-scope semantics, so the objective is to artificially create this block scope. What can you do about this? Using let mitigates many of the issues with the tradi- tional looping mechanism, but a functional approach would be to take advantage of closures and JavaScript’s function scope and consider using forEach. Now, instead of worrying about tying the loop counter and other variables in scope, you can effectively wrap the loop body inside the loop as if emulating a function-scope block under the loop statement. As you’ll learn later, this helps you call asynchronous behavior while iterating over collections:</p>
  681  <pre><code>{`
  682  arr.forEach(function(elem, i) {
  ...
  700  <li classname="littag">	funciones de orden superior y de primera clase de JavaScript constituyen la columna vertebral que permite JavaScript para escribir funcionalmente.</li>
  701  <li className="litag">	Higher-order and first-class JavaScript functions provide the backbone that allows JavaScript to be written functionally.</li>
  702: <li classname="littag">	Los cierres tienen muchos usos prácticos para la ocultación de información, el módulo de Desa- ción, y pasando el comportamiento parametrizado en funciones de grano grueso a través de múltiples tipos de datos.</li>
  703: <li className="litag">	Closures have many practical uses for information hiding, module develop- ment, and passing parameterized behavior into coarse-grained functions across multiple data types.</li></ul>
  704  
  705  </div>            

C:\Users\Emanuela\FunctionalP\pages\Chapter 3.js:
    1: Chapter 3 - Few data structures, many operations
    2  This chapter covers
    3  <li className="litag">	Understanding program control and flow</li>
    .
   12  
   13  <p className="pag">Page 58</p>
   14: In this chapter, I’il introduce you to a few useful and practical operations like map, reduce, and filter that allow you to traverse and transform data structures in a sequential manner. These operations are so important that virtually all functional pro- grams use them in one way or another. They also facilitate removing manual loops from your code, because most loops are just specific cases handled by these functions.
   15: You’ll also learn to use a functional JavaScript library called Lodash.js. It lets you process and understand not only the structure of your application, but also the struc- ture of your data. In addition, I’ll discuss the important role recursion plays in func- tional programming and the advantages of being able to think recursively. Building on these concepts, you’ll learn to write concise, extensible, and declarative programs that clearly separate control flow from the main logic of your code.
   16  3.1	Understanding your application’s control flow
   17: The path a program takes to arrive at a solution is known as its control flow. An impera- tive program describes its flow or path in great detail by exposing all the necessary steps needed to fulfill its task. These steps usually involve lots of loops and branches, as well as variables that change with each statement. At a high level, you can depict a simple imperative program like this:
   18  <pre>
   19  var loop = optC(); while(loop) {
   ..
   30  Figure 3.1 An imperative program made up of a series of operations (or statements) controlled by branches and loops
   31  <p className="pag">Page 59</p>
   32: On the other hand, declarative programs, specifically functional ones, raise the level of abstraction by using a minimally structured flow made up of independent black- box operations that connect in a simple topology. These connected operations are nothing more than higher-order functions that move state from one operation to the next, as shown in figure 3.2. Working functionally with data structures such as arrays lends itself to this style of development and treats data and control flow as simple con- nections between high-level components.
   33  Chaining operations in this manner leads to concise, fluent, expressive programs that let you separate a program’s control flow from its computational logic. Thus, you can reason about your code and your data more effectively.
   34  3.2	Method chaining
   35: Method chaining is an OOP pattern that allows multiple methods to be called in a single statement. When these methods all belong to the same object, method chaining is referred to as method cascading. Although this pattern is seen mostly in object-oriented applications, under certain condi tions, such as working with immutable objects, it works just as well with functional programming. Because mutation of objects is pro- hibited in functional code, you may wonder how this is possible. Let’s look at a string- manipulation example:
   36  <pre>
   37  'Functional Programming'.substring(0, 10).toLowerCase() + ' is fun';
   38  </pre>
   39: In this example, both substring and toLowerCase are string methods that operate on the owning string object (via this) and return new strings. The plus (+) operator is overloaded in JavaScript strings as syntactic sugar for concatenation—also producing a new string. The result of applying these transformations is a string that bears no ref- erence to the original, which remains untouched; this is to be expected, because
   40   
   41  <p className="pag">Page 60</p>
   ..
   43  If you refactor the previous code into a more functional style, it looks like this:
   44  concat(toLowerCase(substring('Functional Programming', 1, 10))),' is fun');
   45: This code follows the functional doctrine that all parameters should be explicitly defined in the function declaration; it has no side effects and doesn’t mutate the orig- inal object. Arguably, writing this function inside out isn’t as fluent as the method- chaining approach. It’s also much harder to read, because you need to start peeling off the wrapped functions to understand what’s truly happening.
   46  Chaining methods belonging to a single object instance has its place in functional programming, as long as you respect the policy for change. Wouldn’t it be nice to translate this pattern to work with arrays as well? The behavior we see in strings has also been extended to work with JavaScript arrays, but most people aren’t familiar with it and resort to quick-and-dirty for loops.
   47  3.3	Function chaining
   48: Object-oriented programs use inheritance as the main mechanism for code reuse. Recall from the previous chapter that Student inherits from Person, and that all state and methods are inherited by the child type. You may have seen this pattern predomi- nantly in purer object-oriented languages, especially in their data structure implemen- tations. Java, for instance, has an explosion of concrete List classes for each need: ArrayList, LinkedList, DoublyLinkedList, CopyOnWriteArrayList, and others imple- ment the basic List interface and derive from common parent classes, adding their own specific functionality.
   49: Functional programming takes a different approach. Instead of creating new data structure classes to meet specific needs, it uses common ones like arrays and applies a number of coarse-grained, higher-order operations that are agnostic to the underly- ing representation of the data. These operations are designed to do the following:
   50  <li className="litag">	Accept function arguments in order to inject specialized behavior that solves your particular task</li>
   51  <li className="litag">	Replace the traditional, manual looping mechanisms that contain mutations of temporary variables and side effects, thereby creating less code to maintain and fewer places where errors can occur</li>
   ..
   61  <p className="pag">Page 61</p>
   62  3.3.1	Understanding lambda expressions
   63: Born from functional programming, lambda expressions (known as fat-arrow functions in the JavaScript world) encode one-line anonymous functions into a shorter syntax, compared to a traditional function declaration. You can have lambda functions with multiple lines, but one-liners are the most commonly used, as you saw in chapter 2. Whether you use lambdas or regular function syntax will depend on the readability of your code; under the hood, they’re all the same. Here’s a simple example of a func- tion used to extract a person’s name:
   64  <pre>const name = p => p.fullname;
   65  console.log(name(p1)); //-> 'Haskell Curry'</pre>
   ..
   67   
   68  <p className="pag">Page 62</p>
   69: Lambda expressions uphold the functional defìnition of a function because they encourage you to always return a value. In fact, for one-line expressions, the return value results from the value of the function body. Another point worth noting here is the relationship between first-class functions and lambdas. In this case, name points not to a concrete value, but (lazily) to a description of how to obtain it; in other words, name points to an arrow function that knows how to compute this data. This is why, in functional programming, you can use functions as values. I’ll discuss this concept fur- ther in this chapter and lazy functions in chapter 7.
   70: Furthermore, functional programming promotes the use of three central higher- order functions—map, reduce, and filter—that are designed to work well with lambda expressions. A lot of functional JavaScript code is based on processing lists of data; hence, the name of the original functional language, LISP (list processing), from which JavaScript is derived. JavaScript 5.1 provides native versions of these operations known as the functional array extras; but in order to create complete solutions that may involve other similar types of operations, I’ll use the implementations provided in a functional library called Lodash.js. Its toolkit provides important artifacts that empower you to write functional programs, and it contains a rich repertoire of utility functions that handle many common programming tasks (see the appendix for details on how to install this library). Once it’s installed, you can access its functionality via the global _ (underscore or low-dash) object. Let’s get started with _.map.
   71  The underscore in Lodash
   72: Lodash uses the underscore convention because it began as a fork of the famous and widely used Undesrscore.js project (http://underscorejs.org/). Lodash stili tracks Underscore's API closely, to the point that it can serve as a drop-in replacement. But behind the scenes, it's a complete rewrite in favor of more elegant ways to build func- tion chains, as well as some performance enhancements that you'll learn about in chapter 7.
   73  3.3.2	Transforming data with _.map
   74  Suppose you need to transform all the elements in a large collection of data. For instance, given a list of student objects, you want to extract each person’s full name. How many times have you had to write this sequence of statements?
   75   
   76  <p className="pag">Page 63</p>
   77: map (also known as collect) is a higher-order function that applies an iterator func- tion to each element in an array, in order, and returns a new array of equal length. Here’s the same program, this time using a functional style with _.map:
   78  A formal definition of this operation is as follows:
   79  map(f, [e0, e1, e2...]) -> [r0, r1, r2...]; where, f(dn) = rn
   80: map is extremely useful for parsing through entire collections of elements without having to write a single loop or deal with odd scoping problems. Also, it’s immutable, because the result is an entirely new array. map works by taking a function f and a col- lection of n elements as input; it returns a new array of size n with elements com- puted from applying f to each element in a left-to-right manner. This is depicted in figure 3.4.
   81  This example of _.map iterates over an array of student objects and extracts their names. You use a lambda expression as the iterator function (which is common). This doesn’t change the original array but, rather, returns a new one that contains the following:
   82  <pre>
   ..
   89  <p className="pag">Page 64</p>
   90  Listing 3.1 Map implementation
   91: As you can see, internally, _.map is based on standard loops. This function handles iteration on your behalf, so you’re only responsible for administering the proper func- tionality in the iterator function instead of having to worry about mundane concerns like incrementing loop variables and bounds checks. This is an example of how func- tional libraries bring your code to the same level as purer functional languages.
   92: map is exclusively a left-to-right operation; for a right-to-left sweep, you must first reverse the array. JavaScript’s Array.reverse() operation won’t work, because it mutates the original array in place, but a functional equivalent of reverse can be con- nected with map in a single statement:
   93  <pre>
   94  _(persons).reverse().map(
   ..
  103  3.3.3	Gathering results with _.reduce
  104  You know how to transform your data, but how do you gather meaningful results from it? Suppose you want to compute the country with the largest count from a collection of Person objects. You can use the reduce function to accomplish this.
  105: reduce is a higher-order function that compresses an array of elements down to a single value. This value is computed from the accumulated result of invoking a func- tion with an accumulator value against each element. This is easier to visualize by looking at the diagram in figure 3.5.
  106  This diagram can be expressed more formally with the following notation:
  107  <pre>reduce(f,[e0, e1, e2, e3],accum) -> f(f(f(f(acc, e0), e1, e2, e3)))) -> R</pre>
  ...
  117  Let’s write a simple program that gathers some statistics about a set of Person objects. Suppose you want find the number of people who live in a particular country; see the following listing.
  118  Listing 3.3 Computing country counts
  119: Running this code converts the input array into a single object containing a represen- tation of the population by country:
  120  <pre>
  121  {
  ...
  125  }
  126  </pre>
  127: To simplify this task further, you can implement the ubiquitous map-reduce combina- tion. Linking these functions, you can enhance the behavior of map and reduce by providing specialized behaviors as parameters. At a high level, this program’s flow has the structure
  128  _(persons).map(func1).reduce(func2);
  129  where func1 and func2 implement the particular behavior you want. Separating the functions from the main flow, you get the code in the next listing.
  ...
  138  <p className="pag">Page 67</p>
  139  _(persons).map(getCountry).reduce(gatherStats/ {});
  140: Listing 3.4 uses map to preprocess the array of objects and extract all countries; then it uses reduce to collect the final result. This produces the same output as listing 3.3, but in a much cleaner and extensible way. Instead of direct property access, consider pro- viding a lens (using Ramda) that focuses on the person’s address.city property:
  141  <pre>
  142  const cityPath = ['address','city'];
  ...
  149  Alternatively, you can use _.groupBy to accomplish a similar outcome in an even more succinct way:
  150  <pre>_.groupBy(persons, R.view(cityLens));</pre>
  151: Unlike map, because reduce relies on an accumulated result, it can behave differ- ently when applied left-to-right or right-to-left if not provided with a commutative operation. To illustrate this, consider a simple program that sums up the numbers in an array:
  152  <pre>_([0,1,3/4/5]).reduce(_.add);	//-> 13</pre>
  153  The same result can be obtained by reducing in reverse with _.reduceRight. This works as expected because addition is a commutative operation, but it can produce significantly different results for operations that aren’t, like division. Using the same notation as before, _.reduceRight can be viewed as follows:
  ...
  155  For instance, these two programs using _.divide will compute completely different values:
  156  <pre>([1,3,4,5]).reduce(_.divide)	!== ([1,3,4,5]).reduceRight(_.divide);</pre>
  157: Furthermore, reduce is an apply-to-all operation, which means there’s no way for it to be short-circuited so it doesn’t run through the entire array. Suppose you need to vali- date a list of input values. You could think of validating an array of parameters as reducing it to a single Boolean value, indicating whether all parameters are valid.
  158  <p className="pag">Page 68</p>
  159  Using reduce, however, would be a bit inefficient because you’d have to visit all values in the list. Once you’ve found an invalid input, there’s no point continuing to check all of them. Let’s look at a more efficient validation function that uses _.some and other functions you’ll come to know and love: _.isUndefined and _.isNull. When applied against each element in the list, _.some returns as soon as it finds a passing (true) value:
  ...
  163  As you saw earlier, both map and reduce attempt to traverse the entire array. Often, you aren’t interested in processing all elements in your data structure and would like to skip any null or undefined objects. It would be nice if you had a mechanism to remove or filter out certain elements from the list before the computation takes place. Let’s visit _.filter next.
  164  3.3.4	Removing unwanted elements with _.filter
  165: When processing large collections of data, it’s often necessary to remove elements that don’t form part of your computations. For instance, say you want to count only people living in European countries, or people born in a certain year. Instead of clut- tering your code with if-else statements, you can use _.filter.
  166  filter (also known as select) is a higher-order function that iterates through an array of elements and returns a new array that’s a subset of the original with values for which a predicate function p returns a result of true. In formal notation, this looks like the following (also see figure 3.6):
  167  <pre>filter(p, [d0, d1, d2, d3...dn]) -> [d0,d1,...dn] (subset of original input)</pre>
  ...
  180  <p className="pag">Page 70</p>
  181  Array comprehension
  182: map and filter are higher-order functions that return new arrays from existing ones. They exist in many functional programming languages like Haskell, Clojure, and others. An alternative to combining map and filter is to use a concept called array compre- hension, also known as list comprehension. It's a functional feature that encapsu- lates the functionality of map and filter into a concise syntax using the for...of and if keywords, respectively:
  183  [for (x of iterable) if (condition) x]
  184: At the time of this writing, there's a proposal in ECMAScript 7 to include array com- prehensions. They'll let you create concise expressions to assemble new arrays (which is why the entire expression is wrapped in [] ). For example, you can refactor the previous code in the following manner:
  185  [for (p of people) if (p.birthYear ===	1903) p.fullname]
  186  .join(' and ');
  187: Applying all of these techniques based on these extensible and powerful functions allows you not only to write cleaner code but also to improve your understanding of the data. Using the declarative style, you can focus on what the output of the appli- cation will be instead of how to get there, facilitating deeper reasoning in your application.
  188  3.4	Reasoning about your code
  189  Recall that, in JavaScript, thousands of lines of code that share a global namespace can be loaded into a single page at once. Lately there’s lots of interest in creating modules to compartmentalize business logic, but thousands of projects in production still don’t do this.
  190: What does it mean to “reason about your code”? I’ve used this term loosely in pre- vious chapters to refer to the ability to look into any part of a program and easily build a mental model of what’s happening. This model includes dynamic parts like the state of all variables and the outcomes of functions, as well as static parts such as the level of readability and expressiveness of your design. Both are important. You’ll learn in this book that immutability and pure functions make building this model much easier.
  191: Earlier, I highlighted the value of being able to link high-level operations together to build programs. An imperative program flow is radically different from a functional program flow. A functional flow gives you a clear picture as to the purpose of the pro- gram without revealing any of its internal details, so that you can reason more deeply about the code as well as how data flows into and out of the different stages to pro- duce results.
  192  <p className="pag">Page 71</p>
  193  3.4.1	Declarative and lazy function chains
  194: Recali from chapter 1 that functional programs are made up of simple functions that in themselves don’t accomplish much but, when put together, can solve com- plex tasks. In this section, you’ll learn a way to build entire an program by linking a set of functions.
  195: Functional programming’s declarative model treats programs as the evaluation of independent, pure functions, which support you in building the necessary abstrac- tions to gain fluency and expressiveness in your code. Doing so, you can form an ontology or vocabulary that clearly expresses the intent of your application. Building pure functions on top of the building blocks of map, reduce, and filter leads to writ- ing in a style that makes code easy to reason about and understand at a glance.
  196: The powerful effect of raising this level of abstraction is that you begin to think of operations as agnostic to the underlying data structures used. Theoretically speaking, whether you’re working with arrays, linked lists, binary trees, or otherwise, it shouldn’t change the semantic meaning of your program. For this reason, functional program- ming focuses on operations more than on the structure of the data.
  197  For example, suppose you’re tasked to read a list of names, normalize them, remove any duplicates, and sort the final result. First, let’s write an imperative version of this program; later you’ll refactor it into a functional style.
  198  You can express the list of names as an array with unevenly formatted input strings:
  ...
  205  This code produces the desired output:
  206  <pre>['Alonzo Church', 'Haskell Curry', 'Jon Von Neumann', 'Stephen Kleene']</pre>
  207: The downside of imperative code is that it’s targeted at solving a particular problem efficiently. The code in listing 3.6 can only be used to perform this particular task. Therefore, it runs at a far lower level of abstraction than functional code. The lower the level of abstraction, the lower the probability of reuse, and the greater the com- plexity and likelihood of errors.
  208: On the other hand, the functional implementation merely connects black-box componente together and cedes the responsibility to these well-established and tested APIs, as shown in the following listing. Notice how the cascade arrangement of func- tion calls makes this code easier to read.
  209  Listing 3.7 Performing sequential operations on arrays (functional approach)
  210  The _.filter and _.map functions take care of all the heavy lifting of ite rating through valid indexes in the names array. Your only job is to supply the specialized behavior in the remaining steps. You use the _.uniq function to throw away duplicate entries and _.startCase to capitalize each word; finally, you sort all the results.
  211: I’d much rather write and read programs that look like listing 3.7, wouldn’t you? Notjust because of the sheer reduction in the amount of code, but also due to its sim- ple and clear structure.
  212: Let’s continue exploring Lodash. This example revisits listing 3.4, which computes counts of all countries from an array of Person objects. For the purpose of this exam- ple, augment the gatherStats function slightly:
  213  <pre>const gatherStats = function (stat, country) { if(!isValid(stat[country])) {
  214  stat[country] = {'name': country, 'count': 0};
  ...
  229  The next task is to build a program that returns the country with the largest number of people in this dataset. Let’s do this again by linking a function with the help of .chain() and a few other artifacts.
  230  Listing 3.8 Demonstrating lazy function chains with Lodash
  231: The _.chain function can be used to augment the state of an input object by connect- ing operations that transform the input into the desired output. It’s powerful because, unlike wrapping arrays with the shorthand _(...) object, it explicitly makes any func- tion in the sequence chainable. Despite this being a complex program, you can avoid creating any variables, and all looping is effectively eliminated.
  232  Another benefit of using _.chain is that you can create complex programs that behave lazily, so nothing executes until that last value() function is called. This can have a tremendous impact in your application because you can potentially skip running
  233   
  ...
  235  Figure 3.7 Control of a program built using Lodash function chains. The array of person objects is processed through a series of operations. Along the way, the data flows and is finally transformed into a single value.
  236  entire functions when their results aren’t needed (lazy evaluation will be discussed in chapter 7). This program’s control flow is depicted in figure 3.7.
  237: You’re beginning to see why functional programs are superior. The imperative version of this task, I’ll leave to your imagination. The reason listing 3.8 works so smoothly relates to the fundamental principles underlying FP—pure and side effect- free functions. Each function in the chain immutably operates on new arrays built from functions that precede it. By starting with a call to _.chain(), Lodash capitalizes on this pattern to provide a Swiss Army knife of utilities to satisfy most needs. This helps you transition into a style of programming called point-free, it’s unique to func- tional programming, and I’ll introduce it in the next chapter.
  238  Being able to lazily define program pipelines has many more benefits than just readability. Because lazy programs are defined before they’re evaluated, they can be optimized using techniques such as data-structure reuse and method fusion. These optimizations don’t reduce the time it takes to execute functions per se; rather, they help to eliminate unnecessary invocations. I’ll discuss this in more detail in chapter 7 when we study the performance of functional programs.
  239  In listing 3.8, data is flowing from one node to the next in the network. Using higher-order functions declaratively makes it obvious how data transforms in each node, revealing more insights about your data.
  ...
  242  3.4.2	SQL-like data: functions as data
  243  Throughout this chapter, you’ve been exposed to an assortment of functions such as map, reduce, filter, groupBy, sortBy, uniq, and so on. The vocabulary formed around these functions can be used to clearly extrapolate information pertaining to your data. If you think outside the box for a second, you’ll notice that these functions resemble SQL, which isn’t accidental.
  244: Developers are accustomed to using SQL and its features to understand and extrapolate meaning from data. For example, you can represent the collection’s per- son objects as shown in table 3.1.
  245  Table 3.1 Representing the data in the person list as a table
  246: As it turns out, thinking in terms of a query language when building programs is simi- lar to the operations applied to arrays in functional programming, which make use of a common vocabulary or algebra, if you will, to encourage a deeper reasoning about the nature of your data and how it’s structured. The following SQL query
  247  <pre>SELECT p.firstname, p.birthYear FROM Person p WHERE p.birthYear > 1903 and p.country IS NOT 'US'
  248  GROUP BY p.firstname, p.birthYear</pre>
  249: makes it crystal clear what you should expect your data to look like after running this code. Before you implement the JavaScript version of this program, let’s implement a few function aliases to help me make this point. Lodash supports a feature called mix- ins that can be used to extend the core library with additional functions and have them chained the same way:
  250  <pre>_.mixin({'select':	_.pluck,
  251  'from':	_.chain,
  ...
  263  Listing 3.9 creates aliases that map native SQL keywords to corresponding functions, so you may experience a closer realization of functional code to a query language.
  264  JavaScript mixins
  265: A mixin is an object that defines an abstract subset of functions relating to a partic- ular type (in this case, a SQL command). This object isn't concretely used in code, other than to extend the behavior of another object (it's somewhat similar to a trait in other programming languages). The target object borrows all of functionality from the mixin.
  266: In the object-oriented world, it's also another way to reuse code without having to use inheritance or to simulate multiple inheritance in languages that don't support it (JavaScript being one of them). I won't cover mixins in this book, but they can be pow- erful when used correctly. If you want to learn more about mixins, I suggest reading https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript- mixins/.
  267: You should be convinced by now that functional programming can behave as a power- ful abstraction over imperative code. What better way of processing and parsing your data than to use query language semantics? Like SQL, this JavaScript code models the data in the form of functions, also known as functions as data. Because it’s declarative, it describes what the data output is and not how it came to be. So far, I haven’t needed any conventional looping statements in this chapter—and I don’t intend to use them for the rest of the book. Instead, high-level abstractions replace looping.
  268  Another technique commonly used to replace loops is recursion, which you can use to abstract iteration when tackling problems that are “self-similar” in nature. For these types of problems, sequential function chains are inefficient and inadequate. Recursion, on the other hand, implements its own ways of processing data by yielding the heavy lifting of standard looping to the language runtime.
  269  <p className="pag">Page 77</p>
  270  3.5	Learning to think recursively
  271  Sometimes a problem is difficult and complex to tackle head on. When this occurs, you should immediately look for ways to decompose it. If the problem can be broken down into smaller versions of itself, you may be able to solve the smaller version and build it up to solve the entire problem. Recursion is essential for array traversal in pure functional programming languages like Haskell, Scheme, and Erlang because they don’t have looping constructs.
  272: In JavaScript, recursion has many applications, such as parsing XML or HTML doc- umento, graphs, and so on. In this section, I’ll explain what recursion is and then work through an exercise that will teach you how think recursively. Then we’ll take a quick look at a few data structures you can parse through using recursion.
  273  3.5.1	What is recursion?
  274  Recursion is a technique designed to solve problems by decomposing them into smaller, self-similar problems that, when combined, arrive at the original solution. A recursive function has two main parte:
  275  <li className="litag">	Base cases (also known as the terminating condition)</li>
  276  <li className="litag">	Recursive cases</li>
  277: The base cases are a set of inputs for which a recursive function computes a concrete result, without having to recur. The recursive case deals with a set of inputs (necessar- ily smaller than the original) for which the function calls itself. If the input isn’t smaller, the recursion runs indefinitely until the program crashes. As the function recurs, the nature of the inputs unconditionally become smaller, finally reaching the instance for which the base case is triggered and the process terminates with a value.
  278  Recall from chapter 2 that we used recursion to deep-freeze an entire nested object structure. The base case triggered when the object encountered was a primitive or had already been frozen; otherwise, the recursive step continued traversing the object structure as it found more unfrozen objects. Recursion was appropriate for this because at each level, the task to solve was exactly the same. Thinking recursively, though, can be a challenge, so let’s begin there.
  279  3.5.2	Learning to think recursively
  280: Recursion isn’t a simple concept to grasp. As with functional programming, the hard- est part is unlearning conventional ways. The focus of this book is not to make you a master of recursion, and it’s not a technique you’ll use often; but it’s important, and I’d like to exercise your brain and help you learn to analyze recursive problems better.
  281: Recursive thinking takes itself or a modified version of itself into consideration. A recursive object is self-defining; for instance, think of the composition of branches in a tree. A branch has leaves as well as other branches, which in turn have more leaves and more branches. This process continues indefinitely and is halted only by a limit- ing external factor—the size of the tree, in this case.
  282  <p className="pag">Page 78</p>
  283: With that in mind, let’s do a warm-up exercise by tackling a simple problemi add- ing all the numbers in an array. We’ll go from an imperative implementation to the most functional. The imperative side of your brain naturally visualizes a solution involving iterating through the array and keeping an accumulated value:
  284  <pre>var acc = 0;
  285  for(let i = 0; i < nums.length; i++)	{
  ...
  292  = 1 + 2 + sum[3,4,5,6,7,8,9]
  293  = 1 + 2 + 3 + sum[4,5,6,7,8,9]</pre>
  294: Recursion and iteration are two sides of the same coin. In the absence of mutation, recursion offers a more expressive, powerful, and excellent alternative to iteration. In fact, pure functional languages don’t even have standard looping constructs like do, for, and while, since all looping is done recursively. Recursion also leads to code that’s easier to understand because it’s premised on repeating the same actions multi- ple times on smaller input. The recursive solution in the following listing uses the Lodash _.first and _.rest functions to access the first element of the array or all but the first, respectively.
  295  Listing 3.10 Performing recursive addition
  296   
  ...
  300  At this point, it’s naturai to think about the performance of recursion versus manual iteration. After all, compilers have become extremely smart at optimizing loops. ES6 JavaScript brings an optimization feature called tail-call optimization that can bring the performance of these two features closer together. Consider this slightly different implementation of sum:
  301   
  302: This version places the recursive call as the last step in the function body, or in tail posi- tion. We’ll explore the benefits of doing this further in chapter 7 when we look at func- tional optimizations.
  303  3.5.3 Recursively defined data structures
  304  You’re probably wondering about the names passed in to the person objects we’ve been using as sample data. Back in the 1900s, the mathematics community behind functional programming (lambda calculus, category theory, and so on) was vibrant.
  305  <p className="pag">Page 80</p>
  306: Much of the work published was based on joint ideas and theorems by leading univer- sities under the tutelage of professors like Alonzo Church. In fact, many mathemati- cians like Barkley Rosser, Alan Turing, and Stephen Kleene, among others, were doctoral studente of Church’s. They went on to have doctoral studente of their own. Figure 3.8 graphs this apprenticeship relationship (or a sliver of it).
  307   
  308  Figure 3.8 Influential mathematicians who contributed to the development of functional programming. The connected lines from parent to child nodes in the tree structure represent a “student of” relationship.
  ...
  320  }
  321  }</pre>
  322: The node’s main logic lies in the append method. Appending a child to a node sets the child’s parent reference to it and adds the input node to the list of children. You populate the tree by linking nodes to other child nodes in the following manner, start- ing with the root, church:
  323  <pre>church.append(rosser).append(turing).append(kleene);
  324  kleene.append(nelson).append(constable);
  325  rosser.append(mendelson).append(sacks);
  326  turing.append(gandy);</pre>
  327: Each node is in charge of wrapping a person object. The recursive algori thm per- forms a preorder traversal of the entire tree, beginning at the root and descending to all of its children. Due to its self-similar nature, traversing the tree from the root node is exactly like traversing it from any node: a recursive definition. For this, you use Tree.map, a higher-order function with semantics similar to Array.prototype.map, which accepts a function that’s evaluated against each node value. As you can see, regardless of the data structure used to model this data (a tree, in this case), the semantics of this function should remain the same. Essentially, any data type can be mapped over by preserving its structure. I’ll consider this notion of mapping structure preserving functions to types more formally in chapter 5.
  328  A preorder traversal of this tree has the following steps, starting with root:
  329  1	Display the data part of the root element
  ...
  336  The function Tree.map has two required inputs: the root node (which is basically the start of the tree) and the iterator function that transforms each node’s value:
  337  <pre>Tree.map(church, p => p.fullname);</pre>
  338: This traverses the tree in preorder and applies the given function to each node, pro- ducing the following:
  339  <pre>'Alonzo Church', 'Barkley Rosser', 'Elliot Mendelson', 'Gerald Sacks', 'Alan Turing', 'Robin Gandy', 'Stephen Kleene', 'Nels Nelson', 'Robert Constable'</pre>
  340: This idea of encapsulating data to control how it’s accessed is key to functional pro- gramming when working with immutability and side effect-free data types. I’ll expand on this idea further in chapter 5. Parsing data structures is one of the most fundamen- tal aspects of software and the bread and butter of functional programming. This chapter took a deeper dive into the functional style of development using JavaScript’s functional capabilities encoded in an extensible functional library called Lodash. This style favors a streamlined and flow-based model where high-level operations can be chained together as a sequence of steps, which contain the business logic needed to arrive at your result.
  341: It’s undeniable that writing flow-based code also benefits reusability and modu- larization, but I’ve only scratched the surface. I’ll take this idea of flow-based pro- gramming to the next level in chapter 4, where I’ll focus on constructing real function pipelines.
  342  3.6	Summary
  343  <li className="litag">	You can write extensible code with the higher-order functions map, reduce, and filter.</li>
  344  <li className="litag">	Lodash is a vehicle for data processing, creating programs via control chains where data flows and transformations are clearly demarcated.</li>
  345: <li className="litag">	Functional programming’s declarative style creates code that’s easier to rea- son about.</li>
  346: <li className="litag">	Mapping high-level abstractions to a SQL vocabulary reveals a deeper under- standing of your data.</li>
  347: <li className="litag">	Recursion solves self-similar problems and is required to parse through recur- sively defined data structures.</li>
  348  

C:\Users\Emanuela\FunctionalP\pages\Chapter 4 - Toward modular, reusable code.js:
    1: <p className="pag">Page 84 - Chapter 4 - Toward modular, reusable code</p>
    2  This chapter covers
    3  <li className="litag">	Comparing function chains and pipelines</li>
    .
    8  A complex system that works is invariably found to have evolved from a simple system that worked.
    9  —John Gall, The Systems Bible (General Systemantics Press, 2012)
   10: Modularity is one of the most important qualities of large software projects; it repre- sents the degree to which programs can be separated into smaller, independent parts. Modular programs posses the distinct quality that their meaning can be derived from the meaning of their constituent parts. These parts (or subprograms) become reusable components that can be incorporated as a whole or in pieces into
   11  
   12  <p className="pag">Page 85</p>
   13  other systems. This makes your code more maintainable and readable while making you more productive. As a simple use case, think of how Unix shell programs are written:
   14  tr 'A-Z'	'a-z' <words.in | uniq | sort
   15: Even if you have no experience with Unix programming, you can clearly see that this code involves a sequence of steps that transforms words from uppercase to lowercase, removes duplicates, and sorts the remainder. The pipe operator ( | in this case) con- nects these commands. It’s remarkable that by having clear contracts describing the inputs and outputs, small programs can be glued together to solve complex tasks. If you imagine having to write this program in traditional imperative JavaScript, a few loops, string comparisons, and perhaps a few conditional statements and global vari- ables keeping track of everything come to mind. This probably isn’t very modular, per se. In programming, we like to solve problems by breaking them into smaller pieces and reconstructing those pieces to form a solution.
   16  In chapter 3, we used high-level functions to solve similar types of issues using tightly coupled method chains that cascade over a single wrapper object. In this chapter, we’ll extend this idea further to create loosely coupled pipelines via functional composition, which will allow you to build whole programs from independent components with more flexibility. These components can be as small as functions or as big as entire modules that separately don’t provide much value but together give meaning to the whole.
   17: Creating modular code isn’t an easy task. We’ll look at important functional tech- niques like partial evaluation and composition, with the aid of a functional framework called Ramdajs, to bring code to the right level of abstraction in order to express solu- tions in a point-free manner via declarative function pipelines.
   18: 4.1 Method chains vs. function pipelines Chapter 3 left off with method chains used to connect a series of functions together, revealing a style of functional programming much different from any other develop- ment style. But there’s another approach for connecting functions, called pipelining.
   19: When studying functions, it’s useful to describe them in terms of their inputs and outputs. The notation used in Haskell, for example, is popular in the functional com- munity, and you’ll see it used in many places (see figure 4.1).
   20   
   21  <p className="pag">Page 86</p>
   22   
   23: Remember that, in functional programming, a function is a mathematical mapping between inputs and output types, as shown in figure 4.2. For instance, a simple func- tion like isEmpty that takes a string and returns a Boolean can be expressed in this notation as
   24  <pre>isEmpty :: String -> Boolean</pre>
   25  This function is a referentially transparent mapping between the set of all input values of type String and the set of all Boolean values. Here’s the JavaScript lambda form together with its function signature:
   ..
   32   
   33  <p className="pag">Page 87</p>
   34: This is clearly a syntactical improvement over imperative code and drastically improves its readability. Unfortunately, it’s contrived and tightly coupled to the owning object that confines the number of methods you can apply in the chain, which limits expres- siveness of the code. In this case, you’re obliged to use only the set of operations pro- vided by Lodash, and you wouldn’t be able to easily connect functions from different libraries (or your own) into one program.
   35  NOTE There are ways to extend an object with additional functionality using mixins, but you’re still responsible for managing the mixin object yourself. I don’t cover mixins in this book, but you can read about them in “A fresh look at JavaScript Mixins” (Angus Croll, JavaScript, JavaScript ..., May 30, 2011, http://mng.bz/15Zj).
   36: At a high level, you can visualize a simple sequence of array methods as shown in fig- ure 4.3. It would be best to break the chain (so to speak) and have a lot more free- dom to arrange a sequence of independent functions; you can achieve this with function pipelines.
   37  4.1.2	Arranging functions in a pipeline
   38: Functional programming removes the limitations present in method chaining and provides the flexibility to combine any set of functions, no matter where they come from. A pipeline is a directional sequence of functions loosely arranged so that the out- put of one is input into the next. Figure 4.4 illustrates this abstractly by connecting functions that work with different types of objects.
   39  Figure 4.4 A Function pipeline that starts with a function f and input of type A and generates an object of type B, subsequently passed into g, which outputs an object of type C as the final result. Functions f and g can belong to any library or can be your own functions.
   40   
   ..
   45  Comparing figures 4.3 and 4.4 reveals a key difference between the approaches: chaining makes tight connections via an object’s methods, whereas a pipeline links inputs and outputs of any functions—arriving at loosely coupled components. But for this linkage to be possible, the connecting functions must be compatible in terms of arity and type, which we’ll examine next.
   46  4.2	Requirements for compatible functions
   47: Object-oriented programs use pipelines sporadically, in specific scenarios (authentica- tion/authorization is usually one of them); on the other hand, functional program- ming relies on pipelines as the sole method of building programs. Depending on the task at hand, there’s usually quite a gap between a problem definition and a proposed solution; therefore, computations must be carried out in well-defined stages. These stages are represented by functions that execute with the condition that their inputs and outputs be compatible in two ways:
   48  <li className="litag">	Type—The type returned by one function must match the argument type of a receiving function.</li>
   49  <li className="litag">	Arity —A receiving function must declare at least one parameter in order to handle the value returned from a preceding function call.</li>
   50  4.2.1	Type-compatible functions
   51: When designing function pipelines, it’s important that there exists a level of compati- bility between what functions return and what they accept. In terms of type, this isn’t as big a concern in JavaScript as it is with statically typed languages, because JavaScript is loosely typed. Hence, if an object behaves like a certain type in practice, it’s that type. This is also known as duck typing. “If it walks like a duck and talks like a duck, it’s a duck.”
   52: NOTE Statically typed languages have the advantage of using type systems to alert you about potential problems without having to run your code. Type sys- tems are an important topic in functional programming but aren’t covered in this book.
   53: JavaScript’s dynamic dispatch mechanism attempts to find properties and methods in your objects regardless of type information. Although this is extremely flexible, you often need to know what types of values a function is expecting; having this clearly defined (perhaps documented in code using the Haskell notation) makes your pro- grams easier to understand.
   54  <p className="pag">Page 89</p>
   55  Formally speaking, two functions f and g are type-compatible if the output of f has a type equivalent to the set of inputs of g. For example, here’s a simple program to process a student’s Social Security number:
   ..
   58  Types are certainly important but, in JavaScript, not as criticai as being compatible with the number of arguments a function accepts.
   59  4.2.2 Functions and arity: the case for tuples
   60: Arity can be defined as the number of arguments a function accepts; it’s also referred to as the function’s length. We usually take arity for granted in other programming par- adigms, but in functional programming, as a corollary to referential transparency, the number of arguments a function declares is often directly proportional to its complex- ity. For instance, a function that works on a single string is likely much simpler than one taking three or four arguments:
   61  Pure functions that expect a single argument are the simplest to use because the implication is that they serve a single purpose—a singular responsibility. Our goal is to work with functions with as few arguments as possible, because they’re more flexible
   62   
   ..
   67  <p className="pag">Page 90</p>
   68  and versatile than those that depend on multiple arguments. Unfortunately, unary functions aren’t easy to come by. In real life, isValid can be embellished with an error message that clearly describes what happened:
   69: But how can you return two different values? Functional languages have support for a structure called a tuple. It’s a finite, ordered list of elements, usually grouping two or three values at a time, and written (a, b, c). Based on this concept, you can use a tuple as a return value from isValid that groups a status with a possible error mes- sage, to be returned as a single entity and subsequently passed to another function if need be. Let’s explore tuples in more detail.
   70  Tuples are immutable structures that pack together items of different types so that they can be passed into other functions. There are other ways of returning ad hoc data, such as object literals or arrays:
   71  <pre>return {
   ..
   75  But when it comes to transferring data between functions, tuples offer more advantages:
   76  <li className="litag">	Immutable—Once created, you can’t change a tuple’s internal contents.</li>
   77: <li className="litag">	Avoid creating ad hoc types—Tuples can relate values that may have no relation- ship at all to each other. So defming and instantiating new types solely for grouping data together makes your model unnecessarily convoluted.</li>
   78  <li className="litag">	Avoid creating heterogeneous arrays—Working with arrays containing different types of elements is hard because it leads to writing code filled with lots of defensive type checks. Tradi tionally, arrays are meant to store objects of the same type.</li>
   79: Moreover, tuples behave much like the value objects shown in chapter 2. One con- crete use case is in the concept of a Status, a simple data type containing a status flag and a message: (false, 'Some error occurred!'). Unlike other functional languages, such as Scala, JavaScript has no native support for a Tuple data type. For instance, given the following Scala tuple definition
   80  <pre>var t =	(30, 60,	90)</pre>
   81  you can access each individual part like this:
   ..
   85  But JavaScript provides all the tools out of the box required for you to implement your own version of Tuple, as shown next.
   86  Listing 4.2 Typed Tuple data type
   87: The Tuple object in listing 4.2 is an immutable, fixed-length structure used to hold a heterogeneous set of n typed values that can be used for inter-function communica- tion. For instance, you can use it to build quick value objects, such as Status:
   88  <pre>const Status = Tuple(Boolean, String);</pre>
   89  Let’s finish the student SSN validation example to take advantage of tuples.
   ..
  105  Declares a Status type that holds values for status (Boolean) and message (String)
  106  <pre>isValid(normalize(strim('444-44-4444'))); //-> (true, 'Success!')</pre>
  107: The occurrence of 2-tuples is so frequent in software that it’s worth making them first- class objects. When combined with JavaScript ES6 support for destructured assignment, you can map tuple values to variables in a clean manner. Using tuples, the following code creates an object called StringPair.
  108  Listing 4.4 StringPair type
  109: Tuples are one way to reduce a function’s arity, but there’s a better alternative for cases in which tuples aren’t sufficient. Let’s spice things up a bit by introducing function curry- ing, which not only abstracts arity but also encourages modularity and reusability.
  110  4.3	Curried function evaluation
  111: Passing a function’s return value as input to a unary function is straightforward, but what if the target function expects more parameters? In order to understand currying in JavaScript, first you must understand the difference between a curried and a regular (non-curried) evaluation. In JavaScript, a regular or non-curried function call is per- mitted to execute with missing arguments. In other words, if you define a function f(a,b,c) and call it with just a, the evaluation proceeds, and the JavaScript runtime
  112   
  113  <p className="pag">Page 93</p>
  114  sets b and c to undefined, as shown in figure 4.5. This is unfortunate and most likely the reason why currying isn’t a built-in feature of the language. As you can imagine, not declaring any arguments and relying on the arguments object within functions only exacerbates this issue.
  115: On the other hand, a curried function is one where all arguments have been explicitly defined so that, when called with a subset of the arguments, it returns a new function that waits for the rest of the parameters to be supplied before running. Figure 4.6 rep- resents this visually.
  116: Currying is a technique that converts a multivariable function into a stepwise sequence of unary functions by suspending or “procrastinating” its execution until all arguments have been provided, which could happen later. Here’s the formal defini- tion of a curry of three parameters:
  117  <pre>curry(f) ::	(a,b,c) -> f(a) -> f(b)-> f(c)</pre>
  118: This formal notation suggests that curry is a mapping from functions to functions that deconstructs the input (a,b,c) into separate single-argument invocations. In pure functional programming languages, like Haskell, currying is a built-in feature and automatically part of all function definitions. Because JavaScript doesn’t auto- matically curry functions, you need to write some supporting code to enable this. Before we go into auto-currying, let’s start with a simple scenario of manually curry- ing two arguments.
  119   
  120  
  ...
  124  Let’s take another look at curry2, implementing the checkType function used in the Tuple type shown in listing 4.2. This example use functions from another functional library called Ramda.js.
  125  Another functional library?
  126: Like Lodash, Ramda.js provides lots of useful functions to connect functional pro- grams and also enables a pure functional style of coding. The reason for using it is that its parameters are conveniently arranged to facilitate currying, partial applica- tion, and composition, which I'll cover later in this chapter. For more details about setting up Ramda, see the appendix.
  127  Once it’s installed, you can use the global variable R to access all of its functionality, such as R.is:
  128   
  ...
  143  checkType(String)(42); //-> Throws TypeError
  144  
  145: For simple tasks, curry2 is adequate; but as you start building more-complex function- ality, you’ll need to handle any number of arguments automatically. Normally, I’d show you the function internals, but curry is a particularly long and convoluted func- tion to explain, so I’ll spare you the headache and move into a more useful discussion (you can find curry and its flavors—curryRight, curryN, and so on—implemented in both Lodash and Ramda).
  146: You can use R.curry to simulate the automatic currying mechanism in pure func- tional languages that works on any number of arguments. You can imagine automatic currying as artificially creating nested function scopes corresponding to the number of arguments declared. This example curries fullname:
  147  <pre>// fullname ::	(String, String) -> String
  148  const fullname = function (first, last) {
  ...
  185   
  186  <p className="pag">Page 97</p>
  187: Because the functions are curried, you can separate the function definition from eval- uation with a generic factory method findStudent, whose implementation details could have originated from either implementation:
  188  <pre>const findStudent = useDb ? fetchStudentFromDb(db)
  189  : fetchStudentFromArray(arr);
  190  findStudent('444-44-4444');</pre>
  191: Now, findStudent can be passed to other modules without the caller knowing the concrete implementation (this will be important in chapter 6 for unit testing to mock interaction with the object store). In matters of reuse, currying also allows you to cre- ate a family of function templates.
  192  4.3.2	Implementing reusable function templates
  193: Suppose you need to configure different logging functions to handle different states in your application, such as errors, warnings, debug, and so on. Function templates define a family of related functions based on the number of arguments that are cur- ried at the moment of creation. This example will use the popular library Log4js, a logging framework for JavaScript that is far superior to the typical console.log. You can find installation information in the appendix. Here’s the basic setup:
  194  <pre>const logger = new Log4js.getLogger('StudentEvents'); logger.info('Student added successfully!');</pre>
  195: But with Log4js, you can do much more. Suppose you need instead to display mes- sages on the screen in a pop-up. You can configure an appender to do so:
  196  <pre>logger.addAppender(new Log4js.JSAlertAppender());</pre>
  197  You can also change the layout by configuring the layout provider so that it outputs messages in JSON format instead of plain text:
  198  <pre>appender.setLayout(new Log4js.JSONLayout());</pre>
  199: There are many settings you can configure, and copying and pasting this code into each file causes lots of duplication. Instead, let’s use currying to define a reusable function template (a logger module, if you will), which will give you the utmost flexi- bility and reuse.
  200  Listing 4.6 Creating a logger function template
  201   
  ...
  204  <pre>const logError = R.curry(logger)('console', 'basic', 'FJS', 'ERROR');
  205  logError('Error code 404 detected!!'); logError('Error code 402 detected!!');</pre>
  206: Behind the scenes, subsequent calls to curry are called on this function, finally yield- ing a unary function. The fact that you’re able to create new functions from existing ones and pass any number of parameters to them leads to easily building functions in steps as arguments are defined.
  207: In addition to gaining lots of reusability in your code, as I mentioned, the principal motivation behind currying is to convert multiargument functions into unary func- tions. Alternatives to currying are partial function application and parameter binding, which are moderately supported by the JavaScript language, to produce functions of smaller arity that also work well when plugged into function pipelines.
  208  4.4	Partial application and parameter binding
  209  Partial application is an operation that initializes a subset of a nonvariadic function’s parameters to fixed values, creating a function of smaller arity. In simpler terms, if you have a function with five parameters, and you supply three of the arguments, you end up with a function that expects the last two.
  210: Like currying, partial application can be used to directly reduce the length of a func- tion, but in a slightly different manner. Because a curried function is, essentially, a par- tially applied function, there tends to be confusion about the techniques. Their main
  211   
  212  <p className="pag">Page 99</p>
  213  difference lies in the internai mechanism and control over parameter passing. I’il attempt to clarify:
  214: <li className="litag">	Currying generates nested unary functions at each partial invocation. Inter- nally, the final result is generated from the step-wise composition of these unary functions. Also, variations of curry allow you to partially evaluate a number of arguments; therefore, it gives you complete control over when and how evalua- tion takes place.</li>
  215: <li className="litag">	Partial application binds (assigns) a function’s arguments to predefined values and generates a new function of fewer arguments. The resulting function con- tains the fixed parameters in its closure and is completely evaluated on the subse- quent call.</li>
  216  Now that this is clear, let’s move on to examine a possible implementation of partial.
  217  Listing 4.7 Implementation of partial
  218: For this discussion of partial application and function binding, we’ll go back to using Lodash, because it has slightly better support for function binding than Ramda. On the surface, however, using _.partial has a similar feel to using R.curry, and both support placeholder arguments with their respective placeholder objects. With the same logger function shown earlier, you can partially apply certain parameters to cre- ate more-specific behavior:
  219  <pre>const consoleLog = _.partial(logger, 'console', 'json', 'FJS Partial');</pre>
  220  Let’s use this function to reemphasize the difference between curry and partial. After applying these three arguments, the resulting consoleLog function expects the
  ...
  227  <pre>const log =_.bind(logger, undefined, 'console', 'json', 'FJS Binding');
  228  log('WARN', 'FP is too awesome!');</pre>
  229: What is this undefined second argument to _.bind? Bind lets you create bound func- tions, which can execute within the context of an owning object (passing undefined tells the runtime to bind this function to the global context). Let’s see some practical uses of _.partial and _.bind that do the following:
  230  <li className="litag">	Extend the core language</li>
  231  <li className="litag">	Bind delayed functions</li>
  232  4.4.1	Extending the core language
  233: Partial application can be used to extend core data types like String and Number with useful utilities than enhance the expressiveness of the language. Just be mindful that extending the language this way may make your code less portable to platform upgrades if new, conflicting methods are added to the language. Consider the follow- ing examples:
  234  Index 1 See “Function.prototype.bind(),” MozillaDeveloperNetwork, http://mng.bz/MY75.
  235   
  ...
  241  There are cases where partial application doesn’t work, such as when you’re working with delayed functions like setTimeout. For this, you need to use function binding.
  242  4.4.2	Binding into delayed functions
  243: Using function binding to set the context object is important when you’re working with methods that expect a certain owning object to be present. For instance, func- tions such as setTimeout and setInterval in the browser expect the this reference to be set to global context, the window object; otherwise, they don’t work. Passing undefined tells the runtime to do just this. For instance, setTimeout can be used to create a simple scheduler object to run delayed tasks. Here’s an example of using both _.bind and _.partial:
  244  <pre>const Scheduler = (function ()	{
  245  const delayedFn = _.bind(setTimeout, undefined, _, _);
  ...
  256  <p className="pag">Page 102</p>
  257  from the composition of a bound function and a partially applied function. Function binding isn’t as useful as partial application in functional programming, and it’s also a bit trickier to use, because it involves once again setting the function context. I cover it here in case you run into it when exploring this topic on your own.
  258: Both partial application and currying are useful. Currying is the most widely used technique to create function wrappers that abstract a function’s behavior, either to preset its arguments or to partially evaluate them. This is beneficial because pure functions with fewer arguments are easier to work with than functions with many argu- ments. Either approach facilitates supplying the proper arguments so that functions don’t have to blatantly access objects outside of their scope, while reducing them to unary functions. Isolating the logic of obtaining this necessary data makes functions more reusable; and, more important, it simplifies their composition.
  259  4.5	Composing function pipelines
  260: In chapter 1, we talked about the importance of being able to split a problem into smaller, simpler subproblems (or tasks) in order to put them back together to arrive at a solution—like pieces in a puzzle. The intention of functional programs is to gain the required structure that leads to composition, the backbone of functional programming. By now you understand the concepts of purity and side effect-free functions that make this such a powerful technique. Recall that a side effect-free function is one that doesn’t depend on any external data; everything the function needs must be provided as argu- ments. In order to properly use composition, your functions must be side effect-free.
  261: Furthermore, if a program is built from pure functions, the resulting program is itself pure, allowing it to be composed further as a part of even more-complex solu- tions without antagonizing other parts of the system. This topic is extremely impor- tant to understand, because it will be the central theme of the book going forward. So before we dive into functional composition, let’s take a moment to understand it with a concrete example that composes widgets in an HTML page.
  262  4.5.1	Understanding composition with HTML widgets
  263: The idea of composition is intuitive and certainly not unique to functional program- ming. Consider how HTML widgets are laid out on a page. Complex widgets are built from the combination of simple ones, which in turn can form part of even bigger wid- gets. For instance, combining three input text boxes with an empty container pro- duces a simple student form, as shown in figure 4.7.
  264  The student form is a now a component (itself a widget) that can be composed with others into a more complex component to create an entire student console form (see figure 4.8). You get the idea; the student console widget could be plugged in to a bigger dashboard if need be. In this case, we say the console is composed of (or made up of) the address and bio forms. Objects with simple behavior (which don’t have external dependencies) compose fairly well and can be used to build complex structures from simple ones, like interlocking building blocks.
  265  <p className="pag">Page 103</p>
  ...
  278   
  279  <p className="pag">Page 104</p>
  280: This is more or less how lists are constructed in languages like ML and Haskell. On the other hand, complex objects with high degrees of coupling to other external objects don’t have clear rules for composition and can be extremely hard to work with. Func- tional composition can have a similar fate when side effects and mutations are pres- ent. Now, let’s dive into the composition of functions.
  281  4.5.2	Functional composition: separating description from evaluation
  282  In essence, functional composition is a process used to group together complex behavior that has been broken into simpler tasks. I defined it briefly in chapter 1, and now I’ll explain it in detail. Let’s go over a quick example that uses Ramda’s R.compose to combine two pure functions:
  283: Arguably, this code is easy to read, and its meaning easily derived by glancing at the function’s constituent parts. The interesting quality of this program is that evaluation never takes place until countWords is run; in other words, the functions passed by name (explode and count) are dormant within the composition. The result of com- position is another function that waits to be called with its respective argument: the argument to countWords. This is the beauty of function composition: separating a func- tion ’s description from its evaluation.
  284  I’ll explain what happens behind the scenes. The call to countWords(str) runs explode with the given sentence and passes its output (array of strings) into count, which computes the length of the array. Composition connects outputs with inputs, creating true function pipelines. Let’s examine a more formal definition. Consider two functions f and g with their respective input and output types:
  285  Figure 4.10 draws a set of arrows connecting all groups. This abstract example shows a function (arrow) f that takes an argument of type B and returns a C. Another function (arrow) g takes an A and returns a B. The composition of g :: A -> B and f :: B -> C,
  ...
  294  pronounced (“f composed of g”), results in another function (arrow) from A -> C, as shown in figure 4.11. This can be expressed more formally as
  295  <pre>f • g = f(g) = compose ::	(B -> C) -> (A -> B) -> (A -> C)</pre>
  296: Recall that with referential transparency, functions are nothing more than arrows con- necting one object of a group to another.
  297: This leads to another important software development principle, which is the backbone of modular systems. Because composition loosely binds type-compatible functions at their boundaries (inputs and outputs), it fairly satisfies the principle of programming to interfaces. In the previous example, you have a function explode :: String -> [String] composed with the function count :: [String] -> Number; in other words, each function only knows or cares about the next function’s interface and isn’t worried about its implementation. Although it isn’t part of the JavaScript lan- guage, compose can be naturally expressed as a higher-order function.
  298  Listing 4.8 Implementation of compose
  299   
  300  <p className="pag">Page 106</p>
  301  Luckily, Ramda provides an implementation of R.compose that you can use so you don’t have to implement this yourself. Let’s write a validation program that checks for a valid SSN (you’ll reuse a lot of these helper functions throughout the book):
  302: Taking this fundamental concept further, as you can see in figure 4.12, entire pro- grams can be built with the combination of simple functions.
  303  Figure 4.12 Complex functions can be built by composing simple functions. Just as functions combine, entire programs made from different modules (containing more functions) that can also combine in this fashion.
  304: This concept isn’t limited to functions; entire programs can be built from the combi- nation of other side effect-free, pure programs or modules. (Based on the earlier def- inition of a function, used throughout this book, I’ll use the terms function, program, and module loosely to refer to any executable unit with inputs and output.)
  305   
  306  
  307   
  308  <p className="pag">Page 107</p>
  309: Composition is a conjunctive operation, which means it joins elements using a logicai AND operator. For instance, the function isValidSsn is made from checkLengthSsn and cleanInput. In this manner, programs are derivations of the sum of all their parts. In chapter 5, we’ll tackle problems that require disjunctive behavior to express condi- tions where functions can return one of two results, A OR B.
  310  Alternatively, you can augment JavaScript’s Function prototype to add compose. Here’s the exact same behavior in a style similar to function chaining from chapter 3:
  311   
  312: If you like this better, feel free to use it. In the next chapter, you’ll learn that this mecha- nism of chaining methods is prevalent in functional algebraic data types called monads. Personally, I recommend sticking to the more functional form, because it’s much more succinct and flexible and works better in conjunction with functional libraries.
  313  4.5.3 Composition with functional libraries
  314: One of the benefits of working with a functional library such as Ramda is that all func- tions have been properly configured with currying in mind, making them versatile when composed into function pipelines. Let’s look at another example. Here’s a list of students with their respective grades in a class:
  315  <pre>const students = ['Rosser', 'Turing', 'Kleene', 'Church'];
  316  const grades =	[80, 100,	90,	99];</pre>
  317: Suppose you need to find the student with the highest grade in the class. You learned in chapter 3 that working with collections of data is one of the cornerstones of func- tional programming. The code in listing 4.9 is made up of the composition of several curried functions, each in charge of transforming this data in a particular way:
  318  <li className="litag">	R.zip—Creates a new array by pairing the contente of adjacent arrays. In this case, pairing these two arrays yields [['Rosser', 80], ['Turing', 100], ...].</li>
  319  <li className="litag">	R.prop—Specifies the value to be used in sorting. In this case, passing a 1 points to the second element of a subarray (grade).</li>
  ...
  325  Listing 4.9 Computing the smartest student
  326  Using composition can be challenging, especially when you’re just getting acquainted with the framework or you’re just beginning to understand the problem domain. When I use composition in my own work, I often find myself thinking about where I should begin. Again, the hardest part is the exercise of breaking a task into smaller pieces; once this is finalized, composition is compelling for recombining functions.
  327: In addition, something you’ll soon realize and begin to love about functional com- position is how you’re naturally drawn to expressing the entire solution succinctly in one or two lines. Because you’re forced to create functions that map to the different stages in your algorithm, you begin to build an ontology with which you can stitch together expressions that describe parts of your solution, allowing team members to more quickly understand your code. The following listing is similar to an exercise from chapter 3.
  328  Listing 4.10 Using descriptive function aliases
  329  <pre>const first = R.head;
  ...
  333  const combine = R.zip;
  334  R.compose(first, getName, reverse, sortByGrade, combine);</pre>
  335: Although this instance of the program is easier to read, there’s no added reusability because these functions are specific to the particular task at hand. Rather, I recom- mend getting acquainted with the functional vocabulary of head, pluck, zip, and oth- ers, so that, through practice, you gain comprehensive knowledge of your functional framework of choice. It will make the transition to other frameworks or other func- tional languages easier, because they all use many of the same naming conventions. This will quickly pay dividends in your productivity.
  336  Listings 4.9 and 4.10 uses pure functions to express an entire solution, but you know this isn’t always possible. As an application developer, you’ll face many situations where you need to do things like read from local storage and make remote HTTP requests, among other tasks, which unavoidably create side effects. For this, you must
  337   
  ...
  340  4.5.4	Coping with pure and impure code
  341  Impure code causes externally observable side effects after it’s run and has external dependencies to access data beyond the scope of its constituent functions. It only takes one function to be impure for your entire program to follow suit.
  342: With that said, you don’t have to make your functions 100% pure to reap the ben- efits of functional programming. Although this is the perfect scenario, you must also learn to tolerate pure and impure behavior by creating a clear separation between the two and isolating the impurity as much as possible—ideally, in single functions. Then composition can be used to glue the pure and impure pieces back together. Recall from chapter 1 that you began implementing the requirements for the showStudent function, which looked like this:
  343  <pre>const showStudent = compose(append, csv, findStudent);</pre>
  344  One way or another, most of these functions emit side effects through the arguments they receive:
  345  <li className="litag">	findStudent uses a reference to a local object store or some external array.</li>
  346  <li className="litag">	append directly writes and modifies HTML elements.</li>
  347: Let’s continue improving this program by using curry to partially evaluate the invari- able parameters of each function. You’ll also add code to sanitize the input parameter and refactor the HTML operations with more fine-grained functions. Finally, you’ll make the find operation more functional by dislodging it from the object store.
  348  Listing 4.11 showStudent program using currying and composition
  349   
  350  <p className="pag">Page 110</p>
  351  The code in listing 4.11 defìnes four functions that make up showStudent (I added their type signatures so that you can more easily follow the correspondence between each successive invocation). This program executes all the functions beginning with trim and works backward until it calls append, linking the output of one function and passing it to the next. But wait a second; remember the Unix program with which I started the chapter? This program executes each function in a left-to-right manner using the Unix built-in pipe | operator. Piping functions evaluates programs in the opposite order of composition (see figure 4.13).
  352: If the thought of composing functions in this naturally reversed flow feels odd to you, or you visualize your programs as a left-associative sequence, you can use Ramda’s mir- ror function to compose, called pipe, which achieves the same results:
  353  <pre>R.pipe(
  354  trim,
  ...
  357  csv,
  358  append('#student-info'));</pre>
  359: As evidence of how important this is, F# provides built-in support for this using its pipe-forward operator |>. In JavaScript, we don’t have this luxury, but we can safely rely on functional libraries to do the job effectively Note from both R.pipe and R.compose that you’re creating new functions without having to explicitly declare any of their formal arguments, as you’d normally have to. Functional composition encour- ages this writing style, which goes by the name of point-free coding.
  360   
  361  
  ...
  363  <p className="pag">Page 111</p>
  364  4.5.5	Introducing point-free programming
  365: If you look closer at the function in listing 4.10, you can see that it doesn’t show the parameters of any of its constituent functions, as would a traditional function declara- tion. Here it is again:
  366  <pre>R.compose(first, getName, reverse, sortByGrade, combine);</pre>
  367  Using compose (or pipe) means never having to declare arguments (known as the points of a function), making your code declarative and more succinct or point-free.
  368: Point-free programming brings functional JavaScript code closer to that of Haskell and the Unix philosophy. It can be used to increase the level of abstraction by forcing you to think of composing high-level components instead of worrying about the low- level details of function evaluation. Currying plays an important role because it gives you the flexibility to partially define all but the last argument of an inlined function reference. This style of coding is also known as tacit programming, much like the Unix program from the start of the chapter, which is written next in a point-free way.
  369  Listing 4.12 Point-free version of a Unix program using Ramda functions
  370: The program in listing 4.12 is made up of point-free function expressions that are defined only by name (some with an argument partially defined), without declaring what types of arguments they take or how they’re connected within the bigger expres- sion. As composition morphs into this coding style, it’s important to keep in mind that overdoing it can create obscure or obfuscated programs. Not everything has to be point-free. In some cases, breaking out your function composition into two or three at a time can go a long way.
  371: Point-free code can raise questions related to error handling and debugging. In other words, because throwing exceptions causes side effects to occur, should you resort to returning null from within composed functions? Checking for null within functions is acceptable but adds a lot of duplicated, boilerplate code and assumes you return sensible default values for the program to proceed. Also, how would you attempt to debug all of these commands, which appear on a single line? These are valid con- cerns and will be addressed in the next chapter, where I’ll present more point-free programs that include automatic support for error handling.
  372   
  373  <p className="pag">Page 112</p>
  374: Another obvious concern is how to handle situations where you need to use condi- tional logic or have some way of running multiple functions in sequence. In the next section, I’ll discuss helpful utilities to manage your application’s control flow.
  375  4.6	Managing control flow with functional combinators
  376: In chapter 3, I gave a comparison of a program’s control flow in both imperative and functional paradigms and highlighted the significant differences between them. Imperative code uses procedural control mechanisms like if-else and for to drive a program’s flow, but functional programming doesn’t. As we leave the imperative world behind, we need to find alternatives to fill in that gap; for this, we can use func- tion combinators.
  377: Combinators are higher-order functions that can combine primitive artifacts like other functions (or other combinators) and behave as control logic. Combinators typ- ically don’t declare any variables of their own or contain any business logic; they’re meant to orchestrate the flow of a functional program. In addition to compose and pipe, there’s an infinite number of combinators, but we’ll look at some of the most common ones:
  378  <li className="litag">	identity</li>
  379  <li className="litag">	tap</li>
  ...
  385  <pre>identity ::	(a) -> a</pre>
  386  It’s used extensively when examining the mathematical properties of functions, but it has other practical applications as well:
  387: <li className="litag">	Supplying data to higher-order functions that expect it when evaluating a func- tion argument, as you did earlier when writing point-free code (listing 4.12).</li>
  388  <li className="litag">	Unit testing the flow of function combinators where you need a simple function result on which to make assertions (you’ll see this in chapter 6). For instance, you could write a unit test for compose that uses identity functions.</li>
  389  <li className="litag">	Extracting data functionally from encapsulated types (more on this in the next chapter).</li>
  ...
  418  const showStudent = R.compose( append('#student-info'), csv,
  419  alt(findStudent, createNewStudent)); showStudent('444-44-4444');</pre>
  420: To understand what’s happening, think of this code emulating a simple if-else state- ment equivalent to the imperative conditional logici:
  421  <pre>
  422  var student = findStudent('444-44-4444'); if(student !== null) { let info = csv(student); append('#student-info', info);
  ...
  434  };
  435  };</pre>
  436: With it, you can perform a sequence of related, yet independent, operations. For instance, after finding the student object, you can use seq to both render it on the HTML page and log it to the console. All functions will run in that order against the same stu- dent object:
  437  <pre>
  438  const showStudent = R.compose(
  ...
  445  The seq combinator doesn’t return a value; it just performs a set of actions one after the other. If you want to inject it into the middle of a composition, you can use R.tap to bridge the function with the rest.
  446  4.6.5	Fork (join) combinator
  447: The fork combinator is useful in cases where you need to process a single resource in two different ways and then combine the results. This combinator takes three func- tions: a join function and two terminal functions that process the provided input. The result of each forked function is ultimately passed in to a join function of two argu- ments, as shown in figure 4.14.
  448  NOTE This isn’t to be confused with the Java fork-join framework, which helps with multiprocessing. This comes as a fork combinator implementation in Haskell and other functional toolkits.
  449  This is the implementation:
  ...
  464   
  465  <p className="pag">Page 116</p>
  466: Some people view composition as restrictive, but you can see for yourself that it’s quite the opposite: combinators unlock freedom and facilitate point-free programming. Because combinators are pure, they can be composed into other combinators, provid- ing an infinite number of alternatives to express and reduce the complexity of writing any type of application. You’ll see them used again in the following chapters.
  467  Through the basic principles of immutability and purity, functional programming enables a fine level of modularity and reusability of the functions that make up your program. In chapter 2, you learned that in JavaScript, functions can also be used to implement modules. Using these same principles, you can also compose and reuse entire modules. I’ll leave this idea for you to contemplate on your own.
  468: Modular functional programs consist of abstract functions that can be understood and reused independently and whose meaning is derived from rules governing their composition. In this chapter, you learned that composing pure functions is the back- bone of functional programming. These techniques take advantage of the abstraction (via currying and partial application) of pure functions with the goal of making them composable. So far, I haven’t talked about error handling, which is a critical part of any robust, fault-tolerant application; that’s what we’ll visit next.
  469  4.7	Summary
  470: <li className="litag">	Functional chains and pipelines connect reusable and modular componen- tized programs.</li>
  471  <li className="litag">	Ramda.js is a functional library adapted for currying and composition, with a powerful arsenal of utility functions.</li>
  472: <li className="litag">	Currying and partial evaluation can be used to reduce the arity of pure func- tions by partially evaluating a subset of a function’s arguments and transform- ing them into unary functions.</li>
  473  <li className="litag">	You can break a task into simple functions and compose them together to arrive at the entire solution.</li>
  474  <li className="litag">	Using function combinators allows you to orchestrate complicated program flows to tackle any real-world problem as well as write in a point-free manner.</li>

C:\Users\Emanuela\FunctionalP\pages\Chapter 5 - Design patterns against com.js:
    1: <p className="pag">Page 117 - Chapter 5 - Design patterns against complexity</p>
    2  This chapter covers
    3  <li className="litag">	The issues with imperative error-handling schemes</li>
    .
   14  however, people are finding that functional programming can treat error handling more elegantly than any other development style.
   15  Many issues can arise in software where data inadvertently becomes nuli or undefined, exceptions are thrown, or network connectivity is lost, to name a few. Our code needs to account for the potential of any of these issues occurring, which unavoidably creates complexity. As a result, we spend countless hours making sure our code throws and catches the proper exceptions and checks for nuli values everywhere we can think of, and what do we get? Even more complex code—code that doesn’t scale and becomes harder to reason about as the size and complexity of applications increase.
   16: We need to work smarter, not harder. In this chapter, I’ll introduce the concept of functors as a means to create simple data types on which functions can be mapped. A functor is applied to data types called monads that contain specific behavior for deal- ing with errors in different ways. Monads are one of the hardest concepts to grasp in functional programming because the theory is deeply rooted in category theory, which I won’t cover. My intention is to focus only on the practical aspects. Having said that, I’ll slowly work my way into that topic, layering in some prerequisite concepts, and then show how you can use monads to create fault-tolerant function compositions in a way that imperative error-handling mechanism can’t.
   17  5.1	Shortfalls of imperative error handling
   18: JavaScript errors can occur in many situations, especially when an application fails to communicate with a server or tries to access properties of a nuli object. Also, third- party libraries can have functions throw exceptions to signal special error conditions. Hence, we always need to be prepared for the worst and design with failure in mind, instead of letting it become an afterthought and regretting it later. In the imperative world, exceptions are handled via the try-catch idiom.
   19  5.1.1	Error handling with try-catch
   20: JavaScript’s current exception-handling mechanism is geared toward throwing and catching exceptions through the popular try-catch structure present in most mod- ern programming languages:
   21  <pre>try {
   22  // code that might throw an exception in here
   ..
   27  The purpose of this structure is to surround a piece of code that you deem to be unsafe. Upon throwing an exception, the JavaScript runtime abruptly halts the
   28  <p className="pag">Page 119</p>
   29: program’s execution and creates a stack trace of all function calls leading up to the problematic instruction. As you know, specific details about the error, such as the message, line number, and filename, are populated into an object of type Error and passed into the catch block. The catch block becomes a safe haven so that you can potentially recover your program. For example, recall the findObject and find- Student functions:
   30  <pre>
   31  // findObject :: DB, String -> Object const findObject = R.curry(function (db, id) { const result = find(db, id) if(!result) {
   ..
   48  The structured mechanism of throwing and catching exceptions in imperative JavaScript code has many drawbacks and is incompatible with the functional design. Functions that throw exceptions
   49  <li className="litag">	Can’t be composed or chained like other functional artifacts.</li>
   50: <li className="litag">	Violate the principle of referential transparency that advocates a single, predict- able value, because throwing exceptions constitutes another exit path from your function calls.</li>
   51  <li className="litag">	Cause side effects to occur because an unanticipated unwinding of the stack impacts the entire system beyond the function call.</li>
   52  Paga 120
   ..
   61  }</pre>
   62  <li className="litag">	Put a great deal of responsibility on the caller to declare matching catch blocks to manage specific exceptions instead ofjust worrying about a function’s single return value.</li>
   63: <li className="litag">	Are hard to use when multiple error conditions create nested levels of exception- handling blocks:</li>
   64  <pre>var student = null; try {
   65  student = findStudent('444-44-44444');
   ..
   74  }
   75  }</pre>
   76: You’re probably asking yourself, “Is throwing exceptions completely off the table in functional programming?” I don’t believe so. In practice, they can never be off the table, because there are many factors outside of your control that you need to account for. Also, you may be writing code against a library outside of your control that imple- ments exceptions.
   77: Using exceptions can be effective for certain edge cases. In checkType in chapter 4, you used an exception to signal a fundamental misuse of the API. They’re also useful to signal unrecoverable conditions like RangeError: Maximum call stack size exceeded, which I’ll talk about in chapter 7. Throwing exceptions has a place but shouldn’t be done excessively. A common scenario that occurs in JavaScript is the infamous Type- Error resulting from invoking a function on a null object.
   78  <p className="pag">Page 121</p>
   79  5.1.3	Problems with null-checking
   80: The alternative to failing abruptly from a function cali is to return nuli. That, at least, guarantees only one route that leaves a function call, but it’s not any better. Functions that return nuli create a different responsibility for users: pesky nuli checks. Con- sider the function getCountry, which is in charge of reading a student’s address and then country:
   81  <pre>function getCountry(student) {
   82  let school = student.getSchool(); if(school !== null) {
   ..
   88  }</pre>
   89  At a glance, this function should have been simple to implement—after all, it’s just extracting an object’s property. I could have created a simple lens that focuses on this property; in the event of a null address, a lens is smart enough to return undefined, but it doesn’t help me to print an error message.
   90: Instead, I ended up with lots of lines of code to defend myself from unexpected behavior. Defensively wrapping code with lots of try-catch or null checks is cow- ardly. Wouldn’t it be great to be able to handle errors effectively while avoiding all of this unnecessary boilerplate code?
   91  5.2	Building a better solution: functors
   92  Functional error handling is a radically different approach to properly cope with the adversities found in software systems. The idea, however, is somewhat similar: create a safety box (a container, if you will) around potentially hazardous code (see figure 5.1).
   93   
   94  <p className="pag">Page 122</p>
   95: In functional programming, this notion of boxing the dangerous code stili applies, but you throw away the try-catch block. Now, here’s the big difference. Walling off impurity is made a first-class citizen in functional programming by the use of func- tional data types. Let’s begin with the most basic type and move into the more advanced ones.
   96  5.2.1	Wrapping unsafe values
   97  Containerizing (or wrapping) values is a fundamental design pattern in functional programming because it guards direct access to the values so they can be manipulated safely and immutably in your programs. It’s like wearing armor before going to battle. Accessing a wrapped value can only be done by mapping an operation to its container. In this chapter, I’ll talk extensively about the concept of a map, but you already learned about this in chapter 3 when you used map on arrays—the array was the container of values, in that case.
   98: It turns out you can map functions to much more than just arrays. In functional JavaScript, a map is nothing more than a function; this idea comes from referential trans- parency, where a function must always “map to” the same result given the same input. So you can also think of map as a gate that allows you to plug in a lambda expression with specific behavior that transforms an encapsulated value. In the case of arrays, you used map to create a new array with the transformed values.
   99  Let’s illustrate this concept with a simple data type called Wrapper, in the following listing. Although this type is simple, the underlying principle is extremely powerful and will pave the way for the next sections in this chapter, so it’s important that you understand it.
  100  Listing 5.1 Functional data type to wrap values
  ...
  104  function you learned about in chapter 4 (notice there’s no explicit get method on this wrapper type). Certainly JavaScript will give you easy access to this value, but the point to understand here is that once the value enters the container, it can’t directly retrieved or transformed (like a virtual barrier); see figure 5.2.
  105  You can map any function to this container to either log to the console or manipulate it as needed:
  106: The benefit of this simple idea is that any code written against these wrappers needs to be able to “reach into the container” via Wrapper.map in order to use the guarded value contained within. But if the value happens to be nuli or undefined, the respon- sibility is placed on the caller, which may or may not gracefully handle this case. Later, you’ll see a better alternative:
  107  As you can see from this example, to manipulate a value within a guarded, wrapped context, you need to apply a function to it; you can’t invoke a function directly. What
  108   
  ...
  112   
  113  <p className="pag">Page 124</p>
  114: to do in the event of an error can be delegated to concrete wrapper types. In other words, you can check for nuli before calling the function, or check for an empty string, a negative number, and so on. Hence, the semantic of Wrapper.map is deter- mined by the specific implementation of the wrapping type.
  115: Let’s not get ahead of ourselves; we have some more groundwork to cover. Con- sider this slightly different variation of map, called fmap:
  116  fmap knows how to apply functions to values wrapped in a context. It first opens the container, then applies the given function to its value, and finally closes the value back into a new container of the same type. This type of function is known as a functor.
  117  5.2.2	Functors explained
  118: In essence, a functor is nothing more than a data structure that you can map func- tions over with the purpose of lifting values into a wrapper, modifying them, and then putting them back into a wrapper. It’s a design pattern that defines semantics for how fmap should work. Here’s the general definition of fmap:
  119  The function fmap takes a function (from A -> B) and a functor (wrapped context) Wrapper(A) and returns a new functor Wrapper(B) containing the result of applying said function to the value and closing it once more. Figure 5.3 shows a quick example that uses the increment function as a mapping function from A -> B (except in this case, A and B are the same types).
  120: Notice that because fmap basically returns a new copy of the container at each invocation, much as lenses (chapter 2) work, it can be considered immutable. In fig- ure 5.3, mapping the increment over Wrapper(1) returns a completely new object,
  121  Figure 5.3 A value of 1 is contained within Wrapper. The functor is called with the wrapper and the increment function, which transforms the value internally and closes it back into a container.
  122   
  ...
  133  Calling fmap to map plus3 over the container performs addition:
  134  Figure 5.4 The value 2 has been added to a Wrapper container. The functor is used to manipulate this value by unwrapping it from the context, applying the given function to it, and rewrapping the value back into a new context.
  135: The purpose of having fmap return the same type (or wrap the result again into a con- tainer of the same type) is so you can continue chaining operations. Consider the fol- lowing example, which maps plus3 on a wrapped value and logs the result.
  136  Listing 5.2 Chaining functors to apply additional behavior to a given context
  137  <pre>const two = wrap(2);
  ...
  148  <pre>map	:: (A -> B)	-> Array(A) -> Array(B)
  149  filter :: (A -> Boolean) -> Array(A) -> Array(A)</pre>
  150: map and filter are type-preserving functors, which is what activates the chaining pat- tern. Consider another functor you’ve seen all along: compose. As you learned in chapter 4, it’s a mapping from functions into other functions (also type-preserving):
  151  <pre>compose :: (B -> C) -> (A -> B) -> (A -> C)</pre>
  152: Functors, like any other functional programming artifact, are governed by some impor- tant properties:
  153: <li className="litag">	They must be side effect-free. You can map the R.identity function to obtain the same value over a context. This proves functors are side effect-free and pre- serves the structure of the wrapped value:</li>
  154  <pre>wrap('Get Functional').fmap(R.identity); //-> Wrapper('Get Functional')</pre>
  155: <li className="litag">	They must be composable. This property indicates that the composition of a func- tion applied to fmap should be exactly the same as chaining fmap functions together. As a result, the following expression is exactly equivalent to the pro- gram in listing 5.2:</li>
  156  <pre>two.fmap(R.compose(plus3, R.tap(infoLogger))).map(R.identity); //-> 5</pre>
  157: It’s no surprise that functors have these requirements. As a result, they’re prohibited from throwing exceptions, mutating elements, or altering a function’s behavior. Their practical purpose is to create a context or an abstraction that allows you to securely manipulate and apply operations to values without changing any original values. This is evident in the way map transforms one array into another without altering the origi- nal array; this concept equally translates to any container type.
  158: But functors by themselves aren’t compelling, because they’re not expected to know how to handle cases with null data. Ramda’s R.compose, for instance, will break if a null function reference is passed into it. This isn’t a flaw in the design; it’s inten- tional. Functors map functions of one type to another. More-specialized behavior can be found in functional data types called monads. Among other things, monads can streamline error handling in your code, allowing you to write fluent function compo- sitions. What’s their relationship to functors? Monads are the containers that functors “reach into.”
  159  <p className="pag">Page 127</p>
  160: Don’t let the term monad discourage you; if you’ve written jQuery code, then monads should be familiar. Behind all the complicated rules and theories, the pur- pose of monads is to provide an abstraction over some resource—whether it’s a simple value, a DOM element, an event, or an AJAX call—so that you can safely process the data contained within it. In this respect, you can classify jQuery as a DOM monad:
  161  <pre>$('#student-info').fadeIn(3000).text(student.fullname());</pre>
  162: This code behaves like a monad because jQuery is taking charge of applying the fadeIn and text transformations safely. If the student-info panel doesn’t exist, applying methods to the empty jQuery object will fail gracefully rather than throw exceptions. Monads aimed at error handling have this powerful quality: safely propa- gating errors so your application is fault-tolerant. Let’s dive into monads next.
  163  5.3	Functional error handling using monads
  164: Monads solve all the problems of traditional error handling outlined earlier when applied to functional programs. But before diving into this topic, let’s first understand a limitation in the use of functors. As you saw earlier, you can use functors to safely apply functions to values in an immutable and safe manner. But when used through- out your code, functors can easily get you into an uncomfortable situation. Consider an example of fetching a student record by SSN and then extracting its address prop- erty. For this task, you can identify two functions—findStudent and getAddress— both using functor objects to create a safe context around their returned values:
  165  Just as you’ve done all along, to run this program, you compose both functions together:
  166  <pre>const studentAddress = R.compose( getAddress,
  ...
  174  Certainly you don’t want to access data this way in your code; just think about the case when you have three or four composed functions. You need a better solution. Enter monads.
  175  5.3.1	Monads: from control flow to data flow
  176: Monads are similar to functors, except that they can delegate to special logic when handling certain cases. Let’s examine this idea with a quick example. Consider apply- ing a function half :: Number -> Number to any wrapped value, as shown in figure 5.5:
  177  <pre>Wrapper(2).fmap(half); //-> Wrapper(l)
  178  Wrapper(3).fmap(half); //-> Wrapper(1.5)</pre>
  ...
  210   
  211  <p className="pag">Page 131</p>
  212: Wrapper uses the functor map to lift data into the container so that you can manipulate it side effect-free—walled off from the outside world. Not surprisingly, the _.iden- tity function is used to inspect its contents:
  213  <pre>Wrapper.of('Hello Monads!')
  214  .map(R.toUpper)
  ...
  222  }
  223  const studentAddress = R.compose(getAddress, findObject(DB('student'))); studentAddress('444-44-4444').join().get(); // Address</pre>
  224: Because the composition in listing 5.4 returns a set of nested wrappers, the join oper- ation is used to flatten out the structure into a single layer, as in this example:
  225  <pre>Wrapper.of(Wrapper.of(Wrapper.of('Get Functional'))).join();
  226  //-> Wrapper('Get Functional')</pre>
  ...
  229   
  230  <p className="pag">Page 132</p>
  231: With regard to arrays (which are also containers that can be mapped to), this is analo- gous to the R.flatten operation:
  232  <pre>R.flatten([1, 2,	[3, 4], 5,	[6,	[7, 8,	[9,	[10, 11], 12]]]]);
  233  //=>	[1, 2, 3, 4, 5, 6, 7, 8,	9, 10, 11, 12]</pre>
  234: Monads typically have many more operations that support their specific behavior, and this minimal interface is merely a subset of its entire API. A monad itself, though, is abstract and lacks any real meaning. Only when implemented as a concrete type does its power begins to shine. Fortunately, most functional programming code can be implemented with just a few popular concrete types, which eliminates lots of boiler- plate code while achieving an immense amount of work. Now, let’s look at some full- fledged monads: Maybe, Either, and IO.
  235  5.3.2	Error handling with Maybe and Either monads
  236  In addition to wrapping valid values, monadic structures can also be used to model the absence of one—as null or undefined. Functional programming reifies errors (turns them into a “thing”) by using the Maybe and Either types to do the following:
  ...
  250   
  251  <p className="pag">Page 134</p>
  252: Maybe explicitly abstracts working with “nullable” values (null and undefined) so you’re free to worry about more important things. As you can see, Maybe is basically an abstract umbrella object for the concrete monadic structures Just and Nothing, each containing its own implementations of the monadic properties. I mentioned earlier that the implementation for the behavior of the monadic operations ultimately depends on the semantics imparted by a concrete type. For instance, map behaves dif- ferently depending on whether the type is a Nothing or a Just. Visually, a Maybe struc- ture can store a student object as shown in figure 5.8:
  253  // findStudent :: String -> Maybe(Student) function findStudent(ssn)
  254   
  255  Figure 5.8 A Maybe structure has two subtypes: Just and Nothing. Calling findStudent returns its value wrapped in Just or the absence of a value in Nothing.
  256: This monad is frequently used with calls that contain uncertainty: querying a database, looking up values in a collection, requesting data from the server, and so on. Let’s con- tinue with the example started in listing 5.4 of extracting the address property of a stu- dent object that’s fetched from a local store. Because a record may or may not exist, you wrap the result of the fetch in a Maybe and add the safe prefix to these operations:
  257  <pre>// safeFindObject :: DB -> String -> Maybe const safeFindObject = R.curry(function(db, id) { return Maybe.fromNullable(find(db, id));
  258  });</pre>
  ...
  262  const safeFindStudent = safeFindObject(DB('student'));
  263  const address = safeFindStudent('444-44-4444').map(R.prop('address')); address; //-> Just(Address(...)) or Nothing</pre>
  264: Another benefit of wrapping results with monads is that it embellishes the function sig- nature, making it self-documented and honest about the uncertainty of its return value. Maybe.fromNullable is useful because it handles the null-checking on your behalf. Calling safeFindStudent will produce a Just(Address(...)) if it encounters a valid value or a Nothing otherwise. Mapping R.prop over the monad behaves as expected. In addition, it does a good job of detecting programmatic errors or misuses of an API call: you can use it to enforce preconditions indicating whether parameters are permitted to be invalid. If an invalid value is passed into Maybe.fromNullable, it produces a Nothing type, such that calling get() to open the container will throw an exception:
  265  <pre>TypeError: Can't extract the value of a Nothing.</pre>
  266: Monads expect you to stick to mapping functions over them instead of directly extracting their contents. Another useful operation of Maybe is getOrElse as an alter- native to returning default values. Consider the example of setting the value of a form field, or a generic default in case there’s no data to set:
  267  <pre>const userName = findStudent('444-44-4444').map(R.prop('firstname'));
  268  document.querySelector('#student-firstname').value = username.getOrElse('Enter first name');</pre>
  269  If the fetch operation is successful, the student’s username is displayed; otherwise, the else branch executes printing the default string.
  270  Maybe in disguise
  271: You may see Maybe appear in different forms such as the Optional or Option type, used in languages like Java 8 and Scala. Instead of Just and Nothing, these lan- guages declare Some and None. Semantically, though, they do the same things.
  272  Now let’s revisit the pessimistic null-check anti-pattern shown earlier that rears its ugly head frequently in object-oriented software. Consider the getCountry function:
  273  <pre>function getCountry(student) { let school = student.school(); if(school !== null) {
  ...
  279  }</pre>
  280  <p className="pag">Page 136</p>
  281: What a drag. If the function returns 'Country does not exist!', which statement caused the failure? In this code, it’s hard to discern which line is the problematic one. When you write code like this, you aren’t paying attention to style and correct- ness; you’re defensively patching function calls. Without monadic traits, you’re basi- cally stuck with nuli checks sprinkled all over the place to prevent TypeError exceptions. The Maybe structure encapsulates this behavior in a reusable manner. Consider this example:
  282  <pre>const country = R.compose(getCountry, safeFindStudent);</pre>
  283  Because safeFindStudent returns a wrapped student object, you can eliminate this defensive programming habit and safely propagate the invalid value. Here’s the new getCountry:
  ...
  287  <pre>const safeFindObject = R.curry(function(db, id) { return Maybe.fromNullable(find(db, id));
  288  });</pre>
  289: Notice that its name is prefixed with safe and it uses a monad directly to wrap its return value. This is a good practice because you make it clear to the caller that the function is housing a potentially dangerous value. Does this mean you need to instru- ment every function in your program with monads? Not necessarily. A technique called function lifting can transform any ordinary function into a function that works on a container, making it “safe.” It can be a handy utility so that you aren't obligated to change your existing implementations:
  290  <pre>const lift = R.curry(function (f, value) { return Maybe.fromNullable(value).map(f);
  291  });</pre>
  ...
  305  <li className="litag">	Left(a) —Contains a possible error message or throwable exception object</li>
  306  <li className="litag">	Right(b) —Contains a successful value</li>
  307: Either is typically implemented with a bias on the right operand, which means map- ping a function over a container is always performed on the Right(b) subtype. It’s analogous to the Just branch of Maybe.
  308  A common use of Either is to hold the results of a computation that may fail to provide additional information as to what the failure is. In unrecoverable cases, the left can contain the proper exception object to throw. The following listing shows the implementation of the Either monad.
  309  Listing 5.6 Either monad with Left and Right subclasses
  ...
  320  Now, let’s put Either to use. This monad offers another alternative for the safeFindObject function:
  321  <p className="pag">Page 140</p>
  322: Let’s pause for a second. You may be wondering, “Why not use the 2-tuple (or a Pair) type discussed in chapter 4 to capture the object and a message?” There’s a subtle rea- son. Tuples represent what’s known as a product type, which implies a logicai AND rela- tionship among its operands. In the case of error handling, it’s more appropriate to use mutually exclusive types to model the case of a value either existing OR not; in the case of error handling, both could not exist simultaneously.
  323  With Either, you can extract the result by calling getOrElse (providing a suitable default just in case):
  324  <pre>const findStudent = safeFindObject(DB('student'));
  ...
  329  This prints to the console:
  330  <pre>MyErrorLogger [ERROR] Student not found with ID: 444-44-4444</pre>
  331: The Either structure can also be used to guard your code against unpredictable func- tions (implemented by you or someone else) that may throw exceptions. This makes your functions more type-safe and side effect-free by eliminating the exception early on instead of propagating it. Consider an example using JavaScript’s decodeURI- Component function, which can produce a URI error if it’s invalidi
  332: As shown in this code, it’s also customary to populate Either.Left with an error object that contains stack trace information as well as an error message; this object can be thrown if necessary to signal an unrecoverable operation. Suppose you want to nav- igate to a given URL that needs to be decoded first. Here’s the function invoked with invalid and valid input:
  333   
  334  
  ...
  341  return Either.Left(uriError);
  342  }</pre>
  343: Now you’ve learned how monads help emulate a try-catch mechanism that contains potentially hazardous function calls. Scala implements a similar notion using a type called Try—the functional alternative to try-catch. Although not fully a monad, Try represents a computation they may either result in an exception or return a fully com- puted value. It’s semantically equivalent to Either, and it involves two cases classes for Success and Failure.
  344  Functional programming projects worth exploring
  345: Most of the topics explored in this and the previous chapter, such as partial applica- tion, tuples, composition, functors, and monads, as well as other topics presented later, are implemented as modules in a formal specification called Fantasy Land (https://github.com/fantasyland). Fantasy Land is a reference implementation of functional concepts that defines how to implement a functional algebra in JavaScript. We've been using libraries like Lodash and Ramda for their ease of use; neverthe- less, Fantasy Land and a functional library called Folktale (http://folktalejs.org/) are worth exploring if you're eager to get deep into more-functional data types.
  346  Monads can help you cope with uncertainty and possibilities for failure in real-world software. But how do you interact with the outside world?
  347  5.3.3	Interacting with external resources using the IO monad
  348  Haskell is believed to be the only programming language that relies heavily on monads for IO operations: file read/writes, writing to the screen, and so on. You can translate that to JavaScript with code that looks like this:
  349  <pre>IO.of('An unsafe operation').map(alert);</pre>
  350: Although this is a simple example, you can see intricacies of IO tucked into lazy monadic operations that are passed to the platform to execute (in this case, a simple alert message). But JavaScript unavoidably needs to be able to interact with the ever- changing, shared, stateful DOM. As a result, any operation performed on the DOM,
  351  Paga 142
  352  whether read or write, causes side effects and violates referential transparency. Let’s begin with most basic IO operations:
  353: When executed independently, the output of these standalone functions can never be guaranteed. Not only does order of execution matter, but, for instance, calling read multiple times can yield different responses if the DOM was modified between calls by another call to write. Remember, the main reason for isolating impure behavior from pure code, as you did in chapter 4 with showStudent, is to always guarantee a consis- tent result.
  354  You can’t avoid mutations or fix the problem with side effects, but you can at least work with IO operations as if they were immutable from the application point of view. This can be done by lifting IO operations into monadic chains and letting the monad drive the flow of data. To do so, you can use the IO monad.
  355  Listing 5.7 IO monad
  ...
  358   
  359  <p className="pag">Page 143</p>
  360: This monad works differently than the others, because it wraps an effect function instead of a value; remember, a function can be thought of as a lazy value, if you will, waiting to be computed. With this monad, you can chain together any DOM opera- tions to be executed in a single “pseudo” referentially transparent operation and ensure that side effect-causing functions don’t run out of order or between calls.
  361  Before I show you this, let’s refactor read and write as manually curried functions:
  362  <pre>const read = function (document, id) { return function ()	{
  ...
  368  };
  369  };</pre>
  370: And in order to avoid passing the document object around, make life easier and par- tially apply it to these functions:
  371  const readDom = _.partial(read, document); const writeDom = _.partial(write, document);
  372  With this change, both readDom and writeDom become chainable (and composable) functions awaiting execution. You do this in order to chain these IO operations together later. Consider a simple example that reads a student’s name from an HTML element and changes it to start-case (capitalize the first letter of each word):
  373: Writing to the DOM, the last operation in the chain, isn’t pure. So what do you expect the changeToStartCase output to be? The nice thing about using monads is that you preserve the requirements imposed by pure functions. Just like any other monad, the output from map is the monad itself, an instance of IO, which means at this stage noth- ing has been executed yet. What you have here is a declarative description of an IO operation. Finally, let’s run this code:
  374  <pre>changeToStartCase.run();</pre>
  375   
  ...
  379  Inspecting the DOM, you’ll see this:
  380  <pre><div id="student-name">Alonzo Church</div></pre>
  381: There you have it: IO operations in a referentially transparent-ish way! The most important benefit of the IO monad is that it clearly separates the pure and impure parts. As you can see in the definition of changeToStartCase, the transformation functions that map over the IO container are completely isolated from the logic of reading and writing to the DOM. You can transform the contents of the HTML ele- ment as needed. Also, because it all executes in one shot, you guarantee that noth- ing else will happen between the read and write operations, which can lead to unpredictable results.
  382: Monads are nothing more than chainable expressions or chainable computa- tions. This allows you to build sequences that apply additional processing at each step—like a conveyor belt in an assembly line. But chaining operations isn’t the only modality where monads are used. Using monadic containers as return types creates consistent, type-safe return values for functions and preserves referential transpar- ency. Recall from chapter 4 that this satisfies the requirement for composing func- tion chains and compositions.
  383  5.4	Monadic chains and compositions
  384  As you can see, monads bring the world of side effects under control, so you can use them in composable structures. As you know from chapter 4, compositionality is the trick to reducing complexity in your code. But in chapter 4, you hadn’t bothered to check for invalid data: if findStudent had returned null, the entire program would have failed, as shown in figure 5.10.
  385  Figure 5.10 Functions findStudent and append are being composed. Without the proper checks, if the former produces a null return value, the latter will fail with a TypeError exception.
  386: Fortunately, with little code, monads can also be made composable so that you can enjoy their fluent, expressive error-handling mechanism to create safe composi- tions. Wouldn’t it be nice if functions arranged in a pipeline gracefully sidestepped null mines?
  387  As you can see in figure 5.11, the first step is to make sure the first function to be executed wraps its result in a proper monad: both Maybe and Either work in this case.
  388   
  ...
  390   
  391  Figure 5.11 Same two functions as in figure 5.10; but this time the nuli value travels in a monad (Either or Maybe), which causes the rest of the functions in the pipeline to gracefully fail.
  392: As you know, there are two variations for combining functions in functional program- ming: chain and compose. Recall that showStudent from the previous chapter had three parts:
  393  1	Normalize user input
  394  2	Find the student record
  395  3	Add the student information to the HTML page
  396: You’re also adding input validation to the mix to make it even more complex. Hence, this program has two points of failure: a validation error and an unsuccessful student- fetch operation. You can refactor them to include the Either monad to supply appro- priate error messages, as shown next.
  397  Listing 5.8 Refactoring functions to use Either
  398   
  ...
  417   
  418  <p className="pag">Page 147</p>
  419: work across any monad type (following from the Liskov Substitution Principle). In particular, you can create generalized map and chain functions, shown in the follow- ing listing.
  420  Listing 5.10 General map and chain functions that work on any container
  421  <pre>// map ::	(ObjectA -> ObjectB), Monad -> Monad[ObjectB]
  ...
  425  const chain = R.curry(function (f, container) { return container.chain(f);
  426  });</pre>
  427: You can use these functions to inject monads into a compose expression. The code in listing 5.11 produces the same results as listing 5.9. Because monads control how data flows from one expression to the next, this style of coding is also known as pro- grammable commas, which is also point-free. In this case, a comma is used to delimit one expression from another in the same way a semicolon traditionally delineates one statement from the next in JavaScript. Also, using lots of trace statements lets you see the data flowing through the operations (logging statements are useful for debug- ging, as well).
  428  Listing 5.11 Monads as programmable commas
  429  <pre>const showStudent = R.compose(
  ...
  442  <p className="pag">Page 148</p>
  443  Tracing through programs
  444: Listing 5.11 demonstrates how easy it is to trace through functional code. Without having to drill into the body of those functions, you can demarcate an entire program with tracing statements that execute before and after function calls, which is incred- ibly useful for troubleshooting and debugging. If this program were written in an object-oriented style, you couldn’t possibly do this without having to modify the actual functions or perhaps instrument them using aspect-oriented programming, which isn’t a trivial endeavor. Functional programming gives you this for free!
  445: Finally, let’s diagram this entire flow to clearly see what’s going on; see figure 5.12. Fig- ure 5.13 shows the behavior of this same program in the event that findStudent is unsuccessful.
  446   
  447  Figure 5.12 Step-by-step flow of the showStudent function in the case where findStudent successfully finds a student object by the provided SSN
  ...
  488  This chapter completes part 2 of the book. Your developer toolbox is equipped with all the functional concepts you need to take on real-world solutions.
  489  5.5	Summary
  490: <li className="litag">	Exception-throwing mechanisms in object-oriented code result in impure func- tions that impose a great deal of responsibility on the caller to provide adequate try-catch logic.</li>
  491  <li className="litag">	The pattern of value containerization is used to create side effect-free code by wrapping possible mutations under a single referentially transparent process.</li>
  492  <li className="litag">	Use functors to map functions to containers in order to access and modify objects in a side effect-free and immutable manner.</li>
  493: <li className="litag">	Monads are a functional programming design pattern used to reduce an appli- cation’s complexity by orchestrating a secure flow of data through functions.</li>
  494  <li className="litag">	Resilient and robust function compositions interleave monadic types such as Maybe, Either, and IO.</li>
  495  

C:\Users\Emanuela\FunctionalP\pages\Chapter 6 - Bulletproofing your code.js:
    1: <p className="pag">Page 153 - Chapter 6 - Bulletproofing your code</p>
    2  This chapter covers
    3  <li className="litag">	How functional programming affects program testing</li>
    .
    8  Good fences make good neighbors
    9  —Robert Frost, “Mending Wall”
   10: Welcome to part 3 of this book. Having read parts 1 and 2, you’ll have noticed a central theme: functional programming makes your code easier to understand, read, and maintain. You can even say its declarative nature makes your code self- documented.
   11: Now that you’ve written functional code, how do you prove that it works? In other words, how do you ensure that it meets the specifications laid out by your cus- tomers? The only way is to write code that tests whether the resulting behavior is as
   12  
   13  <p className="pag">Page 154</p>
   14  expected. Thinking functionally has a deep impact on application-level code and, through it, directly influences the way you design your tests.
   15: You create unit tests to ensure that code meets a problem specification and builds fences around all possible boundary conditions that may cause it to fail. I assume you’ve written unit tests before; you’ve likely experienced that testing imperative pro- grams can be a daunting effort, especially in large code bases. Due to side effects, imperative code is susceptible to errors originating from false assumptions about the global state of the system. Likewise, tests can’t run independently of others, as they should, making it difficult to guarantee consistent results regardless of the order in which they’re called. This is unfortunate and is the main reason testing is often left until the end or, in most cases, skipped.
   16: In this chapter, we’ll look at why functional code is by definition inherently test- able, whereas in most other paradigms, you must intentionally design your code to make it easy to test. Most of the best practices associated with proper testing—elimi- nating external dependencies, making functions predictable, and others—are core principles embedded in functional design. Pure, referentially transparent functions have this quality built into them for free and lend themselves to a more advanced method such as property-based testing. Before we begin, let’s take a moment to understand the influence FP has on the different types of tests and focus on where it will help you be the most productive: unit tests.
   17  6.1	Functional programming’s influence on unit tests
   18: Generally, there are three testing categories: unit tests, integration tests, and accep- tance tests. The testing pyramid in figure 6.1 shows that the influence of FP on your code is greater as you move from acceptance tests (top) to unit tests (bottom). This is evident because functional programming is a software-development paradigm that focuses on the design of functions and modules as well as the integration among its constituent parts.
   19  Figure 6.1 Because functional programming is a software paradigm with focus on code, its influence mostly impacts the design of unit tests, with little effect on integration tests. It’s completely agnostic to acceptance testing.
   20   
   ..
   29  assert.equal(p.ssn, ssn);
   30  });</pre>
   31: The test code lives in a JavaScript file that’s not part of the main application code but imports all the functions that will be tested. Unit testing imperative programs is extremely challenging due to the presence of side effects and mutations. Let’s exam- ine some of the downfalls of testing imperative code.
   32  6.2	Challenges of testing imperative programs
   33: Imperative tests suffer from the same challenges as imperative code. Because impera- tive code is based on global state and mutations, rather than contained data flow and joined computations, testing is a real challenge. One of the main principles to follow when designing unit tests is isolation. A unit test should run as if in a vacuum and igno- rant of any other data or tests around it; but side effects in the code severely limit the extent to which you can test functions.
   34  Imperative code is
   35  <li className="litag">	Difficult to identify and decompose into simple tasks</li>
   ..
   38  Let’s examine some of these challenges more closely.
   39  6.2.1	Difficulty identifying and decomposing tasks
   40: Unit tests are designed to test the smallest parts of your application. In procedural programs, it’s much harder to identify the units of modularity because there’s no intui- tive way to slice the different sections of a single, monolithic program that wasn’t
   41  <p className="pag">Page 156</p>
   42: designed with that mindset to begin with. In this case, the units are functions that encapsulate your business logic. For example, recali the imperative version of show- Student that you’ve been working on throughout the book. Figure 6.2 shows a good attempt to slice it into its constituent parts.
   43  Figure 6.2 The functional sections of the monolithic function showStudent. To simplify writing tests, these sections should be split into separate functions that deal with validation, IO, and error handling.
   44: As you can see, this program is made up of tightly coupled business logic that’s con- cerned with different aspects of a program, all in a single monolithic function. But there’s no real reason to couple data validation with fetching student records and appending elements to the DOM; those can be separate testable business units that are assembled via composition. In addition, as you learned in chapter 5, you should factor out error-handling logic and allow monads to handle it.
   45  Monads and error handling
   46: In chapter 5, you learned about a few design patterns that you can apply to consoli- date and remove error-handling code from your main functions while still keeping them fault-tolerant. By using the monads Maybe and Either, you can write point-free code that knows how to properly propagate errors through the components while mak- ing sure your program remains responsive.
   47   
   48  <p className="pag">Page 157</p>
   ..
   60  <p className="pag">Page 158</p>
   61  6.2.3	Predefined order of execution
   62: Along the same lines as consistency, unit tests should be designed to be commutative, which means changing the order in which they run shouldn’t affect their outcome. For the same reasons as before, this principle doesn’t work with impure functions. To work around this problem, unit testing libraries like QUnit contain out-of-the-box mechanisms to set up and tear down the global testing environment in order for sub- sequent tests to run; but the setup of one test may be completely different than another, so you’re forced to set up preconditions at the beginning of each test. This also implies that for each test, you’re responsible for identifying all the side effects (external dependencies) of the code under test.
   63  To illustrate, let’s create simple tests around increment to verify its behavior against negative numbers, zero, and positive numbers (see figure 6.4). In the first run (left), all tests pass. Shuffling the order of the tests (right), with no additional changes, causes the second test to fail. This is because tests with side effects run based on the assumption that you’ve adequately set up the surrounding state.
   64   
   65  Incorrectly assuming a preexisting state causes the failure.
   66  Figure 6.4 Falsely making assumptions about the global state of the system causes simple tests to fail. The left side shows that all tests executed perfectly, because each test correctly prepared its surrounding state before executing. But shuffling the tests (right) invalidates all assumptions about the state.
   67: As you can see from this simple exercise, even if you manage to successfully run multi- ple unit tests for a particular function by manipulating the global context within each test, you can’t guarantee they’ll work if you move them around. A simple shift in sequence is enough to invalidate all your assertions.
   68: Thinking functionally can also help you build reliable test suites. And if your code is written in a functional style, you’ll get this for free. Instead of hopelessly shoehorn- ing functional principles into your test code, why not write functionally from the beginning and recover the invested time in the test phase? Let’s look at the benefits of functional code for testing.
   69  <p className="pag">Page 159</p>
   70  6.3	Testing functional code
   71: Whether you’re testing imperative or functional code, many of the best practices sur- rounding the development of unit tests, such as isolation, predictability, and repeat- ability, are reciprocated in FP. Because every function clearly defines all of its input parameters, it’s straightforward to supply multiple sets of boundary conditions to per- form a thorough examination of all paths in your code. With respect to side effects, recall from previous chapters that all of the functions are simple and clearly defined, and all of the impure code can be safely wrapped in monads.
   72: In addition, the impurity found in manual looping constructs has also been addressed by ceding control to higher-order operations like map, reduce, filter, and recursion, as well as using functional libraries that are side effect-free. These tech- niques and design patterns allow you to effectively abstract the complexity of your code so that you can test more productively and worry only about the main pieces of your business logic. This section discusses benefits of testing functional code, includ- ing the following:
   73  <li className="litag">	Treating a function as a black box</li>
   74  <li className="litag">	Focusing on business logic instead of control flow</li>
   ..
   76  <li className="litag">	Mocking external dependencies</li>
   77  6.3.1	Treating a function as a black box
   78: Functional programming encourages you to write independent functions that know how to work on a set of inputs in a loosely coupled manner, regardless of the rest of the application. These functions are also side effect-free and referentially transpar- ent, which results in predictable test runs whose outcome is the same regardless of how many times they’re invoked and in what order. This allows you to treat a function as a black box and only focus on the inputs that assert the corresponding outputs. Testing a function like showStudent, for example, requires the same level of effort as testing the functional increment function shown in figure 6.5.
   79   
   80  Can be run in any order.
   81  Figure 6.5 Tests against the functional increment function, which can be repeated or run in a different order without altering their outcome
   82  160
   83: Recali from chapter 1 that declaring all function parameters explicitly in the function signature makes functions more configurable. This simplifies testing significantly because nothing is hidden from the caller at the moment of supplying proper argu- ments and creating expectations of what the functions are supposed to do. Simple functions typically declare one or two parameters that are put together via composi- tion to create richer functions.
   84  6.3.2	Focusing on business logic instead of control flow
   85: The theme of decomposing tasks into simple functions has been a pattern throughout this book. I mentioned in chapter 1 that when writing functional code, you’ll spend most of your time decomposing your problem into smaller parts. This is the challeng- ing step; the rest of the time is spent gluing them together. Fortunately, libraries like Lodash and Ramda fill in the functional gaps in the JavaScript by providing glue points with functions like curry and compose. Together with the functional combina- tore you learned about in section 4.6, the upfront time spent designing and decom- posing is given back to you in the testing phase. Your only responsibility is to test the individual functions that make up the main logic of your program. As an example, let’s begin writing some tests for the functional version of computeAverageGrade (here’s the code again for quick reference).
   86  Listing 6.1 Testing the computeAverageGrade program
   87  <pre>const fork = function(join, funcl, func2){ return function(val) {
   ..
  100  assert.equal(toLetterGrade(90), 'A'); assert.equal(toLetterGrade(200),'A'); assert.equal(toLetterGrade(80), 'B'); assert.equal(toLetterGrade(89), 'B'); assert.equal(toLetterGrade(70), 'C'); assert.equal(toLetterGrade(60), 'D'); assert.equal(toLetterGrade(59), 'F'); assert.equal(toLetterGrade(-10),'F');
  101  });</pre>
  102: Because toLetterGrade is pure, you can run it several times against different inputs to test many of its boundary conditions. Because it’s referentially transparent, you can also shift the order of these test cases without altering the result of the test. Later, you’ll learn an automated way of generating proper sample input; but for now, you’ll do this manually to see that the function works correctly against a comprehensive set of input. Now that all the individual pieces of the program have been tested, you can safely assume the program as a whole works, because it’s driven by the power of com- position and functional combinators.
  103: Along the same lines, what about fork? Functional combinators don’t require much testing, because they contain no business logic other than orchestrating func- tion calls in your application’s control flow. Recall from section 4.6 that combinators are useful for substituting standard control artifacts like if-else (alternation) and loops (sequence).
  104  Some libraries implement combinators out of the box, like R.tap; but when using custom ones (like fork), you can test them independent of the rest of the application and apart from the business logic. For the sake of completeness, let’s write a quick test for fork that showcases another good use of R.identity:
  105  <pre>QUnit.test('Functional Combinator: fork', function (assert) {
  106  const timesTwo = fork((x) => x + x, R.identity, R.identity); assert.equal(timesTwo(1), 2); assert.equal(timesTwo(2), 4);
  107  });</pre>
  108: Again, testing with a simple function is sufficient, because combinators are completely agnostic when it comes to the arguments provided. Using functional libraries, compo- sition, and combinators makes development and testing trivial; but things can get messy when you’re dealing with impure behavior.
  109  6.3.3	Separating the pure from the impure with monadic isolatimi
  110  In previous chapters, you learned that most programs have pure and impure parts. This is especially true in client-side JavaScript, because interacting with the DOM is
  111  PAGE 162
  112  what the language was meant for. On the server, you’ll have other requirements such as reading from a database or file. You learned how to use composition to combine the pure and impure functions that make up your programs. But this still made them impure; you relied on the IO monad to push the line of purity even further away so that you could obtain referential transparency from the application’s perspective, making it more declarative and easier to reason about. In addition to IO, you used other monads like Maybe and Either to create a surefire way to run programs that are still responsive in the event of failure. With all these techniques, you can control most side effects. But when your JavaScript code needs to read and write to the DOM, how can you guarantee that your tests remain isolated and repeatable?
  113: Recall that the nonfunctional version of showStudent makes no effort to separate its impure parts: it’s all mixed together, so it will run as a whole on each and every test. This is utterly inefficient and unproductive because you would need to run the entire program every time even when you only wanted to validate, say, that db.get(ssn) worked with different combinations of Social Security numbers. Another disadvantage is that you can’t test it thoroughly because all statements are tightly coupled. For instance, the first block of code will exit the function early with an exception and pre- vent you from testing db.get(ssn) against invalid input.
  114  On the other hand, functional programming is aimed at reducing the involvement of operations that cause side effects (like IO) to minimal functions (simple reads and writes) so that you can increase the testable scope of your application logic while decoupling the boundaries of IO testing you aren’t responsible for. Let’s revisit the functional version of showStudent:
  115  <pre>const showStudent = R.compose( map(append('#student-info')), liftIO, map(csv),
  ...
  119  lift(cleanInput));</pre>
  120  Looking closely at both programs, you can see how the functional version is essentially taking the imperative version apart and bolting it together with composition and monads. As a result, you dramatically increase the testable scope of showStudent and clearly recognize and isolate the pure functions from the impure (see figure 6.6).
  121: Let’s analyze the testability of the components of showStudent. Of the five func- tions, only three can be tested reliably: cleanInput, checkLengthSsn, and csv. Although findStudent has side effects when reading data from external resources, you’ll see ways to get around this in a later section. The remaining function, append, has no real business logic because it’s been reduced to appending to the DOM whatever data is given to it. It’s not in your best interest, and it isn’t the best use of your time, to test DOM APIs; leave that to browser manufacturers. With functional programming, you can take a hard-to-test program and split it into highly testable pieces.
  122  <p className="pag">Page 163</p>
  123  Figure 6.6 Identifying the testable areas of the showStudent program. The components that perform IO are impure and can’t be tested reliably because they contain side effects. Other than having impure parts, the scope of the entire program remains highly testable.
  ...
  132  You have one last function to test: findStudent. This function originates from the impure safeFindObject, which queries an external object storage to look up student records. But the side effects in this function are manageable by using a technique called mock objects.
  133  6.3.4	Mocking external dependencies
  134: Mocking is a popular testing technique used to simulate the behavior of a function’s external dependencies in a controlled, assertable manner, so it’s good for dealing with some types of side effects. Mock objects will cause your test to fail if its expectations aren’t met. They’re like programmable dummy methods (or stubs) that you can use to define up front the expected behavior of an object that interact with your func- tions. In this case, mocking the call to the DB object gives you complete control over this external resource in order to create more predictable and consistent tests. For this task, you’ll use a QUnit mock plug-in called Sinon.JS (see the appendix for details on how to set up this plug-in).
  135  Sinon.JS enhances the test environment with a sinon object used to create mock versions of any object, all accessible in a mock context. In this case, you populate the context with the DB object, which will serve as the acting stub for this dependency:
  136  <pre>const studentDb = DB('students');
  ...
  140   
  141  <p className="pag">Page 165</p>
  142: Figure 6.7 shows the result of running the tests with QUnit and Sinon.JS for the test- able parts of showStudent.
  143   
  144  Figure 6.7 Execution of all unit tests for the showStudent program. Tests 3 and 4 use QUnit with Sinon.JS because they require mocked dependencies to simulate the functionality of fetching a student record.
  145   
  146  <p className="pag">Page 166</p>
  147: The fact that functional code is orders of magnitude more testable than imperative code boils down to one principle: referential transparency. The essence of an asser- tion is verifying that referential transparency always holds:
  148  assert.equal(computeAverageGrade([80, 90, 100]),	'A');
  149  There’s a lot more to referential transparency than meets the eye. This concept can extend into other realms of software development, such as program specifications. After all, the sole purpose of tests is to verify that the specifications of the system are met.
  ...
  164  <li className="litag">	“If the student’s average is 90 or above, the student is awarded an A.”</li>
  165  <li className="litag">	“Only an average of 90 or above will award the student an A.”</li>
  166: By removing the imperative-case clauses, the second statement is much more com- plete. Not only does it express what happens when the student reaches 90 or above, but it also places the restriction that no other numerical range will result in an A. You can derive from the second statement that, at the least, any other computed
  167  <p className="pag">Page 167</p>
  168  average won’t result in the student being awarded an A, which you couldn’t intuit from the first.
  169: Universal requirements are much easier to work with, because they aren’t depen- dent on the status of the system at any point in time. For this reason, like unit tests, good specifications don’t have side effects or make assumptions about their surround- ing context.
  170: Referentially transparent specifications increase our understanding of what func- tions are supposed to do and give us a clear picture of the input conditions they must satisfy. Because referentially transparent functions are consistent and have clear input parameters, they lend themselves to being easily tested with automated mechanisms that can push them to the limit. This brings us into a much more compelling testing modality called property-based testing. A property-based test makes a statement about what the output of a function should be when executed against a definite set of inputs. The canonical framework or reference implementation is Haskell’s QuickCheck.
  171  QuickCheck: Property-based test for Haskell
  172: QuickCheck is a Haskell library for randomized property-based testing of a program's specification or properties. You design a specification of a pure program in the form of properties the program should fulfill, and QuickCheck generates a large permuta- tion of test cases against your program and produces a report. You can find more information at https://hackage.haskell.org/package/QuickCheck.
  173: By the same token, JavaScript emulates QuickCheck with a library called JSCheck (see the appendix for setup information), by none other than Douglas Crockford,1 author of JavaScript: The Good Parts (O’Reilly, 2008). JSCheck can be used to create a technical response to a matching referentially transparent specification of a function or pro- gram. Hence, proving the properties of a function is done by generating a large num- ber of random test cases aimed at rigorously exercising all possible output paths of your function.
  174: Also, property-based tests control and manage the evolution of your program as it’s being refactored to ensure that new code doesn’t introduce unintentional bugs into the system. The main advantage of using a tool like JSCheck is that its algorithm gener- ates abnormal datasets to test with. Some of the edge cases it generates would most likely be overlooked if you had to manually write them.
  175  The JSCheck module is nicely encapsulated into a global JSC object:
  176  <pre>JSC.claim(name, predicate, specifiers, classifier)</pre>
  ...
  180  <li className="litag">	Name—Description of the claim (similar to QUnit’s test description).</li>
  181  <li className="litag">	Predicate—Function that returns a verdict of true when the claim is satisfied or false otherwise.</li>
  182: <li className="litag">	Specifiers—Array describing the type of the input parameters and the specifica- tion with which to generate random datasets.</li>
  183  <li className="litag">	Classifier (optional)—Function associated with each test case that can be used to reject non-applicable cases</li>
  184: Claims are passed into JSCheck.check to run random test cases. This library wraps creating a claim and feeding it into the engine in a single call to JSCheck.test, so you’ll use this shortcut method in the example tests. Let’s look at an example of writ- ing a simple JSCheck specification for computeAverageGrade that captures the follow- ing specification: “Only an average of 90 or above will award the student an A.”
  185  Listing 6.4 Property-based test for computeAverageGrade
  186   
  ...
  230  Running QUnit with JSCheck flags failures as expected. Figure 6.9 shows the output of a single failure, for brevity.
  231  Figure 6.9 A failure detected as a result of an invalid property check with QUnit. When you randomize the input to include invalid inputs, the JSCheck algorithm has enough entropy that 89 of 90 tests fail.
  232: Where did JSC.SSN come from? JSCheck specifiers behave just like functional combi- nators that can be composed to create more-specialized specifiers. This case uses a custom JSC.SSN made from the combination of three JSC.integer specifiers describ- ing the properties of each SSN group, as shown next.
  233   
  234  <p className="pag">Page 172</p>
  ...
  236  JSCheck works only with pure programs, which means you can’t test the showStudent program entirely, but you can use it to test each component in isolation. I leave that to you as an exercise. Property-based testing is compelling because it exercises functions to the limit. Its best quality, in my opinion, is that it can be used to verify whether code is indeed referentially transparent, because it’s expected to work consistently against the same contract and verdict. But why submit your code to such a heavy procedure? The answer is simple: to make your tests effective.
  237  6.5	Measuring effectiveness through code coverage
  238: Measuring a unit test’s effectiveness is an arduous task if not done with the proper tools in place, because it involves studying the test’s code coverage through the func- tions under test. Getting coverage information involves traversing all unique paths belonging to a program’s control flow; one way to achieve this is by studying the flow of code against a function’s boundary conditions.
  239  Certainly, code coverage alone isn’t an indicator of quality, but it does describe the degree to which your functions are tested, which correlates to better quality. Would you want code that’s never seen the light of day deployed to production? I didn’t think so.
  240: Code-coverage analysis can find areas in your code that haven’t been tested, allow- ing you to create additional tests to uncover them. Normally, this includes code for error handling that you let slip through the cracks and forget to come back to. You can use code coverage to measure the percentage of lines of code that are executed when invoking a program via unit tests. To compute this information, you can use a library called Blanket.js, which is a code-coverage tool for JavaScript. It’s designed to
  241   
  242  <p className="pag">Page 173</p>
  ...
  245  2	Instrument the code by adding tracker lines
  246  3	Connect the hooks in the test runner to output coverage details
  247: Blanket collects coverage information with the help of an instrumentation phase during which it captures meta-information regarding statement execution, which you can display nicely in a QUnit report. Details for setting up Blanket can be found in the appendix. You can instrument any JavaScript module or program via the cus- tom data-covered attribute in the script include line. By analyzing the statement- coverage percentage, you can see that functional code is much more testable than imperative code.
  248  6.5.1	Measuring the effectiveness of testing functional code
  249: Throughout this chapter, you’ve seen that functional programs are more testable due to the ease with which tasks can be broken apart to become atomic, verifiable unite. But don’t take my word for it; you can measure it empirically by performing a state- ment-by-statement percentage-coverage analysis on the showStudent program. First, let’s look at the simplest test case: a positive test.
  250  MEASURING EFFECTIVENESS OF IMPERATIVE AND FUNCTIONAL CODE WITH VALID INPUTS
  251: First let’s look at code-coverage statistics against a successful run of the imperative ver- sion of showStudent, shown in listing 6.2. Using Blanket with QUnit, mark this pro- gram to be instrumented:
  252  <pre><script src="imperative-show-student-program.js" data-cover></script></pre>
  253  Now, running the following test
  254  <pre>QUnit.test('Imperative showStudent with valid user', function (assert) { const result = showStudent('444-44-4444'); assert.equal(result, '444-44-4444, Alonzo, Church');
  255  });</pre>
  256: produces an 80% total statement-coverage percentage, as shown in the QUnit/Blan- ket output in figure 6.10.
  257  This shouldn’t surprise you, because the error-handling code was all skipped. For imperative programs, 75-80% code coverage is considered to be very good. What you can take from this run is that 80% is the best coverage you can get with a single unit test execution. On the other hand, let’s instrument and run a positive test against the functional version:
  258  <pre><script src="functional-show-student-program.js" data-cover></script></pre>
  ...
  261  Again, running the “happy path” test runs the program with a valid SSN, but this time producing a whopping figure of 100% coverage (see figure 6.11)!
  262  Figure 6.11 A positive unit test against the functional showStudent generates a 100% line-percentage coverage. Every line of the testable business logic is executed!
  263: But wait: if the input was valid, why didn’t it skip the error-handling logic? This is the work of monads in the code, which can propagate the concept of an empty value, or nothingness (in the form of an Either.Left or a Maybe.Nothing) seamlessly through- out the entire program; thus, every function is run, yet logic encapsulated in mapping functions is skipped.
  264: It’s remarkable how functional code is so robust and flexible. Now, let’s run a neg- ative test with invalid input.
  265   
  266  
  ...
  281  Figure 6.13 shows the areas that were left untouched due to the skipped logic.
  282  Even in the presence of invalid data, the functional program doesn’t just skip execution of entire sections of code. It gracefully and safely propagates the invalid condition in monads, outputting a decent 80% (twice as much as the imperative counterpart); see figure 6.14.
  283: Because it’s a lot more testable, the functional code should give you a sense of security and comfort to deploy it to your production systems—in case immutability and elimi- nation of side effects hasn’t done the trick. As mentioned earlier, the presence of con- ditional and loop blocks in imperative code not only makes it hard to test and hard to
  284   
  285  
  ...
  289  reason about, but also further increases the complexity of the function in question. How can you measure complexity?
  290  6.5.2	Measuring the complexity of functional code
  291: You can measure a program’s complexity by closely examining its control flow. At a glance, you determine that a block of code is complex when it’s visually difficult to fol- low. Functional programming presents a nice declarative view of the code that makes it visually appealing. This equates to reduced complexity from the developer’s point of view. In this section, you’ll see that functional code is also less complex from an algorithmic point of view.
  292: Many factors can contribute to complex code, including conditional blocks and loops, which can also be nested in other structures. Branching logic, for instance, is mutually exclusive and splits the control-flow logic into two independent branches according to a Boolean condition. Multiple if-else blocks in your code can be hard to trace; the process is even harder when their conditions are based on external fac- tors—side effects dictating the path the code should follow. The higher the number of conditional blocks and nested conditional blocks, the harder functions are to test, which is why it’s important to keep your functions as simple as possible. This is deeply rooted in FP’s philosophy of reducing all functions to simple lambda expressions whenever possible and combining them using composition and monads.
  293  Cyclomatic complexity (CC) is a quantitative software metric used to measure the number of linearly independent paths that functions take. From this concept comes the idea of verifying a function’s boundary conditions, to ensure that all possible paths through the functions are tested. This is accomplished with some simple graph theory of nodes and edges (as shown in figure 6.15):
  294  <li className="litag">	Nodes correspond to indivisible blocks of code.</li>
  ...
  298  <p className="pag">Page 178</p>
  299  In chapter 3, we studied the difference between an imperative control-flow graph and a functional one, and how functional cedes all branching and iteration logic to higher-order operations like map and filter.
  300: What contributes to CC? Mathematically, the complexity of any program can be computed as M = E - N + P, where
  301  <li className="litag">	E = Number of edges in the flow</li>
  302  <li className="litag">	N = Number of nodes or blocks</li>
  303  <li className="litag">	P = Number of nodes that have exit points</li>
  304: All control structures contribute to CC; the lower the value, the better. A conditional block affects complexity the most because it bifurcates the program’s control flow into two linearly independent paths. So, naturally, the greater the number of control arti- facts, the larger the CC metric will be, and, thus, the harder the program is to test.
  305: Let’s revisit the control flow of the imperative showStudent. To easily delineate the flow, I’ve annotated the statements that translate to nodes in the graph and then gen- erated a flowchart, shown in figure 6.16. Applying the CC formula to this graph with 11 edges, 10 nodes, and 3 exit points yields M = E - N + P = 11 - 10 + 3 = 4.
  306: On the other hand, measuring CC in functional programs is much simpler because FP tends to avoid both loops and conditional statements as much as possible in favor of higher-order functions, functional combinators, and other abstractions. All this translates to fewer nodes and edges and all paths in the function being linearly inde- pendent. Hence, functional programs tend to have a cyclomatic complexity value near 1. This is exactly what happens with the functional showStudent, because it’s composed
  307  Figure 6.16 Potential nodes in the imperative version of showStudent. These labels have been converted into a flowchart of nodes and edges, which illustrates the number of different linearly independent paths through the code caused by the presence of conditional statements.
  308   
  309  <p className="pag">Page 179</p>
  310: of many functions that don’t contain nodes and edges (just single exit points), mak- ing its cyclomatic complexity value M = E - N + P = 0 - 0 + 1 = 1. In the realm of com- plexity, some other related metrics extrapolated from both programs are worth noting (see table 6.1). You can measure them with the help of the website at http:// jscomplexity.org.
  311  Table 6.1 Other important static code metrics comparing the imperative to the functional Solutions
  312: The cyclomatic complexity density reexpresses the original CC value as a percentage based on the number of imperative lines of code, which is also substantially lower in functional programs. The degree to which a program is testable is directly propor- tional to how well the program is designed. Simply put, the more modular your code is, the easier it is to test. Functional programs easily take the lead because they embrace the modularity of your units, which are the functions themselves.
  313: Because functional programming is heavily rooted in eliminating manual loops in favor of higher-order functions; composition instead of imperative; sequential evalua- tion of code; and higher levels of abstractions with currying, it’s not senseless to think that all this could affect performance. Can we have our cake, and eat it too?
  314  6.6 Summary
  315  <li className="litag">	Programs that rely on abstractions to join very simple functions are modular.</li>

C:\Users\Emanuela\FunctionalP\pages\Chapter 7 - Functional optimizations.js:
    1: <p className="pag">Page 180 - Chapter 7 - Functional optimizations</p>
    2  This chapter covers
    3  <li className="litag">	Indicating where functional code is performant</li>
    .
   12  <p className="pag">Page 181</p>
   13  Always optimize last, or so they say. In previous chapters, you learned how to write and test your functional code; and now, nearing the end of this wonderful journey, we look at ways to optimize it. No single programming paradigm is the Holy Grail, and each has its share of trade-offs: performance versus abstraction, for example. Functional programming provides layers of abstractions around your code to achieve its high level of fluency and declarativeness. With all of this internal currying, recursion, and monadic wrapping composed together to solve even the simplest types of problems, you may wonder, “Is functional code as performant as imperative code?”
   14: Its true that with most modern web applications nowadays, excluding games, there’s nothing to be gained from cutting milliseconds of execution time from your programs. Computers have become incredibly fast and compiler technology amaz- ingly smart, which guarantees fast performance of correct code. FP isn’t any less per- formant than imperative code, as you may think; it just shines in different ways.
   15: It’s not wise to begin using a new paradigm without understanding its implications for the environment in which it’s running. So, in this chapter, I’ll explain some aspects of functional JavaScript code that you need to be aware of, especially when processing large amounts of data. I’ll be talking about core JavaScript features, like closures, so make sure you’ve read and understood chapter 2. I’ll also discuss some interesting optimization techniques such as lazy evaluation, memoization, and recur- sive call optimizations.
   16: Functional programming won’t speed up the evaluation times of individual func- tions; rather, its strategy is based on avoiding duplicated function calls and delaying calling code until it’s absolutely needed, which may speed up your application overall. In pure functional languages, these optimizations are built into the platform and can be used without any involvement from you. In JavaScript, though, you’ll need to man- ually plug in these optimizations via custom code or functional libraries. But before we dive in, I’ll briefly show you the challenges of using JavaScript functionally and why these optimizations are important.
   17  7.1	Under the hood of function execution
   18  Because FP relies on evaluating functions for everything you do, when learning about performance and optimizations, it’s important to understand what goes on in each function call. Every function call in JavaScript internally creates a record (a frame) in the function context stack.
   ..
   23  Index 1 Information taken from David Shariff s excellent blog post “What Is the Execution Context & Stack in JavaScript?” June 19, 2012, http://mng.bz/mqTu.
   24   
   25: The global context frame always resides at the bottom of the stack. Each function con- text frame takes up a certain amount of memory depending on the number of local variables contained within it. Without any local variables, an empty frame is approxi- mately 48 bytes. Local variables and parameters like numbers and Booleans require 8 byes each. Intuitively, the more variables the function body declares, the larger the stack frame. Each frame contains roughly the following information:1
   26   
   27: From this structure, we can extract a few important insights. First, the variable- Object property is what primarily determines the size of the stack frame, because it has references to a function’s arguments, the actual array-like arguments object (cov- ered in chapter 2), as well as any local variables and functions. Second, the function’s scope chain is what links or references this function’s context with its parent execu- tion context (I’ll talk more about the scope chain later). Whether directly or indi- rectly, every function’s scope chain eventually links to the global context.
   28: NOTE A function’s scope chain is different from a JavaScript object’s proto- type chain. Although both behave in similar ways, the latter refers to the link established in object inheritance through the prototype property. The scope chain refers particularly to the access an inner function has to its outer func- tion’s closure.
   29  <p className="pag">Page 183</p>
   30  The behavior of the stack is determined by the following important rules:
   ..
   33  <li className="litag">	You can have an unlimited number of function contexts (for client-side code, different browsers can impose different limits).</li>
   34  <li className="litag">	Each function call creates a new execution context, even when calling itself recursively.</li>
   35: As you know, functional programming exploits the use of functions to the maximum degree, and you’re encouraged to decompose problems into as many functions as possible as well as curry them for additional flexibility and reuse. But using lots of cur- ried functions has its own implications on the context stack.
   36  7.1.1	Currying and the function context stack
   37: Personally, I am a huge fan of currying. In fact, I’d like for JavaScript to automatically curry all function evaluations. But this additional level of abstraction can cause some context overhead compared to a regular function evaluation. To understand this bet- ter, let’s explore what happens under the hood of a curried function call in JavaScript.
   38: Recall from chapter 4 that when you curry a function, you internally transform its evaluation mechanism from a single-shot call with all parameters, to multiple one-at-a- time inner function executions. In other words, the logger function from chapter 4
   39  const logger = function (appender, layout, name, level, message)
   40  when curried, becomes this nested structure:
   ..
   44  return function (message) {
   45  ...</pre
   46: A nested structure uses the function stack more heavily than a straight call. First I’ll explain the non-curried execution of logger. Due to JavaScript’s synchronous execu- tion, a call to logger results in pausing execution of the global context to make way for logger to run, becoming the new active context and creating a reference to the global context for purposes of variable resolution. This is shown in figure 7.2.
   47: Internally, the logger function makes calls to other Log4js operations, which create new function contexts that are put on the stack (if you haven’t done so, you can visit the appendix for an introduction to Log4js). Due to closures in JavaScript, the func- tion contexts resulting from inner function calls are stacked one on top of the other, each taking up its fair share of allocated memory and linked via the scopeChain refer- ence (see figure 7.3).
   48  <p className="pag">Page 184</p>
   49  Figure 7.2 When invoking any function, like logger in this case, the single-threaded JavaScript runtime pauses the current global context and activates the context for the new function to run. At this point, a link is created between the global context and the function context, traversable via the scopeChain. Once logger returns, its execution context is popped off the stack, and the global context resumes.
   50  Figure 7.3 How the function context grows when running nested functions. Because each function produces a new stack frame, the stack grows in proportion to the level of nesting in functions. Both currying and recursion rely on nested function calls.
   51: Finally, once the Log4js code completes, it gets popped off the stack; the logger func- tion follows suit, leaving the runtime back in its original state—with only the single global context running (refer back to figure 7.1). This is the magic behind closures in JavaScript.
   52  Although this approach is powerful, deeply nested functions can consume large amounts of memory. In chapter 8, I’ll introduce you to RxJS, a functional library used to handle asynchronous code. The latest release, RxJS 5, is a complete revamp of the code from the previous version with focus on performance; reducing the number of closures was a top priority.
   53   
   ..
   77  <p className="pag">Page 186</p>
   78  
   79: This program creates an array of 80,000 numbers and compares the non-curried ver- sion to the curried function. The non-curried version returns the correct result in a few seconds, whereas the curried function causes the browser to halt. Undoubtedly, there’s a price to pay with currying, but having to process such large datasets in most applications is highly unlikely.
   80: This isn’t the only situation that can cause the stack to grow. Inefficient or incor- rect recursive solutions are the leading cases where the stack overflows.
   81  7.1.2	Challenges of recursive code
   82: New function contexts are created even when functions call themselves. An incorrect recursive call—one where the base case is never reached—can easily cause the stack to overflow. Luckily, recursion is one of those cases where it either works or it doesn’t, and when it doesn’t, it’s not shy about letting you know. If you’ve ever had the plea- sure of seeing the dreaded Range Error: Maximum Call Stack Exceeded or too much recursion error, you know what I mean. You can benchmark your browser with this simple script to get an approximate function stack size:
   83  <pre>function increment(i) {
   84  console.log(i);
   ..
   87  increment(1);</pre>
   88  Different browsers implement stack errors differently: on my machine, Chrome fires the exception after approximately 17,500 iterations, whereas Firefox will goes much longer, to about 213,000 iterations. Don’t use these numbers as upper bounds below which to write your functions! These are superfluous numbers meant to show you that there are limits you can’t exceed. Your code should be far below these thresholds, or you likely have a bug somewhere in your recursion.
   89: If you happen to deal with an unusually large amount of data using recursion, you may cause the stack to grow proportionally to the size of the array. Consider this exam- ple to find the longest string in an array:
   90  <pre>function longest(str, arr) {
   91  if(R.isEmpty(arr)) {
   ..
   98  }</pre>
   99  <p className="pag">Page 187</p>
  100: Running longest against all 192 countries in the world isn’t a problem, but using it to find the longest city name out of 2.5 million can cause the application to fail; see fig- ure 7.5. (Actually, this particular algorithm won’t fail with large arrays in ES6 Java- Script; more on this later.)
  101  Figure 7.5 The longest function, in order to find the longest string in an array of size n, grows proportionally to the size of the input, inserting n frames into the context stack.
  102: An alternative to keep in mind when traversing lists this way, especially with unusually large arrays, is to resort to using higher-order functions you learned about in chap- ter 3, such as map, filter, and reduce. Using these functions doesn’t generate nested function calls, and the stack size is recycled at each iteration.
  103  Although currying and recursion lead to functions that take up more memory than their otherwise imperative counterparts, think of what you gain in terms of the flexibility and reuse that come with currying, as well as the correctness inherent in recursive solutions. These definitely make the extra memory requirements worth it.
  104: On the bright side, functional programming provides optimizations that other par- adigms don’t. Placing lots of functions on the stack can increase your program’s mem- ory footprint, so why not avoid making some calls altogether?
  105   
  106  <p className="pag">Page 188</p>
  107  7.2	Deferring execution using lazy evaluation
  108: You can experience many performance benefits when avoiding unnecessary function calls and large inputs when only a subset is sufficient. Functional languages like Haskell have lazy function evaluation built into every function expression. There are dif- ferent types of lazy-evaluation schemes, all with the same goal of delaying the execu- tion of a function as much as possible, or until a dependent expression is called.
  109  But the more mainstream function-evaluation strategy, as used in JavaScript, is eager evaluation. In eager evaluation, an expression is evaluated as soon as it’s bound to a variable, regardless of whether the result of this function is needed; this is also known as greedy evaluation. Consider the sample case of taking a subset of elements from an array, shown in figure 7.6.
  110  Figure 7.6 The composition of the function range (returns a list of numbers from beginning to end) with take (reads the first n elements). In eager evaluation, the range function executes completely, feeding its result to take. With lazy evaluation, the result of range never executes until the dependent operation, take, is called.
  111: As you can see, in the eager-evaluation scheme, the range function is executed first; its result is passed to take, which only requires a subset of the output, discarding the rest. Think of how wasteful this would be if you were generating a larger number of ele- ments. With lazy evaluation, on the other hand, the execution of range is deferred until the dependent operation, take, demands it. Now, with more knowledge about the function’s purpose, the range function only produces the required number of ele- ments. Consider another example involving the Maybe monad:
  112  <pre>Maybe.of(student).getOrElse(createNewStudent());</pre>
  113   
  ...
  120  return student;
  121  }</pre>
  122: But due to JavaScript’s eager-evaluation scheme, this code will execute the create- NewStudent function regardless of whether the student object is null. Under lazy evaluation, the expression would have behaved like the earlier snippet and never called createNewStudent if the student object were invalid. So how can you take advantage of lazy evaluation? This section looks at a couple of tips and tricks:
  123  <li className="litag">	Avoiding needless computations</li>
  124  <li className="litag">	Using shortcut fusion in functional libraries</li>
  125  7.2.1	Avoiding computations with the alternation functional combinator
  126: Not surprisingly, you can do certain things to emulate lazy evaluation and still reap some of the benefits of pure functional languages. In the simplest case, you can avoid a needless computation by passing functions by reference (or by name) and condi- tionally invoking one or the other. In chapter 4, you saw the alt functional combina- tor that takes advantage of the || (OR) operator to evaluate func1 first and only call func2 in the event func1 produces a value of false, null, or undefined. Here it is again, with an example:
  127  Because the functional combinator takes care of orchestrating the calls, this code is equivalent to the imperative conditional logic:
  128  <pre>
  ...
  146  .first()
  147  .value()</pre>
  148: This declarative mode of programming means you don’t have to worry about how the functions work, just what needs to be done, by defining what it is you want to accom- plish ahead of time. On some occasions, this allows Lodash to internally optimize the execution of your program using shortcut fusion. It’s a function-level optimization that can merge the execution of some functions into one and condense the number of internal data structures used to compute intermediate results. Creating fewer data structures lowers the excess memory needed when processing large collections.
  149  This is possible due to functional programming’s strict rules about referential transparency, which give it this unique mathematical or algebraic correctness. For instance, the execution compose(map(f), map(g)) can be replaced by the expression map(compose(f, g)) without altering the meaning. Similarly, compose(filter(p1), filter(p2)) equates to filter((x) => p1(x) && p2(x)). This is exactly what happens in the filter and map pair beginning the previous chain. Again, manipulating the sequence of operations in this mathematical way is only possible with pure functions. Let’s go over another example in the following listing to see this clearly.
  150  Listing 7.1 Lodash’s lazy evaluation and shortcut fusion
  151   
  152  <p className="pag">Page 191</p>
  153: Listing 7.1 has a couple of optimizations: First, the cali to take(3) advises Lodash to only worry about the first three values that pass the mapping and filtering criteria instead of wasting precious cycles on the remaining 195 elements. Second, shortcut fUsion allows the subsequent calls to map and filter to fuse into compose(filter(isEven), map(square)). You can easily proof this by augmenting the square and isEven func- tions with trace logs (using Ramda to effectively compose the tap combinator for log- ging purposes):
  154  <pre>square = R.compose(R.tap(() => trace('Mapping')), square);
  155  isEven= R.compose(R.tap(() => trace('then filtering')), isEven);</pre>
  ...
  160  Along the same lines of avoiding computations until they’re needed is another powerful optimization feature of functional programs called memoization.
  161  7.3 Implementing a call-when-needed strategy
  162: One way to speed up the execution of applications is to avoid computing repetitive values, especially when these computations are expensive. In traditional object-ori- ented systems, this is accomplished by placing a cache or proxy layer that’s checked before a function is called. Upon return, the result of the function is given a key that references it uniquely, and this key-value pair is persisted in the cache. A cache is an intermediary repository, or memory, that’s queried before an expensive operation. In web applications, it’s used for images, documents, compiled code, HTML pages, query results, and so on. Consider this code snippet that implements a simple caching layer for any function:
  163   
  164  
  ...
  167  var cache = {};
  168  cachedFn(cache, findStudent, '444-44-4444'); cachedFn(cache, findStudent, '444-44-4444');
  169: This cachedFn function acts as a proxy between the function execution and its result to ensure that the same function isn’t invoked twice. But writing code with this wrap- per to serve every function cali in your code is tedious and makes it hard to read. What’s even worse is that this function has a side effect because it depends on a glob- ally shared cache object. What we need is a ubiquitous solution that lets us enjoy the benefits of caching while keeping our code and tests agnostic to this mechanism. In functional languages, this mechanism is called memoization.
  170  7.3.1	Understanding memoization
  171: The caching scheme behind memoization, similar to the previous code, makes use of the function’s arguments to create a unique key with which to store the function’s result, so that on subsequent invocations of the function with the same arguments, the stored result can be returned immediately. Relating the function’s result with its input, or shall we say, equating the computation of a function’s input to a value, is achieved due to a certain functional principle. You guessed it: referential transpar- ency. First, let’s study the benefits of memoization with a simple function call.
  172  7.3.2	Memoizing computationally intensive functions
  173: Pure functional languages implement memoization automatically; others, like Java- Script and Python, give you the option to choose when to memoize a function. Natu- rally, functions that are computationally intensive can benefit from interlacing a caching layer. Consider the example of computing a rot13 function, which encodes strings into ROT13 format (rotation of the 26 ASCII characters of the alphabet by 13 positions). Although this is a weak algorithm, it’s practical in web applications for hid- ing puzzle solutions and discount codes, muddling offensive material, and so on:
  174  <pre>var discountCode = 'functional_js_50_off';
  175  rot13(discountCode); //-> shapgvbany_wf_50_bss</pre>
  ...
  180  s.replace(/[a-zA-Z]/g, c =>
  181  String.fromCharCode((c <= 'Z'	? 90 : 122)
  182: >= (c = c.charCodeAt(0) + 13)	? c : c - 26));
  183: (c = c.charCodeAt(0) + 13)	? c : c - 26);
  184  });
  185  };</pre>
  ...
  191  s.replace(/[a-zA-Z]/g, c =>
  192  String.fromCharCode((c <= 'Z'	? 90 : 122)
  193: >= (c = c.charCodeAt(0) + 13) ? c : c - 26))).memoize();</pre>
  194  With memoization, you expect a subsequent call of a function with the same input to trigger the internal cache hit and return immediately. To illustrate this, let’s use JavaScript’s High Resolution Time API (also known as Performance API) to produce more-accurate timestamps than traditional JavaScript functions like Date.now() and console.time(), and measure the elapsed time of a function call. You’ll use the IO monad to inject time-capturing statements before and after the function under test. The entire program involves creating simple start and end functions that wrap the side effects in performance.now(), and tapping a simple function used to run the function under test. The following listing shows the time-measuring code; I’ll omit it in later examples to make the programs shorter.
  195  Listing 7.2 Using tap to add performance timing calls
  ...
  198  As you can see, the second cali to rot13 on the same string returns in a blink of an eye. Although JavaScript has no built-in automatic memoization, you can add it to the language by augmenting the Function object as shown next.
  199  Listing 7.3 Adding memoization to function calls
  200: By extending the Function object, this implementation makes memoization ubiqui- tous and also removes any observable side effects of accessing a globally shared cache. In addition, abstracting the function’s internal caching mechanism makes it com- pletely test-agnostic, which means you aren’t responsible for sprinkling caching state- ments all over your code or for testing the caching functionality; you only worry about what the function is supposed to do.
  201   
  202  
  203   
  204  <p className="pag">Page 195</p>
  205: To get a clearer picture, look at the detailed sequence diagram of the memoization of rot13 in figure 7.7. The first call to the memoized function results in a cache miss and the ROT13 message being computed. On completion, the result of the computa- tion is stored with a key generated from the input arguments so that the result can be reused and skip all computations on the next invocation.
  206  Figure 7.7 A detailed view of two calls to the rot13 function with the message “functionaljs_50_off.” The first time around, with an empty cache, the ROT13 code of the provided discount code is computed. This result is stored in the internal cache with a key generated from this input. The second call results in a cache hit: the value is directly returned without the hash being computed again.
  207: NOTE The examples in this book memoize functions of one argument. But how would you handle functions of multiple arguments? I won’t cover this, and instead leave it to you as an exercise to research, but there are two strate- gies you can follow: you can create a multidimensional cache (an array of arrays), or you can create a unique key by combining the string representa- tion of the arguments.
  208  If you closer at the code in listing 7.3, you’ll notice that memoization is limited to unary functions. I did it this way to simplify the key-generation step in the caching logic. If you need to memoize functions that take multiple arguments, the logic for formulating a proper cache key can get complicated and expensive. In some cases, though, currying can help you work around this issue.
  209   
  210  <p className="pag">Page 196</p>
  211  7.3.3	Taking advantage of currying and memoization
  212: More-complex functions, or functions involving multiple arguments, are harder to cache, even if they’re pure. This is due to the increased complexity in generating a proper key value—an operation that needs to be simple and quick in order to avoid incurring additional overhead in the caching layer. One way to mitigate this is through currying. Recall from chapter 4 that currying is used to transform a multivar- iate function into a unary function. Currying allows you to memoize a function like safeFindObject through findStudent:
  213: This works because the DB object is used only for data access and doesn’t contribute to uniquely distinguishing the purpose of findStudent, which is to find a student by a unique ID. The emphasis on making functions unary is not only to make them easier to work with and compose, but also so that memoization can take advantage of finer- grained decomposition and implement caching across the components that make up the entire program. Let’s discuss this next.
  214  7.3.4	Decomposing to maximize memoization
  215: The relationship of memoization and decomposition can be understood with a simple chemical analogy that will take you on a stroll down memory lane (bear with me!). You may have learned in high school chemistry, when studying the principles of solu- bilità that a solution is composed of a solute and a solvent. A solute is the substance that dissolves in the solvent. The rate of solution, which is how quickly a solute dis- solves, is determined by many factors, one of which is surface area. For instance, if you prepare two solutions of sugar and water, one with powdered sugar and the other with chunks of sugar, which one dissolves faster? When sugar dissolves, only its surface comes in contact with the water. Therefore, the greater the surface area of the solute, the faster it dissolves.
  216  This same analogy can be applied to breaking up problems into tiny, memoizable functions. The more fine-grained your code is, the greater the benefits obtained via memoization will be. Each and every function’s internal caching mechanism is playing a role in speeding up evaluation of your programs—there’s more surface contact, if you will.
  217  In the case of showStudent, for example, if you’ve previously validated certain inputs, why bother to validate them again? Similarly, if you’ve fetched student objects by SSN from a local store, with cookies, or even via a server-side call, and you don’t
  218   
  219  <p className="pag">Page 197</p>
  220: expect them to have changed, why waste precious time doing the lookup again? What’s remarkable is that in the case of findStudent, memoization can serve as a small query cache, retaining already-fetched objects for quick access. Memoization puts the icing on the cake in terms of reasoning about functions as just values—lazily computed values. To illustrate, let’s replace some of the functions in showStudent with their memoized counterparts (just for illustration purposes, the memoized func- tions are prefixed with m_—this isn’t a general convention):
  221  <pre>const m_cleanInput = cleanInput.memoize();
  222  const m_checkLengthSsn = checkLengthSsn.memoize();
  ...
  233  showStudent('444-44-4444').run(); //-> 2.5 ms on average (with memoization)</pre>
  234  Because this function is decomposed into smaller tasks, the speed improvements are compounded, creating a program that runs 75% faster the second time around!
  235: Recursion is another type of decomposition, where a program is split into self- similar smaller tasks—memoizable, self-similar subtasks. Likewise, memoization can turn a slow-performing recursive algorithm into a really fast one.
  236  7.3.5	Applying memoization to recursive calls
  237: Recursion can cause a browser to grind to a halt or throw nasty exceptions. This tends to happen when the stack grows out of control, such as when processing very large input. In some cases, memoization can help mitigate the issue. As you learned in chapter 3, recursion is a mechanism of decomposing a task into smaller versions of itself. Typically, a recursive call solves “the same problem,” or a subset of the big- ger problem, many times until it reaches the base case, which finally causes the stack to unwind and the result to be returned. If you could cache the results of the subtasks, you could improve the performance of invoking this same function on bigger input.
  238  To illustrate, you’ll use a simple function that computes the factorial of a number n. The factorial of n (denoted n!) is the product of all positive integers less than or equal to n:
  239: <pre>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</pre>
  240  <p className="pag">Page 198</p>
  241  For example:
  242  The program for this task can be nicely expressed as a memoized recursive solution:
  243: Because memoization uses the mathematical principles of factorials, you obtain remarkable throughput in the second iteration of the function. In the second run, the function “remembers” to use the formula 101! = 101 x 100! and can reuse the value of factorial(100), causing the entire algorithm to short-circuit and return instantly. This has other benefits in terms of stack frame management and avoiding stack pollu- tion; see figure 7.8.
  244  Figure 7.8 Running the memoized factorial(100) the first time creates 100 stack frames because it needs to compute 100! by multiplying every single number. On the second call to factorial with 101, via memoization it’s able to reuse the result of factorial(100) and create only 2 stack frames.
  245   
  ...
  249   
  250  <p className="pag">Page 199</p>
  251: As you can see, the first run of factorial(100) runs through the entire algorithm, creating 100 frames on the function stack. This is the downfall of some recursive Solu- tions: they tend to be careless with stack space, especially in cases such as factorial that use frames proportional to the input received. But with memoization, you can sig- nificanti reduce the number of stack frames required to compute the next number.
  252  Memoization isn’t the only method to optimize recursive calls. There are other ways to benefit performance by using compiler-level instrumentation.
  253  7.4	Recursion and tail-call optimization (TCO)
  ...
  261  }</pre>
  262  TCO, also known as tail-call elimination, is a compiler enhancement added to ES6 that flattens the execution of a recursive call into a single frame. But this can only occur when the last act of the recursive solution is to invoke another function (typically itself); this last invocation is said to be in tail position (hence the name).
  263: Why is this an optimization? Having a function call as the last thing to run in a recursive function allows the JavaScript runtime to realize it doesn’t need to hold on to the current stack frame any longer, because it doesn’t have any more work to do; so it discards the stack frame. In most cases, you achieve this by transferring all the neces- sary state from one function context to the next as part of the function’s arguments (as you saw in the recursive factorial function). This way, the recursive iteration tends to happen with a new frame every time, recycled from the previous one, instead of
  264   
  265  <p className="pag">Page 200</p>
  ...
  291  <pre>const factorial = (n) =>
  292  (n === 1) ? 1
  293: :  (n * factorial(n - 1));</pre>
  294: wasn’t in tail position because the last return expression multiplies a number times the value of the recursive step: n * factorial(n - 1). Remember that for TCO to occur, the last step needs to be the recursive step, which is what allows the runtime to convert factorial into a loop. You’ll do this in two steps:
  295  1	Move the multiplication as an additional parameter to the function, to keep track of the current multiplication.
  296  2	Use ES6 default parameters to preset a default value for this argument (you could also partially apply them, but with default arguments it will look much cleaner):
  297  <pre>const factorial = (n, current = 1) =>
  298  (n === 1) ? current :
  299: factorial(n - 1, n * current);</pre>
  300: Now this factorial function will run as if it were implemented with standard looping, with no additional stack frames created, while still preserving some of the declara- tive and mathematical feel it originally had. This transformation takes place because a tail-recursive function shares common features with a standard loop, as shown in figure 7.10.
  301  Figure 7.10 The similarities between a standard loop (left) and its equivalent tail-recursive function. In both code samples, you can easily see the base case, the afterthought or accumulated parameter, and the result.
  302   
  ...
  308  return _.first(arr) + sum(_.rest(arr));
  309  }</pre>
  310: Again, you can see that the last action this function performs, _.first(arr) + sum(_.rest(arr)), isn’t in tail form. Let’s refactor this code and optimize it for mem- ory consumption. Again, any data that needs to be shared with subsequent invocations is now added as part of the function arguments:
  311  <pre>function sum(arr, acc = 0)	{
  312  if(_.isEmpty(arr)) { return 0;
  ...
  314  return sum(_.rest(arr), acc + _.first(arr));
  315  }</pre>
  316: Tail recursion brings the performance of a recursive loop closer to that of a manual loop. So in languages that have it, as ES6 JavaScript does, it can be used as a replace- ment for manual loops when performance is of upmost priority, while keeping the correctness of the algorithm and controlling mutations. But tail calls aren’t limited to recursion. They can be used with any function whose last action is to invoke another function, which tends to happen quite a bit in JavaScript applications. The caveat when using TCO, however, is that this new JavaScript standard, which began to be drafted with ES4, is not yet widely adopted by browsers. In fact, as of this writing, none of the browsers have TCO natively implemented, which is why I’ve been using the Babel transpiler.
  317  Emulating tail-recursive calls in ES5
  318  The current mainstream JavaScript implementation, ES5, doesn't have support for tail-call optimization. This was added to the language with the ES6 proposal known as proper tail calls (section 14.6 of the ECMA-262 specification). Recall from chapter 2 that the examples work due to the use of the Babel transpiler, a source-to-source compiler, which is an excellent way to test out the future features of the language.
  319: But you can work around this through a process called trampolining. Trampolining is a way to simulate tail recursion in an iterative way, which is ideal for controlling func- tion stack growth in stack-based languages like JavaScript.
  320  A trampoline is a function combinator that takes another function as input and invokes it repeatedly (or bounces a function, if you will) until a certain condition occurs. The function that bounces or repeats is encapsulated in a structure called a
  321  <p className="pag">Page 203</p>
  322: thunk. A thunk is nothing more than a function wrapper used to assist a cali to another function. In the context of functional JavaScript, thunks lazily wrap an argu- ment expression in an anonymous function that has no parameters of its own, delay- ing its evaluation until a receiving function invokes the anonymous function.
  323  The topics of trampolining and thunks are outside of the scope of this book, so if you're desperately seeking to optimize your recursive functions now, I recommend you begin your research here.
  324  To check for the compatibility of TCO and other ES6 features, you can check out the following website: https://kangax.github.io/compat-table/es6/.
  325: If you’re writing a tight graphics-rendering loop or you need to process large datasets in a short time, then performance becomes a key requirement. In these cases, you’re ready to make the necessary trade-offs, and you aren’t looking to write elegant, exten- sible code—you need to get the job done fast. For this, I recommend sticking to stan- dard loops. But for most application needs, functional programming remains a very performant way to write code. Always optimize last; and, in certain edge cases that require extra milliseconds of performance, you can always use any of the performance enhancements provided in this chapter.
  326: Every software decision has an equal opposing force; but for most applications, sac- rificing efficiency in favor of maintainability is a valid trade-off, in my opinion. I’d much rather write code that is easy to read and debug, even if it’s not the fastest. As Knuth said, “In 97% of the code you write, a few extra milliseconds make no differ- ence, especially compared to the value of writing maintainable code.”
  327  Functional programming is a complete paradigm. It provides a rich level of abstraction and redirection while crafting interesting ways to make it efficient. Until now, you’ve learned how to create functional programs with linear data flows through chaining or composition. But as you’re well aware, JavaScript programs mix in lots of nonlinear or asynchronous behavior, such as when handling user input or making remote HTTP requests. In chapter 8, you’ll take on these challenges and learn about reactive programming, a paradigm built on the principles of functional programming.
  328  7.5	Summary
  329  <li className="litag">	In certain cases, functional code can be slower or consume more memory than its equivalent imperative counterpart.</li>
  330: <li className="litag">	You can implement a deferred strategy using lazy evaluation by taking advan- tage of the alternation combinator and the support provided in functional libraries like Lodash.</li>
  331  <li className="litag">	Memoization, an internal function-level caching strategy, can be used to avoid duplicating the evaluation of potentially expensive functions.</li>
  332  <p className="pag">Page 204</p>

C:\Users\Emanuela\FunctionalP\pages\Chapter 8 - Managing asynchronous event.js:
    1: <p className="pag">Page 205 - Chapter 8 - Managing asynchronous events and data</p>
    2  This chapter covers
    3  <li className="litag">	Identifying the challenges of writing asynchronous code</li>
    .
    6  <li className="litag">	Generating data lazily with function generators</li>
    7  <li className="litag">	Introducing reactive programming</li>
    8: <li className="litag">	Applying reactive programming to tackle event- driven code</li>
    9  Functional programmers argue that there are great material benefits— that a functional programmer is an order of magnitude more productive than his conventional counterpart, because functional programs are an order of magnitude shorter.
   10  —John Hughes, “Why Functional Programming Matters”1
   ..
   12  
   13  <p className="pag">Page 206</p>
   14: Until now, you’ve been learning how to think functionally and using functional tech- niques to write, test, and optimize your JavaScript code. All of these techniques are designed to tame the complexities intrinsic to mid- and large-scale web applications, which can easily become increasingly difficult to maintain. Many years ago, interac- tion with web applications was limited to submitting large forms and rendering entire pages at once. Applications have evolved, and with them the demands of users. Nowa- days, we all expect pages to behave more like native applications that respond and react in real time.
   15: In the world of client-side JavaScript, the number of challenges we face is greater than in any other environment. This is directly influenced by the emergence of bulky client code that not only shares the burden associated with conventional web middle- ware, but also needs to effectively interact with user input, communicate with remote servers (via AJAX), and display data on the screen, all at once. The proposed solution in this book is functional programming, which is ideal for systems that need to main- tain a high level of integrity despite all of these concerns.
   16  In this chapter, you’ll apply functional programming to tackle real-world JavaScript programming challenges related to asynchronous data flows where code isn’t linear to the program’s execution. Some of the examples feature browser technology like AJAX and local storage requests. The goal is to use functional programming in conjunction with ES6 promises, as well as introduce reactive programming, both of which are used to turn messy callback code into elegant, fluent expressions. Reactive programming will seem familiar because it’s a way of thinking about problems that follows closely from functional programming.
   17: Asynchronous behavior is tricky to get right. Unlike normal functions, asynchro- nous functions can’t just return data to the caller. Instead, you rely on the infamous callback pattern that notifies you when long-running computations, database fetches, or remote HTTP calls have been computed. You also use callbacks to handle browser events like clicks, key presses, and mobile gestures in response to user interaction. You need to build code that responds to these events happening after your program is run, which poses many challenges for a functional design that instead expects data to come in predictably and at the right time. After all, how you can compose or chain functions for behavior that will happen in the future?
   18  8.1	Challenges of asynchronous code
   19  Modern JavaScript programs are seldom loaded in a single request; most often, data is progressively loaded on the page by multiple asynchronous requests that respond to a user’s needs. A simple use case is an email client. Your inbox can have thousands of long email threads, yet you see and interact only with the recent ones. It doesn’t make sense for you to have to wait a few seconds (or even minutes) for your entire inbox to load. As JavaScript developers, we deal with problems of this nature frequently, and
   ..
   24  <li className="litag">	An incompatible mix of synchronous and asynchronous code</li>
   25  8.1.1	Creating temporal dependencies among functions
   26: Consider a function used to perform an AJAX request to fetch a list of student objects from the server. In figure 8.1, because getJSON is asynchronous, the function returns as soon as the request is sent and gives control back to the program, which subse- quently invokes showStudents. But at this point in time, the students object is still nuli because the slower remote request hasn’t yet completed. The only way to ensure that the right order of events transpires is to create a temporal dependency between the asynchronous code and the action to take next. This involves including showStudents in the callback function so that it’s executed at the right time.
   27  Figure 8.1 This code has a big problem. Can you spot it? Because you need to fetch data asynchronously, the students object will never be populated in time to be added to the roster table.
   28  Temporal coupling or temporal cohesion occurs when the execution of certain functions is logically grouped together. This is done when functions need to wait for data to be available or need to wait for other functions to run. Whether you’re depending on data or, in this case, time, both can cause side effects.
   29: Because performing remote IO operations is noticeably slower than the rest of your code, you delegate them to nonblocking processes that can request data and “wait” for it to come back. When data is received, the user-provided callback func- tion is invoked. This is precisely what getJSON does; the following listing shows the details.
   30   
   31  <p className="pag">Page 208</p>
   ..
   47  Callback functions are commonly used in JavaScript. But they’re hard to scale when you need to load more data sequentially, which leads to the popular callback pattern.
   48  8.1.2	Falling into a callback pyramid
   49: The main use of callbacks is to avoid blocking the UI to wait for long-running pro- cesses to complete. Functions that accept a callback instead of returning values imple- ment a form of inversion of control: “Don’t call me, I’ll call you.” As soon as an event happens, such as data being available or a user clicking a button, the callback function is invoked with the requested data to allow your synchronous code to run:
   50  <pre>var students = null; getJSON('/students', function(students) {
   51  showStudents(students);
   ..
   55  }
   56  );</pre>
   57: In the event of an error, the corresponding error callback function is called, giving you the chance to report the error and recover. But this inversion of control works against the design of functional programs, where functions are supposed to be inde- pendent of one another and are expected to return values to the caller immediately. As I said earlier, this situation worsens if you need to add more asynchronous logic into already-nested callbacks.
   58  <p className="pag">Page 209</p>
   59  To show this, consider a slightly more complicated scenario. Suppose that after fetching a list of students from the server, you also need to fetch grades—but only for students residing in the United States. This data is then sorted by SSN and displayed on an HTML page, as shown in the next listing.
   60  Listing 8.2 Nested JSON calls, each with its own success and error callbacks
   61: Before you read this book, this code would’ve looked acceptable to you; but to a func- tional programmer such as yourself, it looks messy and tangled (later, I’ll show you a complete functional version of this code). The same effect occurs when handling events. Listing 8.3 interleaves AJAX calls with user-input handling. It listens for clicks and mouse events, fetches multiple pieces of data from the server, and renders the data on the DOM.
   62  Listing 8.3 Retrieving student records from the server by SSN
   63  <pre>var _selector = document.querySelector;
   ..
   87  <p className="pag">Page 210</p>
   88  
   89: Again, this code is hard to follow. As you can see, nesting a sequence of callbacks quickly makes the code resemble a horizontal pyramid like the one shown in figure 8.2. This is known casually as “callback hell” or the “Christmas tree of doom,” characteris- tic of programs dealing with lots of asynchronous code and user/DOM behavior.
   90: When a program begins taking this form, you find yourself relying on spacing and syntac- tic organization, such as grouping statements just to improve readability. But this is just putting lipstick on a pig. Let’s see how thinking functionally can help in this situation.
   91  8.1.3	Using continuation-passing style
   92  Listing 8.3 is another example of a program that hasn’t been properly decomposed. The nested callback functions not only are hard to read, but also create closures that enclose their own scope plus the variable scope of the functions in which they’re nested. The only reason to nest a function in another is when it needs direct access to
   93   
   94  <p className="pag">Page 211</p>
   95: its outer variables in order to fulfill its purpose. But in this case, the inner callback function that processes all the grades still keeps references to unnecessary external data. One solution that makes this code better is to unravel it by using continuation- passing style (CPS). In the following listing, I refactored listing 8.3 using CPS.
   96  Listing 8.4 Refactoring student retrieval using continuation-passing style
   97  <pre>var _selector = document.querySelector;
   ..
  116  }
  117  };</pre>
  118: All I did was separate the inner callbacks into separate functions or lambda expres- sions. CPS is a style of programming used for nonblocking programs that encourages you to separate pieces of a program into individual components; for this reason, it’s an intermediate form of functional programming. In this case, the callback functions are known as the current continuations, which are provided by its callers on the return value. An important advantage of CPS is its efficiency in terms of the context stack (revisit chapter 7 for information on JavaScript’s function stack). If your program is completely in CPS (like listing 8.4), continuing into other functions will clean up the current function’s context and prepare a new one to support the function that contin- ues the flow of the program—every function is essentially in tail form.
  119: Using continuations also fixes a problem in listing 8.2 that occurs when interlac- ing synchronous and asynchronous behavior. The problematic section of code is the
  120  <p className="pag">Page 212</p>
  121  nested loop that makes AJAX requests to retrieve each student’s grades and compute their average:
  ...
  136   
  137  <p className="pag">Page 213</p>
  138: As you learned in chapter 2, the solution to this problem is to properly scope the student object into a function that makes the AJAX request. Using CPS in this case is not as straightforward as before, because the nested callback function to handle the grades depends on the student object as well. Remember, this is a side effect. Restor- ing the continuation requires you to think about what you learned in chapter 4 on currying, to help link function inputs and outputs:
  139  This new code computes the correct results shown in figure 8.4.
  140  Figure 8.4 Passing the current student object as a parameter properly sets the function’s closure and solves the ambiguity resulting from executing remote calls in a loop.
  141: Adopting a continuation passing style helps to break the temporal dependency in your code, as well as disguise the asynchronous flow into a linear evaluation of func- tions—both good things. But someone else reading this code, who isn’t familiar with it, may be confused as to why the functions aren’t executing at the right times. You need to make these long-running operations first-class objects in your programs.
  142   
  143  
  ...
  145  <p className="pag">Page 214</p>
  146  8.2	First-class asynchronous behavior with promises
  147: The previous code example is defmitely an improvement over the imperative asyn- chronous programs you saw at the beginning of the chapter, but it’s far from being functional. As with any functional program, you also seek other qualities like these:
  148  <li className="litag">	Using composition and point-free programming</li>
  149  <li className="litag">	Flattening the nested structure into a more linear flow</li>
  150: <li className="litag">	Abstracting the notion of temporal coupling so that you don’t need to be con- cerned with it</li>
  151  <li className="litag">	Consolidating error handling to a single function rather than multiple error callbacks so that it’s not in the way of the code</li>
  152  Whenever I talk about flattening structures, composition, and consolidating behavior, a design pattern should come to mind; this sounds like the job for a monad. Let’s explore the Promise monad. Just to give you a rough idea, imagine a monad that wraps a long computation (this isn’t the actual Promise interface, but a close analogy):
  153  <pre>Promise.of(<long computation>).map(fun1).map(fun2);//-> Promise(result)</pre>
  154: Unlike the other monads you learned about in this book, promises know to “wait” for the long-running computation to complete before the mapped functions are run. In this manner, this data type tackles head-on the problem of latency present in asyn- chronous calls. Just like Maybe and Either document functions with uncertain return values, promises make the notion of waiting for data honest and transparent; they also have the benefit of providing a simpler alternative for executing, composing, and managing asynchronous operations when compared to traditional callback-based approaches.
  155: You can use promises to wrap a value or a function to be processed in the future (if you have some Java experience, this is similar to the Future<V> object). A long- running operation can be a complex calculation, fetching data from a database or a server, reading a file, and so on. In the event of a failure, promises allow you to con- solidate error-handling logic using approaches with a look and feel much like that used with Maybe and Either. In a similar fashion, a promise can provide information about the state of the work being done, so you can ask questions such as these: Has data been fetched successfully? And were there any errors during the operation?
  156: As you can see in figure 8.5, at any point in time a promise can be in any of these states: pending, fulfilled, rejected, or settled. It begins with a status of pending (also called unresolved). Depending on the outcome of the long-running operation, the promise can move into either fulfilled (in case resolve is called) or rejected (in case reject is called). Once a promise has been fulfilled, it can notify other objects (con- tinuations or callbacks) that its data has arrived; or, in the case of errors, it can invoke
  157  <p className="pag">Page 215</p>
  158  Figure 8.5 How an async operation is wrapped in a Promise and provided with two callbacks: one for resolve and another for reject. The promise begins with a status of pending and then is either fulfilled or rejected, invoking the function resolve or reject, respectively, before moving into the settled state.
  ...
  175  Just like a monad’s map, promises provide a mechanism to apply transformations against a value that doesn’t exist yet—a value in the future.
  176  8.2.1	Future method chains
  177: The Promise object defines a then method (analogous to a functor’s fmap), which applies an operation on a value returned in a promise and closes it back into a Promise. Similar to Maybe.map(f), Promise.then(f) can be used for chaining data transforma- tions as well as joining functions in time, abstracting the use of temporal coupling among your functions. With this, you can chain multiple levels of dependent asynchro- nous behavior linearly without creating new nested levels, as seen in figure 8.6.
  178  Figure 8.6 A sequence of chained promises joined via the then method. Each then clause is executed serially with one promise value after the next as soon as each is fulfilled.
  179   
  ...
  185  Promisifying your APIs is good practice. It makes working with your code a lot easier than with traditional callbacks. Because promises are designed to wrap any type of long-running operation, not just fetching data, they can be used with any object that implements a then method (known as a thenable). Soon, all JavaScript libraries will incorporate promises into their functions.
  186  Promises with jQuery
  187: If you're a jQuery user, you've probably interacted with promises already. jQuery's $.getJSON operation (and any variation of the JQuery $.ajax calls) returns its own Deferred object (a nonstandard version of a Promise), which implements the Prom- ise interface and has a then method. Hence, you can use Promise.resolve() to treat the Deferred object as a Promise:
  188  <pre>Promise.resolve($.getJSON('/students')).then(function ()	...);</pre>
  189  This object is now a thenable and used just like any promisified object. I chose to implement my own getJSON in listing 8.5 to illustrate the process of refactoring an API call to use promises.
  ...
  198  }
  199  );
  200: Now, instead of continuation passing, you’ll refactor listing 8.2 with a superior solu- tion based on promises. Here’s the code from listing 8.2 once more:
  201  getJSON('/students',
  202  function (students) {
  ...
  222  <li className="litag">	Instead of nesting asynchronous calls, chain them together using then and use the Promise monad to abstract out asynchronous parts of the code.</li>
  223  <li className="litag">	Remove all variable declarations and mutations in favor of lambda functions.</li>
  224: <li className="litag">	Take advantage of Ramda’s curried functions to create succinct data-transfor- mation steps like sorting, filtering, and mapping.</li>
  225  <li className="litag">	Consolidate error-handling logic into a final catchall function.</li>
  226  <li className="litag">	Lift the data into an IO monad to write data to the DOM in a side effect-free manner.</li>
  ...
  233  Figure 8.7 The flow of behavior through the chained use of promises. Each thenable block contains a function that transforms the data passed through it. Although this program is bug-free and has all the desired functional qualities, it’s inefficient because it uses a waterfall sequence of getJSON requests to fetch each student’s grades.
  234  Listing 8.7 Fetching multiple items at once with Promise.all()
  235: Using Promise.all takes advantage of the browser’s ability to download multiple things at once. The resulting promise resolves as soon as all promises in the iterable argument have resolved. Listing 8.7 brings together two basic componente of func- tional code: splitting a program into simple functions and then composing them together via a monadic data type that orchestrates the program’s entire execution. Figure 8.8 illustrates what’s happening.
  236   
  237  
  ...
  239  <p className="pag">Page 221</p>
  240  Figure 8.8 The flow of behavior through the chained use of linear as well as concurrent promises with Promise.all(). Each thenable block contains a function that transforms the data passed through it. This program is efficient because it can spawn several parallel connections to fetch all the data at once.
  241: But monads aren’t effective only for forming method chains. As you learned in previ- ous chapters, they’re also effective when used with composition.
  242  8.2.2	Composing synchronous and asynchronous behavior
  243  When you think of the way inputs and outputs of composed functions are linked together, your intuition tells you that these functions must be executing linearly one after the other. But using promises, you can execute functions that are separated in time, while still preserving the look of an otherwise synchronous program made up of functions that compose. This concept is a bit mind-bending to grasp, so I’ll explain with an example.
  ...
  246  <p className="pag">Page 222</p>
  247  Listing 8.8 find function using the browser’s locai store
  248: I’ve omitted the details of setting up the db object because they’re not relevant to this discussion. You can learn how to initialize and use the indexed locai store API here: https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API. What you’ll learn from reading this document is that the APIs are all asynchronous—rely on call- back passing—for reading and writing to storage. But how can you compose functions together that execute at different moments in time? Until now, the find function has always been synchronous. Luckily, promises abstract the execution of asynchronous code so that composing functions with promises is equivalent to composing functions in the future, with not much change to the code. Before you implement the code, let’s create a few helper functions:
  249   
  250  
  ...
  253  Using these functions with R.compose produces the code in the next listing.
  254  Listing 8.9 Asynchronous version of showStudent
  255: Here you can really see the power of composition with promises. As figure 8.9 shows, when findStudentAsync runs, the entire program waits for the asynchronous func- tion to return to the caller with data, in order to proceed to execute the rest of the functions. The promise in this case acts as a gateway into the asynchronous part. It’s also declarative in that nothing in this program reveals the internal behavior of the asynchronous nature of the function or that callbacks are being used. Thus, compose can still be used to orchestrate point-free programs that glue together functions that won’t execute at the same time, but rather in the future, showing its true color as a functional combinator.
  256  I	added error-handling logic as well; running this program with an existing SSN showStudentAsync ('444-44-4444') successfully appends the student record to the
  257  Figure 8.9 When composing synchronous code with asynchronous behavior, there’s a point of inflexion in the program where the code shifts into a time-bound adjacent sequence of events that happen within the confines of the promise type.
  ...
  262  page. Otherwise, if the promise is rejected, the error is safely propagated throughout the program until the catch clause prints the following:
  263  [ERROR] Error: Student not found!
  264: This program is certainly complex, yet you were able to preserve its functional style by combining many concepts learned throughout this book: composition, higher-order functions, monads, containerization, mapping, chaining, and others. Furthermore, this notion of a program waiting or yielding for data to become available is such a com- pelling concept that it has been introduced as a first-class citizen in ES6 JavaScript, as you’ll see next.
  265  8.3	Lazy data generation
  266: One of ES6’s most powerful features is the ability of functions to cooperate with others by pausing to provide data without necessarily running to completion. This brings many (possibly infinite) opportunities for functions to become vehicles for lazily pro- ducing data instead of having to process massive data structures all at once.
  267  On one hand, you can have large collections of objects that are transformed according to business rules (you’ve done this all along with map, filter, reduce, and others); on the other, you can specify rules that govern how data should be created. For instance, the function x => x * x, in the mathematical sense, is nothing more than a specification for all squared numbers (1, 4, 9, 16, 25, and so on). With some special syntax, this is known as a generator.
  268: A generator function is a language-level artifact defined with the function* nota- tion (yes, a function with an asterisk). This new type of function has the unique qual- ity that it can be exited using the new keyword yield and later reentered having its context (all local variable bindings) saved across reentrances. If you’re not familiar with a function’s execution context, see chapter 7 for more information. Unlike typi- cal function calls, the ability to reenter a generator is possible because the execution context of a generator function can be temporarily paused and then resumed at will.
  269  Lazily evaluated languages can generate lists of arbitrary size as required by the program. IfJavaScript were lazily evaluated, you could theoretically do something like the following:
  270  <pre>R.range(1, Infinity).take(1); //-> [1]
  271  R.range(1, Infinity).take(3); //->	[1,2,3]</pre>
  272: This is conceptual, of course. As you learned in chapter 7, JavaScript evaluates func- tions eagerly, so the calls to R.range(1, Infinity) will fail to complete and will overflow the browser’s function stack. Generators provide lazy behavior through an internal iterator object that’s created when the generator function is called. The iterator serves data to the caller on demand on every call to yield, as shown in fig- ure 8.10.
  273  <p className="pag">Page 225</p>
  274  With generators, you can implement the lazy program to take a certain number of elements from an infinite set:
  ...
  281   
  282  <p className="pag">Page 226</p>
  283: With a few limitations, generators behave much like any standard function cali. You can pass arguments to them, and perhaps a function, to drive the nature of the gener- ated values:
  284  Another quality of generator functions is that they can be used recursively.
  285  8.3.1	Generators and recursion
  286: Just like any function call, generators can be called from other generators. This is use- ful in cases where you want to create a flattened view of a nested set of objects, which is ideal when iterating over trees. Because generators can be looped over with for..of, delegating to another generator is similar to merging two collections and iterating over the entire thing. Recall the apprentice graph from chapter 3, shown again in figure 8.11.
  287   
  288  Figure 8.11 Revisiting the apprentice graph from chapter 3, where each node represents a student object and each line represents a “student-of” relationship
  289: You can easily model the data included in the branches of this tree using simple gen- erators like so (I’ll show the printed result of running this program later):
  290  function* AllStudentsGenerator(){ yield 'Church';
  291   
  ...
  293   
  294  <p className="pag">Page 227</p>
  295: Because recursion is such an integrai part of functional programming, I also want to demonstrate that despite the special semantics behind generators, they behave much like standard function calls, which can delegate to themselves. Here’s a simple tra- versal of the same tree (recall that each node contains a Person object), this time using recursion:
  296  Running this code produces the same output as previous: Church, Rosser, Mendelson, Sacks, Turing, Gandy, Kleene, Nelson, Constable. As you can see, control is given to the other generators and then, once completed, returned to the caller in the exact
  297   
  ...
  301  same spot where it left off. From the for..of loop point of view, however, it just calls an internai iterator until it runs out of data and doesn’t know recursion is even taking place.
  302  8.3.2	The Iterator protocol
  303: Generators are closely tied to another ES6 artifact called iterators, which is the reason you can loop over generators like any other data structure (such as arrays). Behind the scenes, a generator function returns a Generator object that conforms to the iter- ator protocol; this means it implements a method called next() that returns a value resulting from using the yield keyword. This object has the following properties:
  304: <li className="litag">	done—Has the value true if the iterator is passed the end of the sequence. Oth- erwise, a value of false means the iterator was able to produce another value in the sequence.</li>
  305  <li className="litag">	value—Any value returned by the iterator.</li>
  306  This is enough for you to understand how generators work behind the scenes. Let’s look at the range generator again, implemented in a raw format:
  ...
  323  iter.next().value// -> t
  324  </pre>
  325: I want to call out the idea of thinking about data as streams that, when probed, pro- duce discrete sequences of events or values. As you’ve seen all along, these values flow into a sequence of pure higher-order functions and transform into your desired out- put. This way of thinking is vitally important and gives rise to another programming paradigm (based on functional programming) called reactive programming.
  326  8.4	Functional and reactive programming with RxJS
  327: I’ve mentioned before that the nature of web applications has changed drastically, mostly influenced by the AJAX revolution. As we push the limits of the web, users’ expectations become increasingly demanding of not just more data, but also more interactivity. Applications need to be able to process user input coming from different sources like button presses, text fields, mouse movements, finger gestures, voice com- mands, and others, and it’s important to be able to interact with all of these in a con- sistent manner.
  328: In this section, I’ll introduce a reactive library called Reactive Extensions for JavaScript (RxJS) that you can use to elegantly combine asynchronous and event- based programs (refer to the appendix for installation information). RxJS works in ways similar to the functional promise-based examples you saw earlier in this chapter, but it provides a higher degree of abstraction and many more powerful operations. Before we get started, you must understand the concept of observables.
  329  8.4.1	Data as observable sequences
  330: An observable is any data object that you can subscribe to. Applications can subscribe to asynchronous events emitted from reading a file, a web service call, querying a data- base, pushing system notifications, handling user input, traversing a collection of ele- ments, or even parsing a simple string. Reactive programming unifies all of these data providers into a single concept called an observable stream, using the Rx.Observable
  331  <p className="pag">Page 230</p>
  332  object. A stream is a sequence of ordered events happening over time. To extract its value, you must subscribe to it. Let’s look at some examples:
  ...
  340  As you can see from these examples, you can work with any type of data in the exact same manner using Rx.Observable, because it converts this data into a stream. Rx.Observable wraps or lifts any observable object so that you can map and apply different functions to transform the observed values into the desired output. Hence, it’s a monad.
  341  8.4.2 Functional and reactive programming
  342: The Rx.Observable object unites the world of functional and reactive programming. It implements the equivalent of the minimal monadic interface you learned about in chapter 5 (map, of, and join) as well as many methods specific to stream manipula- tion. Here’s a quick example:
  343   
  344  
  ...
  347   
  348  To illustrate what’s happening behind the scenes, the diagram in figure 8.12 shows the transformation.
  349: If you hadn’t just read a functional programming book, you would’ve felt that the hardest part about reactive programming is learning to “think reactively.” But think- ing reactively isn’t that different from thinking functionally, just with a different set of tools; so half the battle is won. In fact, there’s so much overlap, that most of the docu- mentation on reactive programming found on the web begins by teaching functional programming techniques. Streams bring declarativeness and chained computations into your code. Hence, reactive programming tends to resemble functional program- ming, giving rise to the term functional reactive programming (FRP).
  350  Suggested reading
  351: Reactive programming has been on the rise since 2013, so a sizeable amount of con- tent is available related to it and FRP. My goal isn't to teach you reactive program- ming, but to demonstrate that reactive programming is really functional programming applied to asynchronous and event-based problems.
  352  If you wish to learn more about reactive programming and the FRP world, you can check out Functional Reactive Programming (Manning 2016) by Stephen Blackheath and Anthony Jones, which you can obtain at https://www.manning.com/books/ functional-reactive-programming. If you're interested in learning about using RxJS with functional programming, I recommend that you read RxJS in Action (Manning, forthcoming 2017) by Paul Daniels and Luis Atencio, which you can begin reading using the Manning Early Access Program (MEAP) at https://www.manning.com/ books/rxjs-in-action.
  353  Now that you understand observables, let’s use RxJS to handle user input. When you need to interact with and capture events from many different sources, you can easily get into code that’s tangled and hard to read. Consider a simple example of reading and validating an SSN field:
  ...
  361  //-> 444-44-4444 Valid
  362  </pre>
  363: Because the change event happens asynchronously, you’re forced to write all the busi- ness logic in a single callback function. As you saw earlier in the chapter, this doesn’t scale if you continue to pile on more event-handling code for every button, field, and link on the page. Your only opportunity for reuse will be to refactor and pull out core logic from the callback. How can you scale this so that your code’s complexity doesn’t grow in proportion to adding more logic?
  364: Just as with asynchronous code, you can’t force functional programming to coop- erate nicely with traditional event-based functions—both paradigms are diverse. The same way promises solved the impedance mismatch between functional and asynchro- nous functions, you need the layer of abstraction provided by Rx.Observable to bridge the world of events to the functional world. This example code that listens for change events fired over time as the user updates a student SSN input field can be modeled as a stream (see figure 8.13).
  365   
  366  Figure 8.13 Shows the event values for SSN treated as an observable stream created from subscribing to the change event of the student SSN input field
  ...
  381  <li className="litag">	Promises provide a functional solution to callback-driven design, which has plagued JavaScript programs for a long time.</li>
  382  <li className="litag">	Promises gives you the ability to chain as well as compose functions “in the future,” abstracting out the low-level intricacies of temporally dependent code.</li>
  383: <li className="litag">	Generators take another approach to asynchronous code by providing pro- gramming artifacts, backed by lazy iterators, that allow you to yield for data to be available.</li>
  384: <li className="litag">	Functional reactive programming raises the level of abstraction of your pro- grams so that you can focus on treating events as logically independent units. This lets you focus on your task at hand instead of coping with complex imple- mentation details.</li>
  385  

C:\Users\Emanuela\FunctionalP\pages\destry.js:
    6  
    7  Can you see the similarity between listing 1.7 and programming with chains in
    8: list- ing 1.5? This shows that whether you’re processing a collection of
    9  elements or user input, it’s all abstracted out and treated in the exact same
   10  manner. I have much more to say about this in chapter 8.   Uno de los robos de
   11  balón más importantes es que todas las operaciones que se realizan en la
   12: lista- Ing 1.7 son completamente inmutable, y toda la lógica de negocio se
   13: segregan en funciones indi- viduo. Usted no tiene que usar funcional con
   14  reactivos, pero pensando funcionalmente te obliga a hacerlo, y cuando lo hace,
   15  se desbloquea una arquitectura realmente sorprendentes sobre la base de la
   ..
   17  
   18  One of the most important takeaways is that all the operations performed in
   19: list- ing 1.7 are completely immutable, and all the business logic is
   20: segregated into individ- ual functions. You don’t have to use functional with
   21  reactive, but thinking functionally forces you to do so—and when you do, you
   22  unlock a truly amazing architecture based on functional reactive programming
   ..
   28  citar al principio de este capítulo. De hecho, una gran cantidad de
   29  aplicaciones pueden beneficiarse del uso de FP junto a una arquitectura
   30: orientada a objetos. Debido al control rígido para bilidad immuta- y estado
   31  compartido, FP también es conocido por hacer la programación multihilo más
   32  sencillo. Debido a que JavaScript es una plataforma de un solo subproceso,
   ..
   40  way you tackle solutions to any programming challenges. So is FP a replacement
   41  for the more popular object-oriented design? Fortunately, applying functional
   42: program- ming to your code isn’t an all-or-nothing approach, as noted in the
   43  Michael Feathers quote at the beginning of this chapter. In fact, lots of
   44  applications can benefit from using FP alongside an object-oriented
   45: architecture. Due to rigid control for immuta- bility and shared state, FP is
   46  also known for making multithreaded programming more straightforward. Because
   47  JavaScript is a single-threaded platform, this isn’t something we need to
   ..
   60  
   61  In this chapter, I briefly touched on topics that will be covered in depth
   62: through- out the book as you sink deeper into a functional frame of mind. If
   63: you’ve been fol- lowing all the concepts so far, that’s great, but don’t worry
   64  if you missed a few things— that just means you’ve picked up the right book.
   65: In traditional OOP, you’re accus- tomed to programming in the
   66  imperative/procedural style; changing this will require you to make a drastic
   67  shift in your thought processes as you begin to tackle problems the
   ..
   89  Puede reducir la complejidad de los programas basados en eventos combinando
   90  funcionalidad con programación reactiva.  You can reduce the complexity of
   91: event-based programs by combining func- tional with reactive programming.
   92  
   93  

C:\Users\Emanuela\FunctionalP\pages\index.html:
   29  <li class="littag"> This fine-grained function reuse is a strategy for increasing your productivity, because you can dramatically reduce the footprint of code that must be actively managed.</li>
   30  <li class="littag"> You enhance the code’s readability by following a declarative style that provides a clear view of the high-level steps carried out by this program.</li>
   31: <li class="littag"> More important, interaction with the HTML objects is moved into its own func- tion, isolating the pure from the non-pure (impure) behavior. I explain curry- ing and managing pure and impure parts in depth in chapter 4.</li>
   32  <li class="littag"> Encourage you to decompose tasks into simple functions</li>
   33  <li class="littag"> Process data using fluent chains</li>
   ..
   40  <li class="littag"> Data processing in a collection of elements is done fluently via function chains that link operations such as map and reduce.</li>
   41  <li class="littag"> Functional programming treats functions as building blocks by relying on first-class, higher-order functions to improve the modularity and reusability of your code.</li>
   42: <li class="littag"> You can reduce the complexity of event-based programs by combining func- tional with reactive programming.</li>

C:\Users\Emanuela\FunctionalP\pages\intro.js:
   18  acknowledgments xvii
   19  about this book xix
   20: PART 1 1 - THINK FUNCTIONALLY	1
   21  Becoming functional 3
   22  1.1	Can functional programming help? 5
   ..
   39  Problems with the global scope 47 ■ JavaScript’s function scope 48 ■ A pseudo-block scope 49 ■ Practical applications of closures 50
   40  2.5	Summary 53
   41: PART 2 GET FUNCTIONAL - 55
   42  
   43  3
   ..
  111  Managing asynchronous events and data 205
  112  8.1	Challenges of asynchronous code 206
  113: Creating temporal dependencies among functions 207 Falling into a callback pyramid 208 ■ Using continuation- passing style 210
  114  8.2	First-class asynchronous behavior with promises 214
  115  Future method chains 216 ■ Composing synchronous and asynchronous behavior 221
  ...
  121  appendix JavaScript libraries used in this book 235 index 239
  122  preface
  123: When I was in college and graduate school, my class schedule was focused on object- oriented design as the sole methodology for planning and architecting software sys- tems. And, like many developers, I began my career writing object-oriented code and building entire systems based on this paradigm.
  124: Throughout my development career, I’ve learned and followed programming lan- guages closely, not only because I want to learn something cool, but also because I’m intrigued by the design decisions and philosophy that each language fosters. Just as a new language provides a different perspective on how to approach software problems, a new paradigm can achieve the same effect. Although the object-oriented approach continues to be the modus operandi of software design, learning about functional programming will open your eyes to new techniques that you can use on their own or in parallel with any other design paradigm that fits your application.
  125: Functional programming has been around for years, but to me it was only a minor distraction. I had heard and read about the benefits of Haskell, Lisp, Scheme, and, more recently, Scala, Clojure, and F# in terms of expressiveness and being highly pro- ductive platforms; even Java, which has traditionally been known as a verbose language, has functional artifacts that make code more succinct. Eventually, the minor distrac- tion became impossible to avoid. And guess what? JavaScript, that object-oriented language everyone uses, can be turned around 180 degrees and used functionally. It turns out that this is the most powerful and effective way to use JavaScript. It took me a long time to discover this, and in this book I want to make you aware of it so you don’t have go on wondering why your JavaScript code is becoming so complex.
  126  Page xv
  127  Page xvi
  128: Throughout my journey as a developer, I’ve learned how to use functional pro- gramming principles to create code that is modular, expressive, robust, easy to reason about, and simple to test. Without a doubt, this has changed me as a software engi- neer, so I wanted to capture and jot down my experiences somehow—perhaps in a book. Naturally, I approached Manning, with the idea of writing a functional pro- gramming book using the Dart programming language. I was playing around with Dart at the time and thought that combining it with my functional background would be a fun, unexplored, uncharted territory. I wrote a proposal, and a week later I had an interview. During the interview, I learned that Manning was seeking a person to write a book about functional programming in JavaScript. Because JavaScript is a lan- guage I’m very much obsessed with, to say the least, I was thrilled to jump into this opportunity. By writing this book, I hope to help you develop the same skills and take your development in a new direction.
  129  acknowledgments
  130: Writing a book is not a trivial undertaking, and the tireless collaboration of many peo- ple with a variety of talents brought to life the manuscript you’re holding (or reading onscreen).
  131  The staff at Manning were incredible and instrumental in obtaining the level of quality we all hoped for, and I thank all of them from the bottom of my heart. Without them, this book would not have been possible. Special thanks to Marjan Bace and Mike Stephens for believing in the idea of this book and in me as an author; to Marina Michaels, for giving me a map and a flashlight to navigate this maze of book-writing challenges; to Susan Conant, for bringing me up to speed and teaching me my first lessons about what it means to write a technical book; to Bert Bates, for giving me my initial sparks of creativity and for his amazing insights on how to teach programming; and to everyone on the editorial and production teams, including Mary Piergies, Janet Vail, Kevin Sullivan, Tiffany Taylor, Katie Tennant, Dennis Dalinnik, and many others who worked behind the scenes.
  132: I can’t thank enough the amazing group of technical peer reviewers led by Aleksandar Dragosavljevic—Amy Teng, Andrew Meredith, Becky Huett, Daniel Lamb, David Barkol, Ed Griebel, Efran Cobisi, Ezra Simeloff, John Shea, Ken Fukuyama, Peter Edwards, Subhasis Ghosh, Tanner Slayton, Thorsten Szutzkus, Wilfredo Manrique, William E. Wheeler, and Yiling Lu—and the talented forum contributors. Their con- tributions included catching technical mistakes, errors in terminology, and typos, and making topic suggestions. Each pass through the review process and each piece of feedback implemented through the forum topics shaped and molded the manuscript.
  133  Page xvii
  134  Page xviii
  135  On the technical side, special thanks to Dean Iverson, who served as the book’s technical editor; Daniel Lamb, who served as the book’s technical proofreader; and Brian Hanafee, for his thorough and in-depth evaluation of the entire book. They are the best technical editors I could have hoped for.
  136: Last but not least, I thank my wife for always supporting me, and my family for pushing me to become better every day and not asking why I didn’t call as often to check in while I was writing this book. Also, thanks go to my colleagues at work for purchasing early releases of the chapters. I am grateful to have the pleasure of work- ing alongside such wonderful people.
  137  about this book
  138: Complexity is a huge beast to tame, and we’ll never get rid of it entirely; it will always be an aspect of software development. I’ve spent countless hours and immeasurable brainpower trying to understand what a particular piece of code does. The secret is to control the complexity so it doesn’t grow in proportion to the size of your code base— and functional programming can help. We’re writing more JavaScript than ever before. We’ve gone from building small client-side event-handling routines, to heavy client- side architectures, to complete isomorphic (server + client) JavaScript applications. Functional programming isn’t a tool—it’s a way of thinking that can apply equally to any of these environments.
  139: This book is designed to teach you how to apply functional programming tech- niques to your code using ECMAScript 6 JavaScript. The material is presented at a gradual, steady pace and covers both theoretical and practical aspects of functional programming. I provide additional information for advanced readers, to help you get deeper into some of the harder concepts.
  140  Roadmap
  141: This book has eight chapters and is divided into three parts that guide you from fun- damental building blocks to more-advanced and practical applications of functional programming.
  142  Page xix
  143  Page xx
  144: Part 1, “Think functionally,” paints a high-level landscape of functional JavaScript. It also discusses core aspects of using JavaScript functionally and thinking like a func- tional programmer:
  145  ■	Chapter 1 introduces some of the core functional concepts that are explained in later chapters and prepares you to make the functional leap. It introduces the main pillars of functional programming, including pure functions, side effects, and declarative programming.
  146  ■	Chapter 2 establishes a level playing field for beginning and intermediate JavaScript developers and acts as a refresher for more-advanced readers. In addition, it’s sprinkled with basic functional programming concepts to prepare you for the techniques discussed in part 2.
  147: Part 2, “Get functional,” focuses on core functional programming techniques, includ- ing function chains, currying, composition, monads, and more:
  148: ■	Chapter 3 introduces function chains and explores writing programs as combi- nations of recursion and high-order functions like map, filter, and reduce. It teaches these concepts using the Lodash.js framework.
  149  ■	Chapter 4 covers the popular techniques of currying and composition, which increase the modulari ty of your code. Using a functional framework such as Ramdajs, composition is the glue that orchestrates your entire JavaScript solution.
  150: ■	Chapter 5 provides a deep dive into more-theoretical areas of functional pro- gramming, with a comprehensive and gradual discussion of functors and monads in the context of error handling.
  151  Part 3, “Enhancing your functional skills,” discusses the practical benefits of using functional programming to tackle real-world challenges:
  152  ■	Chapter 6 reveals the inherent ease with which functional programs can be unit tested. In addition, it introduces a rigorous, automated testing mode called property-based testing.
  153  ■	Chapter 7 takes a look at JavaScript’s memory model, which is used to support the evaluation of functions. This chapter also discusses techniques that help optimize the execution time of functional JavaScript applications.
  154: ■	Chapter 8 introduces some of the main challenges JavaScript developers face on a day-to-day basis when dealing with event-driven and asynchronous behav- ior. It discusses how functional programming can provide elegant solutions to reduce the complexity of existing imperative solutions with a related paradigm known as reactiveprogramming, implemented using RxJS.
  155  Who should read this book
  156: Functional Programming in JavaScript is written for JavaScript developers with at least a basic understanding of object-oriented software and a general awareness of the chal- lenges of modern web applications. Because JavaScript is such a ubiquitous language,
  157  Page xxi
  158  if you want an introduction to functional programming and prefer a familiar syntax, you can take full advantage of this book instead of learning Haskell. (If you want to ease your way into Haskell, this book isn’t the best resource, because each language has its own idiosyncrasies that are best understood by learning it directly.)
  159  The book will help beginning and intermediate programmers heighten their JavaScript skills with higher-order functions, closures, function currying, composition, as well as new JavaScript ES6 features like lambda expressions, iterators, generators, and promises. Advanced developers will enjoy the comprehensive coverage of monads and reactive programming as well, which can help you implement innovative ways of tackling the arduous task of dealing with event-driven and asynchronous code, taking full advantage of the JavaScript platform.
  160  How to use this book
  161: If you’re a beginner or intermediate JavaScript developer and functional program- ming is new to you, begin with chapter 1. If you’re a strong JavaScript programmer, you can skim through chapter 2 and move quickly into chapter 3, which begins with function chains and overall functional design.
  162  More-advanced users of functional JavaScript typically understand pure functions, currying, and composition, so you may skim chapter 4 and move into functors and monads in chapter 5.
  163  Examples and source code
  164: The code examples in this book use ECMAScript 6 JavaScript, which can run equally well on either the server (Node.js) or the client. Some examples show I/O and browser DOM APIs, but without regard for browser incompatibilities. I assume you have experience interacting at a basic level with HTML pages and the console. No spe- cific browser-based JavaScript is used.
  165  The book makes heavy use of functional JavaScript libraries like Lodashjs, Ramdajs, and others. You can find documentation and installation information in the appendix.
  166  This book contains extensive code listings that showcase functional techniques and, where appropriate, compare imperative versus functional designs. You can find all the code samples at the publisher’s website, https://www.manning.com/books/ functional-programming-in-javascript, and on GitHub at https://github.com/luijar/ functional-programming-js.
  ...
  168  The following conventions are used throughout the book:
  169  ■	Italie typeface is used to reference important terms.
  170: ■	Courier typeface is used to denote code listings, as well as elements and attri- butes, methods names, classes, functions, and other programming artifacts.
  171  ■	Code annotations accompany some of the source code listings, highlighting important concepts.
  172  Page xxii
  173  About the author
  174: Luis Atencio (@luijar) is a staff software engineer for Citrix Systems in Ft. Lauderdale, Florida. He has a B.S. and an M.S. in Computer Science and now works full-time developing and architecting applications using JavaScript, Java, and PHP platforms. Luis is very involved in the community and has presented frequently at local meetups and conferences. He blogs about software engineering at luisatencio.net, writes arti- cles for magazines and DZone, and is also the coauthor of RxJS in Action (forthcoming from Manning in 2017).
  175  Author Online
  176  Purchase of Functional Programming in JavaScript includes free access to a private web forum run by Manning Publications where you can make comments about the book, ask technical questions, and receive help from the author and from other users. To access the forum and subscribe to it, point your web browser to https://www.manning .com/books/functional-programming-in-javascript. This page provides information on how to get on the forum once you are registered, what kind of help is available, and the rules of conduct on the forum.
  ...
  179  Think functionally
  180  t’s highly probable that most of your experience building professional appli-
  181: cations has been with an object-oriented language. You may have heard or read about functional programming in other books, blogs, forums, and magazine articles, but you’ve probably never written any functional code. Don’t worry; this is to be expected. I’ve done most of my development in an object-oriented envi- ronment as well. Writing functional code isn’t difficult, but learning to think functionally and letting go of old habits is. The primary goal of part 1 of this book is to lay the foundation for and prepare your mind to embrace the func- tional techniques discussed in parts 2 and 3.
  182  Chapter 1 discusses what functional programming is and the mindset you need to embrace it; it also introduces some of the most important techniques based on pure functions, immutability, side effects, and referential transparency. These form the backbone of all functional code and will help you transition into functional more easily. Also, these will be the guiding principles that set the stage for many of the design decisions we make in the following chapters.
  183: Chapter 2 provides a first view ofJavaScript as a functional language. Because it’s so ubiquitous and mainstream, it’s an ideal language with which to teach func- tional programming. If you aren’t a strong JavaScript developer, this chapter will bring you up to speed with everything you need to know to understand functional JavaScript, such as higher-order functions, closures, and scoping rules.
  184  
  185  

C:\Users\Emanuela\FunctionalP\pages\Part  3.js:
    1  Part 3
    2  Enhancing your functional skills
    3: Parts 1 and 2 of this book taught you about the tools you need to apply func- tional programming to solve real-world scenarios. You learned new techniques and design patterns, all targeted at eliminating side effects so you can write code that’s modular, extensible, and easy to reason about. In this part of the book, you’ll use this learning to tackle the challenges of unit testing JavaScript applica- tions, optimizing your code under the functional umbrella, and handling the complexities of dealing with asynchronous events and data.
    4: Chapter 6 focuses on unit testing imperative applications and why FP is inher- ently testable and less complex. Achieving referential transparency also leads to an automated testing modality called property-based testing.
    5: Chapter 7 explores the inner workings of JavaScript’s function context as well as the performance considerations that must be taken into account when using deeply nested function closures and recursion. To improve overall appli- cation performance, you’ll learn about lazy evaluation, memoization, and tail- call optimization.
    6  Finally, in chapter 8, you’ll learn more monadic design patterns to combat the increasing complexity of applications. This chapter focuses specifically on two frequent JavaScript tasks: fetching data asynchronously from a server or a database using promises, and cutting down on traditional function callbacks of event-driven programs by approaching them from a reactive mindset using RxJS.
    7  <p className="pag">Page 152</p>
    8: After reading through this entire book, you should be equipped to become suc- cessful at applying functional programming techniques during your professional endeavors.
    9  

C:\Users\Emanuela\FunctionalP\pages\Part 2.js:
    1  Part 2
    2  Get functional
    3: Part 1 answered the two most fundamental questions about this book: Why Functional? And why JavaScript? Now that you understand what functional pro- gramming brings to JavaScript development, I’ll take it up a few notches. In part 2, I’ll build on and discuss all the practical concepts and techniques you need in order to apply functional programming to solve real-world problems. In this part, you’ll learn what it means to “get functional.”
    4  Chapter 3 takes a first look at some comprehensive functional programs by using declarative abstractions such as map, reduce, and filter, with the goal of creating code that’s easy to reason about. It also covers the use of recursion as a means of iterating through different forms of data in a functional style.
    5: Chapter 4 takes the concepts from chapter 3 and applies them to constructing function pipelines to streamline development and write in a point-free style. You’ll learn that the key to building functional code is breaking up complex tasks into small, independent components that can be glued back together to form whole solutions via the principle of compositionality. The result is a modular and reus- able code base.
    6: Finally, in chapter 5 you’ll learn fundamental design patterns that combat the increasing complexity of your applications and error handling. Functional composition is made more reliable and robust with abstract data types like func- tors and monads, which provide a layer of abstraction that makes your code fault-tolerant and resilient to exceptional conditions.
    7  <p className="pag">Page 56</p>
    8: Applying the techniques discovered in part 2 will completely transform the way you code JavaScript. Also, this sets the stage for part 3, which deals with applying functional programming techniques to solve more-complex JavaScript problems involving asyn- chronous data and events.
    9  <p className="pag">Page 57 </p>

833 matches across 14 files


